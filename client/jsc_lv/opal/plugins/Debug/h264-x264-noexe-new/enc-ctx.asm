; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	.\gpl\enc-ctx.cxx
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0FG@EOHGAEB@?3Sun?3Sunday?3Mon?3Monday?3Tue?3Tuesd@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0IH@HPGJLCCK@?3Jan?3January?3Feb?3February?3Mar?3Ma@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05LAPONLG@false?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04LOAJBDKD@true?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EN@CBMLGOH@D?3?2Program?5Files?5?$CIx86?$CJ?2Microsoft@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01GFHCPBMG@C?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02EAOCLKAK@ld?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02BDDLJJBK@lu?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02HIKPPMOK@Ld?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02CLHGNPPK@Lu?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02BBAHNLBA@?$CFp?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01DDCIFGEA@E?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01KGKMHCOC@e?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EM@KKHJFHNK@D?3?2Program?5Files?5?$CIx86?$CJ?2Microsoft@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08EPJLHIJG@bad?5cast?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EN@IBFBLEEG@D?3?2Program?5Files?5?$CIx86?$CJ?2Microsoft@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
CRT$XCA	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCA	ENDS
CRT$XCU	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCU	ENDS
CRT$XCL	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCL	ENDS
CRT$XCC	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCC	ENDS
CRT$XCZ	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCZ	ENDS
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??1bad_exception@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gbad_exception@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _wmemchr
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _wmemcmp
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _wmemcpy
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _wmemmove
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _wmemset
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?copy@?$char_traits@G@std@@SAPAGPAGPBGI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?to_char_type@?$char_traits@G@std@@SAGABG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?to_int_type@?$char_traits@G@std@@SAGABG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?eq_int_type@?$char_traits@G@std@@SA_NABG0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?eof@?$char_traits@G@std@@SAGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$char_traits@D@std@@SAPADPADID@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?to_char_type@?$char_traits@D@std@@SADABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?to_int_type@?$char_traits@D@std@@SAHABD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?eof@?$char_traits@D@std@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1domain_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gdomain_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1invalid_argument@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Ginvalid_argument@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1out_of_range@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gout_of_range@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1runtime_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?what@runtime_error@std@@UBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gruntime_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1overflow_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Goverflow_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1underflow_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gunderflow_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1range_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Grange_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B_DebugHeapString@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_Timevec@std@@QAE@PAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1_Timevec@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4_Timevec@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Getctype@_Locinfo@std@@QBE?AU_Ctypevec@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Getcvt@_Locinfo@std@@QBE?AU_Cvtvec@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Getlconv@_Locinfo@std@@QBEPBUlconv@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Getfalse@_Locinfo@std@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Gettrue@_Locinfo@std@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0id@locale@std@@QAE@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Bid@locale@std@@QAEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Incref@facet@locale@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Decref@facet@locale@std@@QAEPAV123@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1facet@locale@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0facet@locale@std@@IAE@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0locale@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1locale@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gfacet@locale@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0codecvt_base@std@@QAE@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1codecvt_base@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_always_noconv@codecvt_base@std@@MBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_max_length@codecvt_base@std@@MBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_encoding@codecvt_base@std@@MBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gcodecvt_base@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$codecvt@GDH@std@@QAE@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$codecvt@GDH@std@@MAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Init@?$codecvt@GDH@std@@IAEXABV_Locinfo@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_in@?$codecvt@GDH@std@@MBEHAAHPBD1AAPBDPAG3AAPAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_out@?$codecvt@GDH@std@@MBEHAAHPBG1AAPBGPAD3AAPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_unshift@?$codecvt@GDH@std@@MBEHAAHPAD1AAPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_length@?$codecvt@GDH@std@@MBEHABHPBD1I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_always_noconv@?$codecvt@GDH@std@@MBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_max_length@?$codecvt@GDH@std@@MBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_encoding@?$codecvt@GDH@std@@MBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$codecvt@GDH@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ctype_base@std@@QAE@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1ctype_base@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gctype_base@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?is@?$ctype@D@std@@QBE_NFD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$ctype@D@std@@QAE@PBF_NI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$ctype@D@std@@MAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Init@?$ctype@D@std@@IAEXABV_Locinfo@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$ctype@D@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_tolower@?$ctype@D@std@@MBEDD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_toupper@?$ctype@D@std@@MBEDD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_widen@?$ctype@D@std@@MBEDD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_narrow@?$ctype@D@std@@MBEDDD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?table@?$ctype@D@std@@IBEPBFXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?is@?$ctype@G@std@@QBE_NFG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$ctype@G@std@@QAE@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Getcat@?$ctype@G@std@@SAIPAPBVfacet@locale@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$ctype@G@std@@MAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Init@?$ctype@G@std@@IAEXABV_Locinfo@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_is@?$ctype@G@std@@MBE_NFG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_is@?$ctype@G@std@@MBEPBGPBG0PAF@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_scan_is@?$ctype@G@std@@MBEPBGFPBG0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_scan_not@?$ctype@G@std@@MBEPBGFPBG0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_tolower@?$ctype@G@std@@MBEGG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_tolower@?$ctype@G@std@@MBEPBGPAGPBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_toupper@?$ctype@G@std@@MBEGG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_toupper@?$ctype@G@std@@MBEPBGPAGPBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Dowiden@?$ctype@G@std@@IBEGD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_widen@?$ctype@G@std@@MBEGD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_widen@?$ctype@G@std@@MBEPBDPBD0PAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Donarrow@?$ctype@G@std@@IBEDGD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_narrow@?$ctype@G@std@@MBEDGD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_narrow@?$ctype@G@std@@MBEPBGPBG0DPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$ctype@D@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$ctype@G@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1failure@ios_base@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@ios_base@std@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?rdstate@ios_base@std@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setstate@ios_base@std@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?good@ios_base@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?eof@ios_base@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?fail@ios_base@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?exceptions@ios_base@std@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?flags@ios_base@std@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setf@ios_base@std@@QAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setf@ios_base@std@@QAEHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?unsetf@ios_base@std@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?precision@ios_base@std@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?width@ios_base@std@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?width@ios_base@std@@QAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?getloc@ios_base@std@@QBE?AVlocale@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gfailure@ios_base@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gios_base@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?endl@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@1@AAV21@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1sentry@?$basic_istream@GU?$char_traits@G@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0RTPFrame@@QAE@PBEH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPayloadSize@RTPFrame@@QAEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetFrameLen@RTPFrame@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPayloadPtr@RTPFrame@@QAEPAEXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetHeaderSize@RTPFrame@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetPayloadType@RTPFrame@@QAEXE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetTimestamp@RTPFrame@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetMaxPayloadSize@H264Frame@@QAEXG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetTimestamp@H264Frame@@QAEX_K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HasRTPFrames@H264Frame@@QAE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _acosl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _asinl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atanl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atan2l
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ceill
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _cosl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _coshl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _expl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fabsl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _floorl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fmodl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _frexpl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ldexpl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _logl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _log10l
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _modfl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _powl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinhl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sqrtl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanhl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _frexpf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ldexpf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _acosf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _asinf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atanf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atan2f
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ceilf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _cosf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _coshf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _expf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fabsf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _floorf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fmodf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _logf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _log10f
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _modff
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _powf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinhf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sqrtf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanhf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GH264Frame@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$basic_ostream@GU?$char_traits@G@std@@@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?put@?$basic_ostream@GU?$char_traits@G@std@@@std@@QAEAAV12@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?flush@?$basic_ostream@GU?$char_traits@G@std@@@std@@QAEAAV12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$basic_ios@GU?$char_traits@G@std@@@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setstate@?$basic_ios@GU?$char_traits@G@std@@@std@@QAEXH_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?rdbuf@?$basic_ios@GU?$char_traits@G@std@@@std@@QBEPAV?$basic_streambuf@GU?$char_traits@G@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?fill@?$basic_ios@GU?$char_traits@G@std@@@std@@QBEGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0sentry@?$basic_ostream@GU?$char_traits@G@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1sentry@?$basic_ostream@GU?$char_traits@G@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Bsentry@?$basic_ostream@GU?$char_traits@G@std@@@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$basic_streambuf@GU?$char_traits@G@std@@@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?sbumpc@?$basic_streambuf@GU?$char_traits@G@std@@@std@@QAEGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?sgetc@?$basic_streambuf@GU?$char_traits@G@std@@@std@@QAEGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?snextc@?$basic_streambuf@GU?$char_traits@G@std@@@std@@QAEGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?sputc@?$basic_streambuf@GU?$char_traits@G@std@@@std@@QAEGG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?overflow@?$basic_streambuf@GU?$char_traits@G@std@@@std@@MAEGG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pbackfail@?$basic_streambuf@GU?$char_traits@G@std@@@std@@MAEGG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?showmanyc@?$basic_streambuf@GU?$char_traits@G@std@@@std@@MAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?underflow@?$basic_streambuf@GU?$char_traits@G@std@@@std@@MAEGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?uflow@?$basic_streambuf@GU?$char_traits@G@std@@@std@@MAEGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?xsgetn@?$basic_streambuf@GU?$char_traits@G@std@@@std@@MAEHPAGH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?xsputn@?$basic_streambuf@GU?$char_traits@G@std@@@std@@MAEHPBGH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?seekoff@?$basic_streambuf@GU?$char_traits@G@std@@@std@@MAE?AV?$fpos@H@2@JHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?seekpos@?$basic_streambuf@GU?$char_traits@G@std@@@std@@MAE?AV?$fpos@H@2@V32@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setbuf@?$basic_streambuf@GU?$char_traits@G@std@@@std@@MAEPAV12@PAGH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?sync@?$basic_streambuf@GU?$char_traits@G@std@@@std@@MAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?imbue@?$basic_streambuf@GU?$char_traits@G@std@@@std@@MAEXABVlocale@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$basic_istream@GU?$char_traits@G@std@@@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0sentry@?$basic_istream@GU?$char_traits@G@std@@@std@@QAE@AAV12@_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Bsentry@?$basic_istream@GU?$char_traits@G@std@@@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1_Sentry_base@?$basic_istream@GU?$char_traits@G@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$basic_istream@DU?$char_traits@D@std@@@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?overflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pbackfail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?underflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?uflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHPBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?seekoff@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@JHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?seekpos@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@V32@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setbuf@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEPAV12@PADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?sync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?imbue@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_DebugHeapAllocator@D@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_DebugHeapAllocator@D@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$basic_ostream@GU?$char_traits@G@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$basic_ios@GU?$char_traits@G@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$basic_streambuf@GU?$char_traits@G@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$basic_ostream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$basic_ios@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$basic_istream@GU?$char_traits@G@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$basic_istream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_D?$basic_ostream@GU?$char_traits@G@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_D?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_D?$basic_istream@GU?$char_traits@G@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_D?$basic_istream@DU?$char_traits@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@IAEX_NI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_String_val@DV?$_DebugHeapAllocator@D@std@@@std@@IAE@V?$_DebugHeapAllocator@D@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Osfx@?$basic_ostream@GU?$char_traits@G@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$basic_ios@GU?$char_traits@G@std@@@std@@QAEXH_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?tie@?$basic_ios@GU?$char_traits@G@std@@@std@@QBEPAV?$basic_ostream@GU?$char_traits@G@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_Sentry_base@?$basic_ostream@GU?$char_traits@G@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1_Sentry_base@?$basic_ostream@GU?$char_traits@G@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pubsync@?$basic_streambuf@GU?$char_traits@G@std@@@std@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Unlock@?$basic_streambuf@GU?$char_traits@G@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?gptr@?$basic_streambuf@GU?$char_traits@G@std@@@std@@IBEPAGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pptr@?$basic_streambuf@GU?$char_traits@G@std@@@std@@IBEPAGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?egptr@?$basic_streambuf@GU?$char_traits@G@std@@@std@@IBEPAGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?gbump@?$basic_streambuf@GU?$char_traits@G@std@@@std@@IAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?epptr@?$basic_streambuf@GU?$char_traits@G@std@@@std@@IBEPAGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Gninc@?$basic_streambuf@GU?$char_traits@G@std@@@std@@IAEPAGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pbump@?$basic_streambuf@GU?$char_traits@G@std@@@std@@IAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Pninc@?$basic_streambuf@GU?$char_traits@G@std@@@std@@IAEPAGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ipfx@?$basic_istream@GU?$char_traits@G@std@@@std@@QAE_N_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_Sentry_base@?$basic_istream@GU?$char_traits@G@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pubsync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?egptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?gbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?epptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Gninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$fpos@H@std@@QAE@J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?failed@?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@IAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@IAE_NI_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$_DebugHeapAllocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lock@?$basic_streambuf@GU?$char_traits@G@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ffmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDIIII@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADPBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?falsename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?truename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$numpunct@D@std@@MAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_decimal_point@?$numpunct@D@std@@MBEDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_thousands_sep@?$numpunct@D@std@@MBEDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_grouping@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_falsename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_truename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$numpunct@D@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IID@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@IAEXII@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@IAE_NPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Putc@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Putgrouped@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDID@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@D@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??D?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??E?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?decimal_point@?$numpunct@D@std@@QBEDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?thousands_sep@?$numpunct@D@std@@QBEDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?grouping@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$numpunct@D@std@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$_DebugHeapAllocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_DebugHeapDelete@Vfacet@locale@std@@@std@@YAXPAVfacet@locale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$use_facet@V?$ctype@G@std@@@std@@YAABV?$ctype@G@0@ABVlocale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@N@@YANNH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@H@@YAHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@M@@YAMMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@O@@YAOOH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_DebugHeapDelete@Vlocale@std@@@std@@YAXPAVlocale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_DebugHeapDelete@X@std@@YAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocchr@D@std@@YADDPADABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Glocale@std@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHPBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$numpunct@D@std@@QAE@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Init@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEXABV_Locinfo@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E1
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
;	COMDAT _$E3
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
;	COMDAT ??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_R4out_of_range@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVout_of_range@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R2?$codecvt@GDH@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3?$ctype@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@overflow_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@out_of_range@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4?$basic_ostream@GU?$char_traits@G@std@@@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@?$numpunct@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3ios_base@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2domain_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@facet@locale@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVdomain_error@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R3underflow_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4?$codecvt@GDH@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_streambuf@GU?$char_traits@G@std@@@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R2?$ctype@G@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2facet@locale@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2codecvt_base@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVrange_error@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R4ios_base@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$numpunct@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@codecvt_base@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@?$basic_ios@GU?$char_traits@G@std@@@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2length_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2runtime_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4?$basic_ios@GU?$char_traits@G@std@@@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2failure@ios_base@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@bad_alloc@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AV?$ctype@G@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R4?$numpunct@D@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVcodecvt_base@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@exception@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT __CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AV?$basic_istream@DU?$char_traits@D@std@@@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AVios_base@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R4?$basic_istream@GU?$char_traits@G@std@@@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4underflow_error@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2ctype_base@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2overflow_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@A@3BA@?$basic_ios@GU?$char_traits@G@std@@@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@range_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4length_error@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_ostream@GU?$char_traits@G@std@@@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R4?$ctype@D@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3?$basic_ios@GU?$char_traits@G@std@@@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3invalid_argument@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVfailure@ios_base@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R3overflow_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2out_of_range@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$basic_streambuf@GU?$char_traits@G@std@@@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVruntime_error@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AV?$basic_ios@GU?$char_traits@G@std@@@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R2?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$basic_ostream@GU?$char_traits@G@std@@@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3facet@locale@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4overflow_error@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT __TI2?AVbad_cast@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVunderflow_error@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R3runtime_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AV?$ctype@D@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R3?$codecvt@GDH@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AV?$codecvt@GDH@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R3codecvt_base@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@?$basic_ostream@GU?$char_traits@G@std@@@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R13A@3A@?$_Iosb@H@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$basic_ios@GU?$char_traits@G@std@@@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4domain_error@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3?$basic_istream@GU?$char_traits@G@std@@@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3bad_exception@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@?$basic_istream@GU?$char_traits@G@std@@@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2range_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3?$basic_streambuf@GU?$char_traits@G@std@@@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVexception@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCU	ENDS
;	COMDAT ??_R1A@?0A@A@?$ctype@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT __CT??_R0?AVbad_cast@@@8??0bad_cast@@QAE@ABV0@@Z12
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R2ios_base@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4ctype_base@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R3domain_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3?$basic_istream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVbad_exception@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R2bad_exception@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AV?$numpunct@D@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@?$basic_streambuf@GU?$char_traits@G@std@@@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R4?$basic_istream@DU?$char_traits@D@std@@@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4invalid_argument@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4range_error@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@logic_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT __CTA2?AVbad_cast@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R4logic_error@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AV?$_Iosb@H@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R3out_of_range@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVbad_cast@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@runtime_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@invalid_argument@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@ctype_base@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2logic_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@failure@ios_base@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3logic_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R1A@A@3A@ios_base@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3length_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@ios_base@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4bad_exception@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R2?$basic_istream@GU?$char_traits@G@std@@@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@underflow_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3failure@ios_base@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4facet@locale@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4?$basic_streambuf@DU?$char_traits@D@std@@@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ?id@?$numpunct@D@std@@2V0locale@2@A
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCU	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@bad_exception@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@A@3BA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@?$ctype@G@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2underflow_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AUctype_base@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R13?0A@A@?$_Iosb@H@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_istream@GU?$char_traits@G@std@@@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@?$basic_istream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4failure@ios_base@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$ctype@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4?$basic_streambuf@GU?$char_traits@G@std@@@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4?$ctype@G@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3range_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3?$numpunct@D@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@?$codecvt@GDH@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVfacet@locale@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R3ctype_base@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3?$basic_ostream@GU?$char_traits@G@std@@@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_7ios_base@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$basic_ios@GU?$char_traits@G@std@@@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7invalid_argument@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$basic_streambuf@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$codecvt@GDH@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$numpunct@D@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7out_of_range@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_8?$basic_ostream@GU?$char_traits@G@std@@@std@@7B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$ctype@G@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7facet@locale@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$basic_istream@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$basic_streambuf@GU?$char_traits@G@std@@@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7runtime_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_7?$basic_istream@GU?$char_traits@G@std@@@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@G@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_8?$basic_istream@DU?$char_traits@D@std@@@std@@7B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$basic_ostream@GU?$char_traits@G@std@@@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7codecvt_base@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7underflow_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ctype_base@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7overflow_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?collate@?$_Locbase@H@std@@2HB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Stz@?$fpos@H@std@@0HA
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
;	COMDAT ?ctype@?$_Locbase@H@std@@2HB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$ctype@D@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$numpunct@D@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?npos@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@2IB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7bad_exception@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?all@?$_Locbase@H@std@@2HB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?numeric@?$_Locbase@H@std@@2HB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_8?$basic_istream@GU?$char_traits@G@std@@@std@@7B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7failure@ios_base@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7range_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$basic_ios@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_8?$basic_ostream@DU?$char_traits@D@std@@@std@@7B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?time@?$_Locbase@H@std@@2HB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?messages@?$_Locbase@H@std@@2HB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7domain_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?none@?$_Locbase@H@std@@2HB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?monetary@?$_Locbase@H@std@@2HB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R2?$basic_istream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2invalid_argument@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R4?$basic_ios@DU?$char_traits@D@std@@@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@length_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4runtime_error@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4codecvt_base@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3?$ctype@G@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVinvalid_argument@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@domain_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVoverflow_error@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS, CRT$XCU, CRT$XCU
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

PUBLIC	?collate@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::collate
PUBLIC	?ctype@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::ctype
PUBLIC	?monetary@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::monetary
PUBLIC	?numeric@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::numeric
PUBLIC	?time@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::time
PUBLIC	?messages@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::messages
PUBLIC	?all@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::all
PUBLIC	?none@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::none
PUBLIC	?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::skipws
PUBLIC	?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::unitbuf
PUBLIC	?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::uppercase
PUBLIC	?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showbase
PUBLIC	?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpoint
PUBLIC	?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpos
PUBLIC	?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::left
PUBLIC	?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::right
PUBLIC	?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::internal
PUBLIC	?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::dec
PUBLIC	?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::oct
PUBLIC	?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::hex
PUBLIC	?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::scientific
PUBLIC	?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::fixed
PUBLIC	?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::boolalpha
PUBLIC	?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::_Stdio
PUBLIC	?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::adjustfield
PUBLIC	?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::basefield
PUBLIC	?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::floatfield
PUBLIC	?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::goodbit
PUBLIC	?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::eofbit
PUBLIC	?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::failbit
PUBLIC	?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::badbit
PUBLIC	?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::_Hardfail
PUBLIC	?in@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::in
PUBLIC	?out@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::out
PUBLIC	?ate@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::ate
PUBLIC	?app@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::app
PUBLIC	?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::trunc
PUBLIC	?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Nocreate
PUBLIC	?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Noreplace
PUBLIC	?binary@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::binary
PUBLIC	?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::beg
PUBLIC	?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::cur
PUBLIC	?end@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::end
;	COMDAT ?collate@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?collate@?$_Locbase@H@std@@2HB DD 01H			; std::_Locbase<int>::collate
CONST	ENDS
;	COMDAT ?ctype@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?ctype@?$_Locbase@H@std@@2HB DD 02H			; std::_Locbase<int>::ctype
CONST	ENDS
;	COMDAT ?monetary@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?monetary@?$_Locbase@H@std@@2HB DD 04H			; std::_Locbase<int>::monetary
CONST	ENDS
;	COMDAT ?numeric@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?numeric@?$_Locbase@H@std@@2HB DD 08H			; std::_Locbase<int>::numeric
CONST	ENDS
;	COMDAT ?time@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?time@?$_Locbase@H@std@@2HB DD 010H			; std::_Locbase<int>::time
CONST	ENDS
;	COMDAT ?messages@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?messages@?$_Locbase@H@std@@2HB DD 020H			; std::_Locbase<int>::messages
CONST	ENDS
;	COMDAT ?all@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?all@?$_Locbase@H@std@@2HB DD 03fH			; std::_Locbase<int>::all
CONST	ENDS
;	COMDAT ?none@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?none@?$_Locbase@H@std@@2HB DD 00H			; std::_Locbase<int>::none
CONST	ENDS
;	COMDAT ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01H		; std::_Iosb<int>::skipws
CONST	ENDS
;	COMDAT ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02H	; std::_Iosb<int>::unitbuf
CONST	ENDS
;	COMDAT ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04H	; std::_Iosb<int>::uppercase
CONST	ENDS
;	COMDAT ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08H	; std::_Iosb<int>::showbase
CONST	ENDS
;	COMDAT ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 010H	; std::_Iosb<int>::showpoint
CONST	ENDS
;	COMDAT ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 020H	; std::_Iosb<int>::showpos
CONST	ENDS
;	COMDAT ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 040H		; std::_Iosb<int>::left
CONST	ENDS
;	COMDAT ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 080H		; std::_Iosb<int>::right
CONST	ENDS
;	COMDAT ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0100H	; std::_Iosb<int>::internal
CONST	ENDS
;	COMDAT ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0200H		; std::_Iosb<int>::dec
CONST	ENDS
;	COMDAT ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0400H		; std::_Iosb<int>::oct
CONST	ENDS
;	COMDAT ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0800H		; std::_Iosb<int>::hex
CONST	ENDS
;	COMDAT ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01000H	; std::_Iosb<int>::scientific
CONST	ENDS
;	COMDAT ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02000H	; std::_Iosb<int>::fixed
CONST	ENDS
;	COMDAT ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04000H	; std::_Iosb<int>::boolalpha
CONST	ENDS
;	COMDAT ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08000H	; std::_Iosb<int>::_Stdio
CONST	ENDS
;	COMDAT ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01c0H	; std::_Iosb<int>::adjustfield
CONST	ENDS
;	COMDAT ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0e00H	; std::_Iosb<int>::basefield
CONST	ENDS
;	COMDAT ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::floatfield
CONST	ENDS
;	COMDAT ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 00H		; std::_Iosb<int>::goodbit
CONST	ENDS
;	COMDAT ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 01H		; std::_Iosb<int>::eofbit
CONST	ENDS
;	COMDAT ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 02H		; std::_Iosb<int>::failbit
CONST	ENDS
;	COMDAT ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 04H		; std::_Iosb<int>::badbit
CONST	ENDS
;	COMDAT ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B DD 010H	; std::_Iosb<int>::_Hardfail
CONST	ENDS
;	COMDAT ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?in@?$_Iosb@H@std@@2W4_Openmode@12@B DD 01H		; std::_Iosb<int>::in
CONST	ENDS
;	COMDAT ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?out@?$_Iosb@H@std@@2W4_Openmode@12@B DD 02H		; std::_Iosb<int>::out
CONST	ENDS
;	COMDAT ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 04H		; std::_Iosb<int>::ate
CONST	ENDS
;	COMDAT ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?app@?$_Iosb@H@std@@2W4_Openmode@12@B DD 08H		; std::_Iosb<int>::app
CONST	ENDS
;	COMDAT ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B DD 010H		; std::_Iosb<int>::trunc
CONST	ENDS
;	COMDAT ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 040H	; std::_Iosb<int>::_Nocreate
CONST	ENDS
;	COMDAT ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B DD 080H	; std::_Iosb<int>::_Noreplace
CONST	ENDS
;	COMDAT ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B DD 020H	; std::_Iosb<int>::binary
CONST	ENDS
;	COMDAT ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 00H		; std::_Iosb<int>::beg
CONST	ENDS
;	COMDAT ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 01H		; std::_Iosb<int>::cur
CONST	ENDS
;	COMDAT ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 02H		; std::_Iosb<int>::end
CONST	ENDS
CONST	SEGMENT
_h264_levels DD	0aH
	DD	05cdH
	DD	063H
	DD	025200H
	DD	0fa00H
	DD	0afH
	DD	040H
	DD	040H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	09H
	DD	05cdH
	DD	063H
	DD	025200H
	DD	01f400H
	DD	015eH
	DD	040H
	DD	040H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	0bH
	DD	0bb8H
	DD	018cH
	DD	054600H
	DD	02ee00H
	DD	01f4H
	DD	080H
	DD	040H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	0cH
	DD	01770H
	DD	018cH
	DD	0dec00H
	DD	05dc00H
	DD	03e8H
	DD	080H
	DD	040H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	0dH
	DD	02e68H
	DD	018cH
	DD	0dec00H
	DD	0bb800H
	DD	07d0H
	DD	080H
	DD	040H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	014H
	DD	02e68H
	DD	018cH
	DD	0dec00H
	DD	01e8480H
	DD	07d0H
	DD	080H
	DD	040H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	015H
	DD	04d58H
	DD	0318H
	DD	01bd800H
	DD	03d0900H
	DD	0fa0H
	DD	0100H
	DD	040H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	016H
	DD	04f1aH
	DD	0654H
	DD	02f7600H
	DD	03d0900H
	DD	0fa0H
	DD	0100H
	DD	040H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01eH
	DD	09e34H
	DD	0654H
	DD	02f7600H
	DD	0989680H
	DD	02710H
	DD	0100H
	DD	020H
	DD	016H
	DD	00H
	DD	01H
	DD	00H
	DD	01fH
	DD	01a5e0H
	DD	0e10H
	DD	0697800H
	DD	0d59f80H
	DD	036b0H
	DD	0200H
	DD	010H
	DD	03cH
	DD	01H
	DD	01H
	DD	00H
	DD	020H
	DD	034bc0H
	DD	01400H
	DD	0780000H
	DD	01312d00H
	DD	04e20H
	DD	0200H
	DD	010H
	DD	03cH
	DD	01H
	DD	01H
	DD	00H
	DD	028H
	DD	03c000H
	DD	02000H
	DD	0c00000H
	DD	01312d00H
	DD	061a8H
	DD	0200H
	DD	010H
	DD	03cH
	DD	01H
	DD	01H
	DD	00H
	DD	029H
	DD	03c000H
	DD	02000H
	DD	0c00000H
	DD	02faf080H
	DD	0f424H
	DD	0200H
	DD	010H
	DD	018H
	DD	01H
	DD	01H
	DD	00H
	DD	02aH
	DD	07f800H
	DD	02200H
	DD	0cc0000H
	DD	02faf080H
	DD	0f424H
	DD	0200H
	DD	010H
	DD	018H
	DD	01H
	DD	01H
	DD	01H
	DD	032H
	DD	090000H
	DD	05640H
	DD	0286e000H
	DD	080befc0H
	DD	020f58H
	DD	0200H
	DD	010H
	DD	018H
	DD	01H
	DD	01H
	DD	01H
	DD	033H
	DD	0f0000H
	DD	09000H
	DD	04380000H
	DD	0e4e1c00H
	DD	03a980H
	DD	0200H
	DD	010H
	DD	018H
	DD	01H
	DD	01H
	DD	01H
	DD	00H
	ORG $+44
$SG9450	DB	'auto', 00H
	ORG $+3
$SG9449	DB	'temporal', 00H
	ORG $+3
$SG9448	DB	'spatial', 00H
$SG9447	DB	'none', 00H
	ORG $+3
$SG9456	DB	'tesa', 00H
	ORG $+3
$SG9455	DB	'esa', 00H
$SG9454	DB	'umh', 00H
$SG9453	DB	'hex', 00H
$SG9452	DB	'dia', 00H
$SG9460	DB	'normal', 00H
	ORG $+1
$SG9459	DB	'strict', 00H
	ORG $+1
$SG9458	DB	'none', 00H
	ORG $+3
$SG9464	DB	'crop', 00H
	ORG $+3
$SG9463	DB	'show', 00H
	ORG $+3
$SG9462	DB	'undef', 00H
	ORG $+2
$SG9471	DB	'undef', 00H
	ORG $+2
$SG9470	DB	'mac', 00H
$SG9469	DB	'secam', 00H
	ORG $+2
$SG9468	DB	'ntsc', 00H
	ORG $+3
$SG9467	DB	'pal', 00H
$SG9466	DB	'component', 00H
	ORG $+2
$SG9474	DB	'on', 00H
	ORG $+1
$SG9473	DB	'off', 00H
$SG9484	DB	'film', 00H
	ORG $+3
$SG9483	DB	'smpte240m', 00H
	ORG $+2
$SG9482	DB	'smpte170m', 00H
	ORG $+2
$SG9481	DB	'bt470bg', 00H
$SG9480	DB	'bt470m', 00H
$SG9479	DB	00H
$SG9478	DB	'undef', 00H
	ORG $+2
$SG9477	DB	'bt709', 00H
$SG9476	DB	00H
	ORG $+1
$SG9496	DB	'log316', 00H
	ORG $+1
$SG9495	DB	'log100', 00H
	ORG $+1
$SG9494	DB	'linear', 00H
	ORG $+1
$SG9493	DB	'smpte240m', 00H
	ORG $+2
$SG9492	DB	'smpte170m', 00H
	ORG $+2
$SG9491	DB	'bt470bg', 00H
$SG9490	DB	'bt470m', 00H
$SG9489	DB	00H
$SG9488	DB	'undef', 00H
	ORG $+2
$SG9487	DB	'bt709', 00H
$SG9486	DB	00H
	ORG $+1
$SG9506	DB	'YCgCo', 00H
	ORG $+2
$SG9505	DB	'smpte240m', 00H
	ORG $+2
$SG9504	DB	'smpte170m', 00H
	ORG $+2
$SG9503	DB	'bt470bg', 00H
$SG9502	DB	'fcc', 00H
$SG9501	DB	00H
	ORG $+3
$SG9500	DB	'undef', 00H
	ORG $+2
$SG9499	DB	'bt709', 00H
	ORG $+2
$SG9498	DB	'GBR', 00H
$SG10597 DB	'H264', 09H, 'x264', 09H, 00H
	ORG $+1
$SG10654 DB	'.\gpl\enc-ctx.cxx', 00H
	ORG $+2
$SG10659 DB	'.\gpl\enc-ctx.cxx', 00H
	ORG $+2
$SG10672 DB	'H264', 09H, 'Encoder', 09H, 'Couldn''t init x264 encoder'
	DB	00H
$SG10673 DB	'.\gpl\enc-ctx.cxx', 00H
	ORG $+2
$SG10678 DB	'H264', 09H, 'Encoder', 09H, 'x264 encoder successfully o'
	DB	'pened', 00H
	ORG $+2
$SG10679 DB	'.\gpl\enc-ctx.cxx', 00H
	ORG $+2
$SG10687 DB	' Frames', 00H
$SG10688 DB	'H264', 09H, 'Encoder', 09H, 'Closed H.264 encoder, encod'
	DB	'ed ', 00H
$SG10689 DB	'.\gpl\enc-ctx.cxx', 00H
	ORG $+2
$SG10753 DB	'H264', 09H, 'Cap', 09H, 'Illegal Level negotiated', 00H
	ORG $+2
$SG10754 DB	'.\gpl\enc-ctx.cxx', 00H
	ORG $+2
$SG10769 DB	'H264', 09H, 'Encoder', 09H, 'Couldn''t init x264 encoder'
	DB	00H
$SG10770 DB	'.\gpl\enc-ctx.cxx', 00H
	ORG $+2
$SG10775 DB	'H264', 09H, 'Encoder', 09H, 'x264 encoder successfully o'
	DB	'pened', 00H
	ORG $+2
$SG10776 DB	'.\gpl\enc-ctx.cxx', 00H
	ORG $+2
$SG10795 DB	'H264', 09H, 'Encoder', 09H, 'Video grab too small, Close'
	DB	' down video transmission thread', 00H
$SG10796 DB	'.\gpl\enc-ctx.cxx', 00H
	ORG $+6
$SG10804 DB	'H264', 09H, 'Encoder', 09H, 'Video grab of partial frame'
	DB	' unsupported, Close down video transmission thread', 00H
	ORG $+1
$SG10805 DB	'.\gpl\enc-ctx.cxx', 00H
	ORG $+2
$SG10832 DB	'H264', 09H, 'Encoder', 09H, 'Encoding failed', 00H
	ORG $+3
$SG10833 DB	'.\gpl\enc-ctx.cxx', 00H
CONST	ENDS
PUBLIC	?endl@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@1@AAV21@@Z ; std::endl
PUBLIC	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
PUBLIC	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
PUBLIC	??0X264EncoderContext@@QAE@XZ			; X264EncoderContext::X264EncoderContext
PUBLIC	?SetMaxRTPFrameSize@X264EncoderContext@@QAEXI@Z	; X264EncoderContext::SetMaxRTPFrameSize
PUBLIC	?SetMaxKeyFramePeriod@X264EncoderContext@@QAEXI@Z ; X264EncoderContext::SetMaxKeyFramePeriod
PUBLIC	?SetTargetBitrate@X264EncoderContext@@QAEXI@Z	; X264EncoderContext::SetTargetBitrate
PUBLIC	?SetFrameWidth@X264EncoderContext@@QAEXI@Z	; X264EncoderContext::SetFrameWidth
PUBLIC	?SetFrameHeight@X264EncoderContext@@QAEXI@Z	; X264EncoderContext::SetFrameHeight
PUBLIC	?SetFrameRate@X264EncoderContext@@QAEXI@Z	; X264EncoderContext::SetFrameRate
PUBLIC	?SetTSTO@X264EncoderContext@@QAEXI@Z		; X264EncoderContext::SetTSTO
PUBLIC	?SetProfileLevel@X264EncoderContext@@QAEXI@Z	; X264EncoderContext::SetProfileLevel
EXTRN	_memset:NEAR
EXTRN	?Start@Trace@@SAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@PBDH@Z:NEAR ; Trace::Start
EXTRN	?CanTrace@Trace@@SA_NI@Z:NEAR			; Trace::CanTrace
EXTRN	__RTC_InitBase:NEAR
EXTRN	__RTC_Shutdown:NEAR
EXTRN	??2@YAPAXI@Z:NEAR				; operator new
EXTRN	??3@YAXPAX@Z:NEAR				; operator delete
EXTRN	__except_list:DWORD
EXTRN	__RTC_CheckEsp:NEAR
EXTRN	__fltused:NEAR
EXTRN	___CxxFrameHandler:NEAR
EXTRN	_x264_param_default:NEAR
EXTRN	_x264_encoder_open_79:NEAR
EXTRN	??0H264Frame@@QAE@XZ:NEAR			; H264Frame::H264Frame
;	COMDAT rtc$IMZ
; File d:\chy\projects\my\eqcores2\opal\plugins\video\h.264\gpl\enc-ctx.cxx
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
xdata$x	SEGMENT
$T13434	DD	0ffffffffH
	DD	FLAT:$L13425
$T13429	DD	019930520H
	DD	01H
	DD	FLAT:$T13434
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
_TEXT	SEGMENT
tv74 = -28						; size = 4
$T13416 = -24						; size = 4
$T13415 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0X264EncoderContext@@QAE@XZ PROC NEAR			; X264EncoderContext::X264EncoderContext
; _this$ = ecx

; 65   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0X264EncoderContext@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR _this$[ebp], ecx

; 66   :   _frameCounter=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+684], 0

; 67   :   _PFramesSinceLastIFrame = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+676], 0

; 68   : 
; 69   :   _txH264Frame = new H264Frame();

	push	56					; 00000038H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T13416[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T13416[ebp], 0
	je	SHORT $L13417
	mov	ecx, DWORD PTR $T13416[ebp]
	call	??0H264Frame@@QAE@XZ			; H264Frame::H264Frame
	mov	DWORD PTR tv74[ebp], eax
	jmp	SHORT $L13418
$L13417:
	mov	DWORD PTR tv74[ebp], 0
$L13418:
	mov	edx, DWORD PTR tv74[ebp]
	mov	DWORD PTR $T13415[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T13415[ebp]
	mov	DWORD PTR [eax+672], ecx

; 70   : 
; 71   :   memset( &_inputFrame,0, sizeof( _inputFrame ) );

	push	64					; 00000040H
	push	0
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 608				; 00000260H
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 72   :   _inputFrame.i_type = X264_TYPE_AUTO;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+608], 0

; 73   :   _inputFrame.i_qpplus1 = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+612], 0

; 74   :   _inputFrame.img.i_csp = X264_CSP_I420;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+628], 1

; 75   :  
; 76   :    X264_PARAM_DEFAULT(&_context);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	push	eax
	call	_x264_param_default
	add	esp, 4

; 77   : 
; 78   :   // Default
; 79   :   // ABR with bit rate tolerance = 1 is CBR...
; 80   :   _context.rc.i_rc_method = X264_RC_ABR;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+464], 2

; 81   :   _context.rc.f_rate_tolerance = 1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+492], 1065353216		; 3f800000H

; 82   :   _context.rc.i_lookahead = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+528], 0

; 83   : 
; 84   :   // No aspect ratio correction
; 85   :   _context.vui.i_sar_width = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+44], 0

; 86   :   _context.vui.i_sar_height = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+40], 0

; 87   : 
; 88   :   // Enable logging
; 89   :   //////_context.pf_log = logCallbackX264;
; 90   :   //////_context.i_log_level = X264_LOG_DEBUG;
; 91   :   //////_context.p_log_private = NULL;
; 92   : 
; 93   :   // Auto detect number of CPUs
; 94   :   _context.i_threads = 0;  

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 95   :   SetFrameWidth       (CIF_WIDTH);

	push	352					; 00000160H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetFrameWidth@X264EncoderContext@@QAEXI@Z ; X264EncoderContext::SetFrameWidth

; 96   :   SetFrameHeight      (CIF_HEIGHT);

	push	288					; 00000120H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetFrameHeight@X264EncoderContext@@QAEXI@Z ; X264EncoderContext::SetFrameHeight

; 97   :   //SetFrameWidth       (640);
; 98   :   //SetFrameHeight      (480);
; 99   :   SetFrameRate        (H264_FRAME_RATE);

	push	30					; 0000001eH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetFrameRate@X264EncoderContext@@QAEXI@Z ; X264EncoderContext::SetFrameRate

; 100  :   SetTargetBitrate    ((unsigned)(H264_BITRATE / 1000));

	push	1024					; 00000400H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTargetBitrate@X264EncoderContext@@QAEXI@Z ; X264EncoderContext::SetTargetBitrate

; 101  :   SetProfileLevel     (H264_PROFILE_LEVEL);

	push	4374541					; 0042c00dH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetProfileLevel@X264EncoderContext@@QAEXI@Z ; X264EncoderContext::SetProfileLevel

; 102  :   SetTSTO             (H264_TSTO);

	push	31					; 0000001fH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetTSTO@X264EncoderContext@@QAEXI@Z	; X264EncoderContext::SetTSTO

; 103  :   SetMaxKeyFramePeriod(H264_KEY_FRAME_INTERVAL);

	push	30					; 0000001eH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetMaxKeyFramePeriod@X264EncoderContext@@QAEXI@Z ; X264EncoderContext::SetMaxKeyFramePeriod

; 104  :   SetMaxRTPFrameSize  (H264_PAYLOAD_SIZE);

	push	900					; 00000384H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetMaxRTPFrameSize@X264EncoderContext@@QAEXI@Z ; X264EncoderContext::SetMaxRTPFrameSize

; 105  : 
; 106  :   //_context.i_maxframes = 0;
; 107  :   //_context.rc.b_stat_write = 0;
; 108  :   //_context.analyse.inter = 0;
; 109  :   _context.analyse.b_psnr = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+456], 0

; 110  : 
; 111  :   _codec = X264_ENCODER_OPEN(&_context);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 4
	push	edx
	call	_x264_encoder_open_79
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 112  :   
; 113  :   if (_codec == NULL) {

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $L10668

; 114  :     TRACE(1, "H264\tEncoder\tCouldn't init x264 encoder");

	push	1
	call	?CanTrace@Trace@@SA_NI@Z		; Trace::CanTrace
	add	esp, 4
	movzx	eax, al
	test	eax, eax
	je	SHORT $L10669
	push	OFFSET FLAT:?endl@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@1@AAV21@@Z ; std::endl
	push	OFFSET FLAT:$SG10672
	push	114					; 00000072H
	push	OFFSET FLAT:$SG10673
	call	?Start@Trace@@SAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@PBDH@Z ; Trace::Start
	add	esp, 8
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
$L10669:

; 115  :   } 
; 116  :   else

	jmp	SHORT $L10662
$L10668:

; 117  :   {
; 118  :     TRACE(4, "H264\tEncoder\tx264 encoder successfully opened");

	push	4
	call	?CanTrace@Trace@@SA_NI@Z		; Trace::CanTrace
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $L10662
	push	OFFSET FLAT:?endl@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@1@AAV21@@Z ; std::endl
	push	OFFSET FLAT:$SG10678
	push	118					; 00000076H
	push	OFFSET FLAT:$SG10679
	call	?Start@Trace@@SAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@PBDH@Z ; Trace::Start
	add	esp, 8
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
$L10662:

; 119  :   }
; 120  : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 28					; 0000001cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
$L13425:
	mov	eax, DWORD PTR $T13416[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$??0X264EncoderContext@@QAE@XZ:
	mov	eax, OFFSET FLAT:$T13429
	jmp	___CxxFrameHandler
text$x	ENDS
??0X264EncoderContext@@QAE@XZ ENDP			; X264EncoderContext::X264EncoderContext
PUBLIC	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
PUBLIC	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\ostream
;	COMDAT ?endl@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@1@AAV21@@Z
_TEXT	SEGMENT
__Ostr$ = 8						; size = 4
?endl@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@1@AAV21@@Z PROC NEAR ; std::endl, COMDAT

; 921  : 	{	// insert newline and flush byte stream

	push	ebp
	mov	ebp, esp

; 922  : 	_Ostr.put('\n');

	push	10					; 0000000aH
	mov	ecx, DWORD PTR __Ostr$[ebp]
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put

; 923  : 	_Ostr.flush();

	mov	ecx, DWORD PTR __Ostr$[ebp]
	call	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush

; 924  : 	return (_Ostr);

	mov	eax, DWORD PTR __Ostr$[ebp]

; 925  : 	}

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
?endl@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@1@AAV21@@Z ENDP ; std::endl
_TEXT	ENDS
PUBLIC	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
PUBLIC	??_GH264Frame@@QAEPAXI@Z			; H264Frame::`scalar deleting destructor'
PUBLIC	??1X264EncoderContext@@QAE@XZ			; X264EncoderContext::~X264EncoderContext
EXTRN	_x264_encoder_close:NEAR
; Function compile flags: /Odt /RTCsu
; File d:\chy\projects\my\eqcores2\opal\plugins\video\h.264\gpl\enc-ctx.cxx
_TEXT	SEGMENT
tv92 = -16						; size = 4
$T13440 = -12						; size = 4
$T13439 = -8						; size = 4
_this$ = -4						; size = 4
??1X264EncoderContext@@QAE@XZ PROC NEAR			; X264EncoderContext::~X264EncoderContext
; _this$ = ecx

; 123  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 124  :     if (_codec != NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L10683

; 125  :     {
; 126  :       X264_ENCODER_CLOSE(_codec);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_x264_encoder_close
	add	esp, 4

; 127  :       TRACE(4, "H264\tEncoder\tClosed H.264 encoder, encoded " << _frameCounter << " Frames" );

	push	4
	call	?CanTrace@Trace@@SA_NI@Z		; Trace::CanTrace
	add	esp, 4
	movzx	eax, al
	test	eax, eax
	je	SHORT $L10683
	push	OFFSET FLAT:?endl@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@1@AAV21@@Z ; std::endl
	push	OFFSET FLAT:$SG10687
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+684]
	push	edx
	push	OFFSET FLAT:$SG10688
	push	127					; 0000007fH
	push	OFFSET FLAT:$SG10689
	call	?Start@Trace@@SAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@PBDH@Z ; Trace::Start
	add	esp, 8
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
$L10683:

; 128  :     }
; 129  :   if (_txH264Frame) delete _txH264Frame;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+672], 0
	je	SHORT $L10682
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+672]
	mov	DWORD PTR $T13440[ebp], edx
	mov	eax, DWORD PTR $T13440[ebp]
	mov	DWORD PTR $T13439[ebp], eax
	cmp	DWORD PTR $T13439[ebp], 0
	je	SHORT $L13441
	push	1
	mov	ecx, DWORD PTR $T13439[ebp]
	call	??_GH264Frame@@QAEPAXI@Z
	mov	DWORD PTR tv92[ebp], eax
	jmp	SHORT $L10682
$L13441:
	mov	DWORD PTR tv92[ebp], 0
$L10682:

; 130  : }

	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1X264EncoderContext@@QAE@XZ ENDP			; X264EncoderContext::~X264EncoderContext
_TEXT	ENDS
EXTRN	??1H264Frame@@QAE@XZ:NEAR			; H264Frame::~H264Frame
; Function compile flags: /Odt /RTCsu
;	COMDAT ??_GH264Frame@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GH264Frame@@QAEPAXI@Z PROC NEAR			; H264Frame::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1H264Frame@@QAE@XZ			; H264Frame::~H264Frame
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $L10696
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L10696:
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_GH264Frame@@QAEPAXI@Z ENDP				; H264Frame::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?SetMaxPayloadSize@H264Frame@@QAEXG@Z		; H264Frame::SetMaxPayloadSize
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_this$ = -4						; size = 4
_size$ = 8						; size = 4
?SetMaxRTPFrameSize@X264EncoderContext@@QAEXI@Z PROC NEAR ; X264EncoderContext::SetMaxRTPFrameSize
; _this$ = ecx

; 133  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 134  :   _txH264Frame->SetMaxPayloadSize(size);

	mov	ax, WORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+672]
	call	?SetMaxPayloadSize@H264Frame@@QAEXG@Z	; H264Frame::SetMaxPayloadSize

; 135  :   _context.i_slice_max_size = size;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _size$[ebp]
	mov	DWORD PTR [edx+588], eax

; 136  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?SetMaxRTPFrameSize@X264EncoderContext@@QAEXI@Z ENDP	; X264EncoderContext::SetMaxRTPFrameSize
; Function compile flags: /Odt /RTCsu
; File d:\chy\projects\my\eqcores2\opal\plugins\video\h.264\shared\h264frame.h
_TEXT	ENDS
;	COMDAT ?SetMaxPayloadSize@H264Frame@@QAEXG@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_maxPayloadSize$ = 8					; size = 2
?SetMaxPayloadSize@H264Frame@@QAEXG@Z PROC NEAR		; H264Frame::SetMaxPayloadSize, COMDAT
; _this$ = ecx

; 161  :   {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 162  :     _maxPayloadSize = maxPayloadSize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR _maxPayloadSize$[ebp]
	mov	WORD PTR [eax+8], cx

; 163  :   }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetMaxPayloadSize@H264Frame@@QAEXG@Z ENDP		; H264Frame::SetMaxPayloadSize
; Function compile flags: /Odt /RTCsu
; File d:\chy\projects\my\eqcores2\opal\plugins\video\h.264\gpl\enc-ctx.cxx
_TEXT	ENDS
_TEXT	SEGMENT
_this$ = -4						; size = 4
_period$ = 8						; size = 4
?SetMaxKeyFramePeriod@X264EncoderContext@@QAEXI@Z PROC NEAR ; X264EncoderContext::SetMaxKeyFramePeriod
; _this$ = ecx

; 139  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 140  :   _IFrameInterval = _context.i_keyint_max = period;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _period$[ebp]
	mov	DWORD PTR [eax+88], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _period$[ebp]
	mov	DWORD PTR [edx+680], eax

; 141  :   _PFramesSinceLastIFrame = _IFrameInterval + 1; // force a keyframe on the first frame

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+680]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+676], edx

; 142  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetMaxKeyFramePeriod@X264EncoderContext@@QAEXI@Z ENDP	; X264EncoderContext::SetMaxKeyFramePeriod
_TEXT	ENDS
PUBLIC	__real@4090000000000000
EXTRN	__ftol2:NEAR
;	COMDAT __real@4090000000000000
CONST	SEGMENT
__real@4090000000000000 DQ 04090000000000000r	; 1024
; Function compile flags: /Odt /RTCsu
CONST	ENDS
_TEXT	SEGMENT
tv85 = -20						; size = 8
_r$ = -12						; size = 8
_this$ = -4						; size = 4
_rate$ = 8						; size = 4
?SetTargetBitrate@X264EncoderContext@@QAEXI@Z PROC NEAR	; X264EncoderContext::SetTargetBitrate
; _this$ = ecx

; 145  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 146  : 	double r = ((double)rate);

	mov	eax, DWORD PTR _rate$[ebp]
	mov	DWORD PTR tv85[ebp], eax
	mov	DWORD PTR tv85[ebp+4], 0
	fild	QWORD PTR tv85[ebp]
	fst	QWORD PTR _r$[ebp]

; 147  :   _context.rc.i_vbv_max_bitrate =(unsigned)(r * 1024 / (1024 + r));

	fmul	QWORD PTR __real@4090000000000000
	fld	QWORD PTR __real@4090000000000000
	fadd	QWORD PTR _r$[ebp]
	fdivp	ST(1), ST(0)
	call	__ftol2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+496], eax

; 148  :   _context.rc.i_bitrate =  (unsigned)((double)(_context.rc.i_vbv_max_bitrate));

	mov	edx, DWORD PTR _this$[ebp]
	fild	DWORD PTR [edx+496]
	call	__ftol2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+484], eax

; 149  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetTargetBitrate@X264EncoderContext@@QAEXI@Z ENDP	; X264EncoderContext::SetTargetBitrate
; Function compile flags: /Odt /RTCsu
_this$ = -4						; size = 4
_width$ = 8						; size = 4
?SetFrameWidth@X264EncoderContext@@QAEXI@Z PROC NEAR	; X264EncoderContext::SetFrameWidth
; _this$ = ecx

; 152  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 153  :   _context.i_width = width;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _width$[ebp]
	mov	DWORD PTR [eax+20], ecx

; 154  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetFrameWidth@X264EncoderContext@@QAEXI@Z ENDP		; X264EncoderContext::SetFrameWidth
; Function compile flags: /Odt /RTCsu
_this$ = -4						; size = 4
_height$ = 8						; size = 4
?SetFrameHeight@X264EncoderContext@@QAEXI@Z PROC NEAR	; X264EncoderContext::SetFrameHeight
; _this$ = ecx

; 157  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 158  :   _context.i_height = height;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _height$[ebp]
	mov	DWORD PTR [eax+24], ecx

; 159  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetFrameHeight@X264EncoderContext@@QAEXI@Z ENDP	; X264EncoderContext::SetFrameHeight
_TEXT	ENDS
PUBLIC	__real@3fe0000000000000
PUBLIC	__real@408f400000000000
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
;	COMDAT __real@408f400000000000
CONST	SEGMENT
__real@408f400000000000 DQ 0408f400000000000r	; 1000
; Function compile flags: /Odt /RTCsu
CONST	ENDS
_TEXT	SEGMENT
tv75 = -12						; size = 8
_this$ = -4						; size = 4
_rate$ = 8						; size = 4
?SetFrameRate@X264EncoderContext@@QAEXI@Z PROC NEAR	; X264EncoderContext::SetFrameRate
; _this$ = ecx

; 162  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 163  :   _context.i_fps_num = (int)((rate + .5) * 1000);

	mov	eax, DWORD PTR _rate$[ebp]
	mov	DWORD PTR tv75[ebp], eax
	mov	DWORD PTR tv75[ebp+4], 0
	fild	QWORD PTR tv75[ebp]
	fadd	QWORD PTR __real@3fe0000000000000
	fmul	QWORD PTR __real@408f400000000000
	call	__ftol2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+76], eax

; 164  :   _context.i_fps_den = 1000;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+80], 1000		; 000003e8H

; 165  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SetFrameRate@X264EncoderContext@@QAEXI@Z ENDP		; X264EncoderContext::SetFrameRate
_TEXT	ENDS
PUBLIC	_log2f
PUBLIC	_logf
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
tv72 = -4						; size = 4
_f$ = 8							; size = 4
_log2f	PROC NEAR

; 171  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 172  : 		return logf( f ) / logf( 2 );

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	call	_logf
	fstp	DWORD PTR tv72[ebp]
	add	esp, 4
	push	1073741824				; 40000000H
	call	_logf
	add	esp, 4
	fdivr	DWORD PTR tv72[ebp]

; 173  : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_log2f	ENDP
_TEXT	ENDS
EXTRN	_log:NEAR
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\math.h
;	COMDAT _logf
_TEXT	SEGMENT
tv70 = -4						; size = 4
__X$ = 8						; size = 4
_logf	PROC NEAR					; COMDAT

; 456  :         {return ((float)log((double)_X)); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	fld	DWORD PTR __X$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_log
	add	esp, 8
	fst	DWORD PTR tv70[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_logf	ENDP
_TEXT	ENDS
PUBLIC	__real@0000000000000000
PUBLIC	_round
EXTRN	_ceil:NEAR
EXTRN	_floor:NEAR
;	COMDAT __real@0000000000000000
; File d:\chy\projects\my\eqcores2\opal\plugins\video\h.264\gpl\enc-ctx.cxx
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
; Function compile flags: /Odt /RTCsu
CONST	ENDS
_TEXT	SEGMENT
tv71 = -8						; size = 8
_value$ = 8						; size = 8
_round	PROC NEAR

; 175  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 176  : 		return value < 0 ? floor(value-0.5) : ceil(value+0.5);

	fld	QWORD PTR _value$[ebp]
	fcomp	QWORD PTR __real@0000000000000000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L13464
	fld	QWORD PTR _value$[ebp]
	fsub	QWORD PTR __real@3fe0000000000000
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_floor
	add	esp, 8
	fstp	QWORD PTR tv71[ebp]
	jmp	SHORT $L13465
$L13464:
	fld	QWORD PTR _value$[ebp]
	fadd	QWORD PTR __real@3fe0000000000000
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_ceil
	add	esp, 8
	fstp	QWORD PTR tv71[ebp]
$L13465:
	fld	QWORD PTR tv71[ebp]

; 177  : 	}

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_round	ENDP
_TEXT	ENDS
PUBLIC	__real@3ff6318c6318c632
PUBLIC	__real@4020000000000000
;	COMDAT __real@3ff6318c6318c632
CONST	SEGMENT
__real@3ff6318c6318c632 DQ 03ff6318c6318c632r	; 1.3871
CONST	ENDS
;	COMDAT __real@4020000000000000
CONST	SEGMENT
__real@4020000000000000 DQ 04020000000000000r	; 8
; Function compile flags: /Odt /RTCsu
CONST	ENDS
_TEXT	SEGMENT
tv81 = -12						; size = 8
_this$ = -4						; size = 4
_tsto$ = 8						; size = 4
?SetTSTO@X264EncoderContext@@QAEXI@Z PROC NEAR		; X264EncoderContext::SetTSTO
; _this$ = ecx

; 182  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 183  :     _context.rc.i_qp_min = H264_MIN_QUANT;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+472], 8

; 184  :     _context.rc.i_qp_max = round ( (double)(51 - H264_MIN_QUANT) / 31 * tsto + H264_MIN_QUANT);

	mov	ecx, DWORD PTR _tsto$[ebp]
	mov	DWORD PTR tv81[ebp], ecx
	mov	DWORD PTR tv81[ebp+4], 0
	fild	QWORD PTR tv81[ebp]
	fmul	QWORD PTR __real@3ff6318c6318c632
	fadd	QWORD PTR __real@4020000000000000
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_round
	add	esp, 8
	call	__ftol2
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+476], eax

; 185  :     _context.rc.i_qp_step = 4;	    

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+480], 4

; 186  : }

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?SetTSTO@X264EncoderContext@@QAEXI@Z ENDP		; X264EncoderContext::SetTSTO
; Function compile flags: /Odt /RTCsu
tv88 = -20						; size = 4
_i$ = -16						; size = 4
_level$ = -12						; size = 4
_profile$ = -8						; size = 4
_this$ = -4						; size = 4
_profileLevel$ = 8					; size = 4
?SetProfileLevel@X264EncoderContext@@QAEXI@Z PROC NEAR	; X264EncoderContext::SetProfileLevel
; _this$ = ecx

; 189  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 190  :   unsigned profile = (profileLevel & 0xff0000) >> 16;

	mov	eax, DWORD PTR _profileLevel$[ebp]
	and	eax, 16711680				; 00ff0000H
	shr	eax, 16					; 00000010H
	mov	DWORD PTR _profile$[ebp], eax

; 191  : //  bool constraint0 = (profileLevel & 0x008000) ? true : false;
; 192  : //  bool constraint1 = (profileLevel & 0x004000) ? true : false;
; 193  : //  bool constraint2 = (profileLevel & 0x002000) ? true : false;
; 194  : //  bool constraint3 = (profileLevel & 0x001000) ? true : false;
; 195  :   unsigned level   = (profileLevel & 0x0000ff);

	mov	ecx, DWORD PTR _profileLevel$[ebp]
	and	ecx, 255				; 000000ffH
	mov	DWORD PTR _level$[ebp], ecx

; 196  : 
; 197  :   int i = 0;

	mov	DWORD PTR _i$[ebp], 0
$L10746:

; 198  :   while (h264_levels[i].level_idc) {

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 48					; 00000030H
	cmp	DWORD PTR _h264_levels[edx], 0
	je	SHORT $L10747

; 199  :     if (h264_levels[i].level_idc == level)

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 48					; 00000030H
	mov	ecx, DWORD PTR _h264_levels[eax]
	cmp	ecx, DWORD PTR _level$[ebp]
	jne	SHORT $L10748

; 200  :       break;

	jmp	SHORT $L10747
$L10748:

; 201  :    i++; 

	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx

; 202  :   }

	jmp	SHORT $L10746
$L10747:

; 203  : 
; 204  :   if (!h264_levels[i].level_idc) {

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 48					; 00000030H
	cmp	DWORD PTR _h264_levels[eax], 0
	jne	SHORT $L10749

; 205  :     TRACE(1, "H264\tCap\tIllegal Level negotiated");

	push	1
	call	?CanTrace@Trace@@SA_NI@Z		; Trace::CanTrace
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $L10750
	push	OFFSET FLAT:?endl@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@1@AAV21@@Z ; std::endl
	push	OFFSET FLAT:$SG10753
	push	205					; 000000cdH
	push	OFFSET FLAT:$SG10754
	call	?Start@Trace@@SAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@PBDH@Z ; Trace::Start
	add	esp, 8
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
$L10750:

; 206  :     return;

	jmp	$L10741
$L10749:

; 207  :   }
; 208  : 
; 209  :   // We make use of the baseline profile, that means:
; 210  :   // no B-Frames (too much latency in interactive video)
; 211  :   // CBR (we want to get the max. quality making use of all the bitrate that is available)
; 212  :   // baseline profile begin
; 213  : #if 1
; 214  :   switch( profile )

	mov	edx, DWORD PTR _profile$[ebp]
	mov	DWORD PTR tv88[ebp], edx
	cmp	DWORD PTR tv88[ebp], 66			; 00000042H
	je	SHORT $L10759
	cmp	DWORD PTR tv88[ebp], 77			; 0000004dH
	je	SHORT $L10760
	cmp	DWORD PTR tv88[ebp], 88			; 00000058H
	je	SHORT $L10760
	jmp	SHORT $L10756
$L10759:

; 215  :   {
; 216  :   case 66:	// base profile
; 217  : 	  _context.analyse.b_transform_8x8 = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+372], 0

; 218  : 	  _context.b_cabac = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+128], 0

; 219  : 	  _context.i_cqm_preset = X264_CQM_FLAT;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+144], 0

; 220  : 	  _context.i_bframe = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+100], 0

; 221  : 	  _context.analyse.i_weighted_pred = X264_WEIGHTP_NONE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+376], 0

; 222  : 	  break;

	jmp	SHORT $L10756
$L10760:

; 223  :   case 77:	// main profile
; 224  :   case 88:
; 225  : 	  _context.i_bframe = 1; 

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+100], 1

; 226  : 	  _context.analyse.b_transform_8x8 = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+372], 0

; 227  : 	  _context.i_cqm_preset = X264_CQM_FLAT;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+144], 0
$L10756:

; 228  : 	  break;
; 229  :   case 100:	// high profile (default settings)
; 230  :   default:
; 231  : 	  break;
; 232  :   }
; 233  : #else
; 234  :   _context.b_cabac = 0;  // Only >= MAIN LEVEL
; 235  :   _context.i_bframe = 0; // Only >= MAIN LEVEL
; 236  :   _context.analyse.i_weighted_pred = 0; // Only >= MAIN LEVEL
; 237  :   _context.analyse.b_transform_8x8 = 0;
; 238  :   if (profile == 77 || profile == 88)
; 239  :   {
; 240  : 	  _context.b_cabac = 1;  
; 241  : 	  _context.i_bframe = 1; 
; 242  : 	  _context.analyse.i_weighted_pred = 1; 
; 243  : 	  _context.analyse.b_transform_8x8 = 1;
; 244  : 
; 245  :   }
; 246  : #endif
; 247  :   // Level:
; 248  :   _context.i_level_idc = level;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _level$[ebp]
	mov	DWORD PTR [edx+32], eax

; 249  :   
; 250  :   // DPB from Level by default
; 251  :   _context.rc.i_vbv_buffer_size = h264_levels[i].cpb;

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 48					; 00000030H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _h264_levels[ecx+20]
	mov	DWORD PTR [edx+500], eax
$L10741:

; 252  :   // MV Range from Level by default  
; 253  : }

	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?SetProfileLevel@X264EncoderContext@@QAEXI@Z ENDP	; X264EncoderContext::SetProfileLevel
_TEXT	ENDS
PUBLIC	?ApplyOptions@X264EncoderContext@@QAEXXZ	; X264EncoderContext::ApplyOptions
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ApplyOptions@X264EncoderContext@@QAEXXZ PROC NEAR	; X264EncoderContext::ApplyOptions
; _this$ = ecx

; 256  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 257  :   X264_ENCODER_CLOSE(_codec);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_x264_encoder_close
	add	esp, 4

; 258  :   _codec = X264_ENCODER_OPEN(&_context);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 4
	push	edx
	call	_x264_encoder_open_79
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 259  :   if (_codec == NULL) {

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $L10765

; 260  :     TRACE(1, "H264\tEncoder\tCouldn't init x264 encoder");

	push	1
	call	?CanTrace@Trace@@SA_NI@Z		; Trace::CanTrace
	add	esp, 4
	movzx	eax, al
	test	eax, eax
	je	SHORT $L10766
	push	OFFSET FLAT:?endl@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@1@AAV21@@Z ; std::endl
	push	OFFSET FLAT:$SG10769
	push	260					; 00000104H
	push	OFFSET FLAT:$SG10770
	call	?Start@Trace@@SAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@PBDH@Z ; Trace::Start
	add	esp, 8
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
$L10766:

; 261  :   } 
; 262  :   else

	jmp	SHORT $L10764
$L10765:

; 263  :   {
; 264  :     TRACE(4, "H264\tEncoder\tx264 encoder successfully opened");

	push	4
	call	?CanTrace@Trace@@SA_NI@Z		; Trace::CanTrace
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $L10764
	push	OFFSET FLAT:?endl@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@1@AAV21@@Z ; std::endl
	push	OFFSET FLAT:$SG10775
	push	264					; 00000108H
	push	OFFSET FLAT:$SG10776
	call	?Start@Trace@@SAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@PBDH@Z ; Trace::Start
	add	esp, 8
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
$L10764:

; 265  :   }
; 266  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?ApplyOptions@X264EncoderContext@@QAEXXZ ENDP		; X264EncoderContext::ApplyOptions
_TEXT	ENDS
PUBLIC	??0RTPFrame@@QAE@PBEH@Z				; RTPFrame::RTPFrame
PUBLIC	?GetPayloadSize@RTPFrame@@QAEIXZ		; RTPFrame::GetPayloadSize
PUBLIC	?GetFrameLen@RTPFrame@@QAEHXZ			; RTPFrame::GetFrameLen
PUBLIC	?GetPayloadPtr@RTPFrame@@QAEPAEXZ		; RTPFrame::GetPayloadPtr
PUBLIC	?GetTimestamp@RTPFrame@@QAEKXZ			; RTPFrame::GetTimestamp
PUBLIC	?SetTimestamp@H264Frame@@QAEX_K@Z		; H264Frame::SetTimestamp
PUBLIC	?HasRTPFrames@H264Frame@@QAE_NXZ		; H264Frame::HasRTPFrames
PUBLIC	?EncodeFrames@X264EncoderContext@@QAEHPBEAAIPAE11@Z ; X264EncoderContext::EncodeFrames
EXTRN	__RTC_UninitUse:NEAR
EXTRN	@_RTC_CheckStackVars@8:NEAR
EXTRN	_x264_encoder_encode:NEAR
EXTRN	?BeginNewFrame@H264Frame@@QAEXXZ:NEAR		; H264Frame::BeginNewFrame
EXTRN	?SetFromFrame@H264Frame@@QAEXPAUx264_nal_t@@H@Z:NEAR ; H264Frame::SetFromFrame
EXTRN	?GetRTPFrame@H264Frame@@QAE_NAAVRTPFrame@@AAI@Z:NEAR ; H264Frame::GetRTPFrame
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
tv231 = -148						; size = 4
$T13479 = -141						; size = 1
_dummyOutput$ = -136					; size = 64
_numberOfNALs$ = -64					; size = 4
_NALs$ = -52						; size = 4
_wantIFrame$ = -41					; size = 1
_header$ = -40						; size = 4
_dstRTP$ = -32						; size = 8
_srcRTP$ = -16						; size = 8
_this$ = -4						; size = 4
_src$ = 8						; size = 4
_srcLen$ = 12						; size = 4
_dst$ = 16						; size = 4
_dstLen$ = 20						; size = 4
_flags$ = 24						; size = 4
?EncodeFrames@X264EncoderContext@@QAEHPBEAAIPAE11@Z PROC NEAR ; X264EncoderContext::EncodeFrames
; _this$ = ecx

; 269  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 148				; 00000094H
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-148]
	mov	ecx, 37					; 00000025H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	BYTE PTR $T13479[ebp], 0

; 270  :   // create RTP frame from source buffer
; 271  :   RTPFrame srcRTP(src, srcLen);

	mov	eax, DWORD PTR _srcLen$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _src$[ebp]
	push	edx
	lea	ecx, DWORD PTR _srcRTP$[ebp]
	call	??0RTPFrame@@QAE@PBEH@Z			; RTPFrame::RTPFrame

; 272  : 
; 273  :   // create RTP frame from destination buffer
; 274  :   RTPFrame dstRTP(dst, dstLen);

	mov	eax, DWORD PTR _dstLen$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _dst$[ebp]
	push	edx
	lea	ecx, DWORD PTR _dstRTP$[ebp]
	call	??0RTPFrame@@QAE@PBEH@Z			; RTPFrame::RTPFrame

; 275  : 
; 276  :   dstLen = 0;

	mov	eax, DWORD PTR _dstLen$[ebp]
	mov	DWORD PTR [eax], 0

; 277  : 
; 278  :   // from here, we are encoding a new frame
; 279  :   if ((!_codec) || (!_txH264Frame))

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $L10788
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+672], 0
	jne	SHORT $L10787
$L10788:

; 280  :   {
; 281  :     return 0;

	xor	eax, eax
	jmp	$L10784
$L10787:

; 282  :   }
; 283  : 
; 284  :   // if there are RTP packets to return, return them
; 285  :   if  (_txH264Frame->HasRTPFrames())

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+672]
	call	?HasRTPFrames@H264Frame@@QAE_NXZ	; H264Frame::HasRTPFrames
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $L10789

; 286  :   {
; 287  :     _txH264Frame->GetRTPFrame(dstRTP, flags);

	mov	edx, DWORD PTR _flags$[ebp]
	push	edx
	lea	eax, DWORD PTR _dstRTP$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+672]
	call	?GetRTPFrame@H264Frame@@QAE_NAAVRTPFrame@@AAI@Z ; H264Frame::GetRTPFrame

; 288  :     dstLen = dstRTP.GetFrameLen();

	lea	ecx, DWORD PTR _dstRTP$[ebp]
	call	?GetFrameLen@RTPFrame@@QAEHXZ		; RTPFrame::GetFrameLen
	mov	edx, DWORD PTR _dstLen$[ebp]
	mov	DWORD PTR [edx], eax

; 289  :     return 1;

	mov	eax, 1
	jmp	$L10784
$L10789:

; 290  :   }
; 291  : 
; 292  :   if (srcRTP.GetPayloadSize() < sizeof(frameHeader))

	lea	ecx, DWORD PTR _srcRTP$[ebp]
	call	?GetPayloadSize@RTPFrame@@QAEIXZ	; RTPFrame::GetPayloadSize
	cmp	eax, 16					; 00000010H
	jae	SHORT $L10791

; 293  :   {
; 294  :    TRACE(1, "H264\tEncoder\tVideo grab too small, Close down video transmission thread");

	push	1
	call	?CanTrace@Trace@@SA_NI@Z		; Trace::CanTrace
	add	esp, 4
	movzx	eax, al
	test	eax, eax
	je	SHORT $L10792
	push	OFFSET FLAT:?endl@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@1@AAV21@@Z ; std::endl
	push	OFFSET FLAT:$SG10795
	push	294					; 00000126H
	push	OFFSET FLAT:$SG10796
	call	?Start@Trace@@SAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@PBDH@Z ; Trace::Start
	add	esp, 8
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
$L10792:

; 295  :    return 0;

	xor	eax, eax
	jmp	$L10784
$L10791:

; 296  :   }
; 297  : 
; 298  :   frameHeader * header = (frameHeader *)srcRTP.GetPayloadPtr();

	lea	ecx, DWORD PTR _srcRTP$[ebp]
	call	?GetPayloadPtr@RTPFrame@@QAEPAEXZ	; RTPFrame::GetPayloadPtr
	mov	DWORD PTR _header$[ebp], eax

; 299  :   if (header->x != 0 || header->y != 0)

	mov	ecx, DWORD PTR _header$[ebp]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $L10800
	mov	edx, DWORD PTR _header$[ebp]
	cmp	DWORD PTR [edx+4], 0
	je	SHORT $L10799
$L10800:

; 300  :   {
; 301  :     TRACE(1, "H264\tEncoder\tVideo grab of partial frame unsupported, Close down video transmission thread");

	push	1
	call	?CanTrace@Trace@@SA_NI@Z		; Trace::CanTrace
	add	esp, 4
	movzx	eax, al
	test	eax, eax
	je	SHORT $L10801
	push	OFFSET FLAT:?endl@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@1@AAV21@@Z ; std::endl
	push	OFFSET FLAT:$SG10804
	push	301					; 0000012dH
	push	OFFSET FLAT:$SG10805
	call	?Start@Trace@@SAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@PBDH@Z ; Trace::Start
	add	esp, 8
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
$L10801:

; 302  :     return 0;

	xor	eax, eax
	jmp	$L10784
$L10799:

; 303  :   }
; 304  : 
; 305  :   // do a validation of size
; 306  :   // if the incoming data has changed size, tell the encoder
; 307  :   if ((unsigned)_context.i_width != header->width || (unsigned)_context.i_height != header->height)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _header$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	cmp	eax, DWORD PTR [edx+8]
	jne	SHORT $L10809
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _header$[ebp]
	mov	eax, DWORD PTR [ecx+24]
	cmp	eax, DWORD PTR [edx+12]
	je	SHORT $L10808
$L10809:

; 308  :   {
; 309  :     X264_ENCODER_CLOSE(_codec);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_x264_encoder_close
	add	esp, 4

; 310  :     _context.i_width = header->width;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _header$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+20], edx

; 311  :     _context.i_height = header->height;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _header$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+24], edx

; 312  :     _codec = X264_ENCODER_OPEN(&_context);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	push	eax
	call	_x264_encoder_open_79
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax
$L10808:

; 313  :   } 
; 314  : 
; 315  :   bool wantIFrame = false;

	mov	BYTE PTR _wantIFrame$[ebp], 0

; 316  :   x264_nal_t* NALs;
; 317  :   int numberOfNALs = 0;

	mov	DWORD PTR _numberOfNALs$[ebp], 0

; 318  :   x264_picture_t dummyOutput;
; 319  : 
; 320  :   // Check whether to insert a keyframe 
; 321  :   // (On the first frame and every_IFrameInterval)
; 322  :   _PFramesSinceLastIFrame++;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+676]
	add	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+676], eax

; 323  :   if (_PFramesSinceLastIFrame >= _IFrameInterval)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+676]
	cmp	ecx, DWORD PTR [eax+680]
	jb	SHORT $L10814

; 324  :   {
; 325  :     wantIFrame = true;

	mov	BYTE PTR _wantIFrame$[ebp], 1

; 326  :     _PFramesSinceLastIFrame = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+676], 0
$L10814:

; 327  :   }
; 328  :   // Prepare the frame to be encoded
; 329  :   _inputFrame.img.plane[0] = (uint8_t *)(((unsigned char *)header) + sizeof(frameHeader));

	mov	eax, DWORD PTR _header$[ebp]
	add	eax, 16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+652], eax

; 330  :   _inputFrame.img.i_stride[0] = header->width;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _header$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+636], ecx

; 331  :   _inputFrame.img.plane[1] = (uint8_t *)((((unsigned char *)header) + sizeof(frameHeader)) 
; 332  :                            + (int)(_inputFrame.img.i_stride[0]*header->height));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _header$[ebp]
	mov	ecx, DWORD PTR [edx+636]
	imul	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _header$[ebp]
	lea	eax, DWORD PTR [edx+ecx+16]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+656], eax

; 333  :   _inputFrame.img.i_stride[1] = 
; 334  :   _inputFrame.img.i_stride[2] = (int) ( header->width / 2 );

	mov	edx, DWORD PTR _header$[ebp]
	mov	eax, DWORD PTR [edx+8]
	shr	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+644], eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+644]
	mov	DWORD PTR [edx+640], ecx

; 335  :   _inputFrame.img.plane[2] = (uint8_t *)(_inputFrame.img.plane[1] + (int)(_inputFrame.img.i_stride[1] *header->height/2));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _header$[ebp]
	mov	ecx, DWORD PTR [edx+640]
	imul	ecx, DWORD PTR [eax+12]
	shr	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+656]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+660], ecx

; 336  :   _inputFrame.i_type = (wantIFrame || (flags && forceIFrame)) ? X264_TYPE_IDR : X264_TYPE_AUTO;

	movzx	ecx, BYTE PTR _wantIFrame$[ebp]
	test	ecx, ecx
	jne	SHORT $L13477
	mov	edx, DWORD PTR _flags$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $L13476
	mov	eax, 2
	test	eax, eax
	jne	SHORT $L13477
$L13476:
	mov	DWORD PTR tv231[ebp], 0
	jmp	SHORT $L13478
$L13477:
	mov	DWORD PTR tv231[ebp], 1
$L13478:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR tv231[ebp]
	mov	DWORD PTR [ecx+608], edx
$L10826:

; 337  : 
; 338  :   while (numberOfNALs==0) { // workaround for first 2 packets being 0

	cmp	DWORD PTR _numberOfNALs$[ebp], 0
	jne	SHORT $L10827

; 339  :     if (X264_ENCODER_ENCODE(_codec, &NALs, &numberOfNALs, &_inputFrame, &dummyOutput) < 0) {

	lea	eax, DWORD PTR _dummyOutput$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 608				; 00000260H
	push	ecx
	lea	edx, DWORD PTR _numberOfNALs$[ebp]
	push	edx
	mov	BYTE PTR $T13479[ebp], 1
	lea	eax, DWORD PTR _NALs$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_x264_encoder_encode
	add	esp, 20					; 00000014H
	test	eax, eax
	jge	SHORT $L10828

; 340  :       TRACE (1,"H264\tEncoder\tEncoding failed");

	push	1
	call	?CanTrace@Trace@@SA_NI@Z		; Trace::CanTrace
	add	esp, 4
	movzx	eax, al
	test	eax, eax
	je	SHORT $L10829
	push	OFFSET FLAT:?endl@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@1@AAV21@@Z ; std::endl
	push	OFFSET FLAT:$SG10832
	push	340					; 00000154H
	push	OFFSET FLAT:$SG10833
	call	?Start@Trace@@SAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@PBDH@Z ; Trace::Start
	add	esp, 8
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
$L10829:

; 341  :       return 0;

	xor	eax, eax
	jmp	$L10784
$L10828:

; 342  :     } 
; 343  :   }

	jmp	SHORT $L10826
$L10827:

; 344  :   
; 345  :   _txH264Frame->BeginNewFrame();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+672]
	call	?BeginNewFrame@H264Frame@@QAEXXZ	; H264Frame::BeginNewFrame

; 346  :   _txH264Frame->SetFromFrame(NALs, numberOfNALs);

	cmp	BYTE PTR $T13479[ebp], 0
	jne	SHORT $L13480
	push	OFFSET FLAT:$L13481
	call	__RTC_UninitUse
	add	esp, 4
$L13480:
	mov	edx, DWORD PTR _numberOfNALs$[ebp]
	push	edx
	mov	eax, DWORD PTR _NALs$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+672]
	call	?SetFromFrame@H264Frame@@QAEXPAUx264_nal_t@@H@Z ; H264Frame::SetFromFrame

; 347  :   _txH264Frame->SetTimestamp(srcRTP.GetTimestamp());

	lea	ecx, DWORD PTR _srcRTP$[ebp]
	call	?GetTimestamp@RTPFrame@@QAEKXZ		; RTPFrame::GetTimestamp
	xor	edx, edx
	push	edx
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+672]
	call	?SetTimestamp@H264Frame@@QAEX_K@Z	; H264Frame::SetTimestamp

; 348  :   _frameCounter++; 

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+684]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+684], edx

; 349  : 
; 350  :   if (_txH264Frame->HasRTPFrames())

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+672]
	call	?HasRTPFrames@H264Frame@@QAE_NXZ	; H264Frame::HasRTPFrames
	movzx	edx, al
	test	edx, edx
	je	SHORT $L10834

; 351  :   {
; 352  :     _txH264Frame->GetRTPFrame(dstRTP, flags);

	mov	eax, DWORD PTR _flags$[ebp]
	push	eax
	lea	ecx, DWORD PTR _dstRTP$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+672]
	call	?GetRTPFrame@H264Frame@@QAE_NAAVRTPFrame@@AAI@Z ; H264Frame::GetRTPFrame

; 353  :     dstLen = dstRTP.GetFrameLen();

	lea	ecx, DWORD PTR _dstRTP$[ebp]
	call	?GetFrameLen@RTPFrame@@QAEHXZ		; RTPFrame::GetFrameLen
	mov	ecx, DWORD PTR _dstLen$[ebp]
	mov	DWORD PTR [ecx], eax

; 354  :     return 1;

	mov	eax, 1
	jmp	SHORT $L10784
$L10834:

; 355  :   }
; 356  :   return 1;

	mov	eax, 1
$L10784:

; 357  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L13488
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	add	esp, 148				; 00000094H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
$L13488:
	DD	5
	DD	$L13487
$L13487:
	DD	-52					; ffffffccH
	DD	4
	DD	$L13481
	DD	-16					; fffffff0H
	DD	8
	DD	$L13483
	DD	-32					; ffffffe0H
	DD	8
	DD	$L13484
	DD	-64					; ffffffc0H
	DD	4
	DD	$L13485
	DD	-136					; ffffff78H
	DD	64					; 00000040H
	DD	$L13486
$L13486:
	DB	100					; 00000064H
	DB	117					; 00000075H
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	121					; 00000079H
	DB	79					; 0000004fH
	DB	117					; 00000075H
	DB	116					; 00000074H
	DB	112					; 00000070H
	DB	117					; 00000075H
	DB	116					; 00000074H
	DB	0
$L13485:
	DB	110					; 0000006eH
	DB	117					; 00000075H
	DB	109					; 0000006dH
	DB	98					; 00000062H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	79					; 0000004fH
	DB	102					; 00000066H
	DB	78					; 0000004eH
	DB	65					; 00000041H
	DB	76					; 0000004cH
	DB	115					; 00000073H
	DB	0
$L13484:
	DB	100					; 00000064H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	82					; 00000052H
	DB	84					; 00000054H
	DB	80					; 00000050H
	DB	0
$L13483:
	DB	115					; 00000073H
	DB	114					; 00000072H
	DB	99					; 00000063H
	DB	82					; 00000052H
	DB	84					; 00000054H
	DB	80					; 00000050H
	DB	0
$L13481:
	DB	78					; 0000004eH
	DB	65					; 00000041H
	DB	76					; 0000004cH
	DB	115					; 00000073H
	DB	0
?EncodeFrames@X264EncoderContext@@QAEHPBEAAIPAE11@Z ENDP ; X264EncoderContext::EncodeFrames
; Function compile flags: /Odt /RTCsu
; File d:\chy\projects\my\eqcores2\opal\plugins\video\common\rtpframe.h
_TEXT	ENDS
;	COMDAT ??0RTPFrame@@QAE@PBEH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_frame$ = 8						; size = 4
_frameLen$ = 12						; size = 4
??0RTPFrame@@QAE@PBEH@Z PROC NEAR			; RTPFrame::RTPFrame, COMDAT
; _this$ = ecx

; 41   :   RTPFrame (const unsigned char* frame, int frameLen) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 42   :     _frame = (unsigned char*) frame;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _frame$[ebp]
	mov	DWORD PTR [eax], ecx

; 43   :     _frameLen = frameLen;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _frameLen$[ebp]
	mov	DWORD PTR [edx+4], eax

; 44   :   };

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0RTPFrame@@QAE@PBEH@Z ENDP				; RTPFrame::RTPFrame
_TEXT	ENDS
PUBLIC	?GetHeaderSize@RTPFrame@@QAEHXZ			; RTPFrame::GetHeaderSize
; Function compile flags: /Odt /RTCsu
;	COMDAT ?GetPayloadSize@RTPFrame@@QAEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetPayloadSize@RTPFrame@@QAEIXZ PROC NEAR		; RTPFrame::GetPayloadSize, COMDAT
; _this$ = ecx

; 54   :   unsigned GetPayloadSize () {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 55   :     return (_frameLen - GetHeaderSize());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetHeaderSize@RTPFrame@@QAEHXZ		; RTPFrame::GetHeaderSize
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	sub	edx, eax
	mov	eax, edx

; 56   :   }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?GetPayloadSize@RTPFrame@@QAEIXZ ENDP			; RTPFrame::GetPayloadSize
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?GetFrameLen@RTPFrame@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetFrameLen@RTPFrame@@QAEHXZ PROC NEAR			; RTPFrame::GetFrameLen, COMDAT
; _this$ = ecx

; 62   :   int GetFrameLen () {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 63   :     return (_frameLen);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 64   :   }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetFrameLen@RTPFrame@@QAEHXZ ENDP			; RTPFrame::GetFrameLen
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?GetPayloadPtr@RTPFrame@@QAEPAEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetPayloadPtr@RTPFrame@@QAEPAEXZ PROC NEAR		; RTPFrame::GetPayloadPtr, COMDAT
; _this$ = ecx

; 66   :   unsigned char* GetPayloadPtr () {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 67   :     return (_frame + GetHeaderSize());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetHeaderSize@RTPFrame@@QAEHXZ		; RTPFrame::GetHeaderSize
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]

; 68   :   }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?GetPayloadPtr@RTPFrame@@QAEPAEXZ ENDP			; RTPFrame::GetPayloadPtr
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?GetHeaderSize@RTPFrame@@QAEHXZ
_TEXT	SEGMENT
_size$ = -8						; size = 4
_this$ = -4						; size = 4
?GetHeaderSize@RTPFrame@@QAEHXZ PROC NEAR		; RTPFrame::GetHeaderSize, COMDAT
; _this$ = ecx

; 70   :   int GetHeaderSize () {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 71   :     int size;
; 72   :     size = 12;

	mov	DWORD PTR _size$[ebp], 12		; 0000000cH

; 73   :     if (_frameLen < 12) 

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 12			; 0000000cH
	jge	SHORT $L9346

; 74   :       return 0;

	xor	eax, eax
	jmp	SHORT $L9344
$L9346:

; 75   :     size += (_frame[0] & 0x0f) * 4;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	movzx	eax, BYTE PTR [edx]
	and	eax, 15					; 0000000fH
	mov	ecx, DWORD PTR _size$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _size$[ebp], edx

; 76   :     if (!(_frame[0] & 0x10))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	movzx	edx, BYTE PTR [ecx]
	and	edx, 16					; 00000010H
	jne	SHORT $L9347

; 77   :       return size;

	mov	eax, DWORD PTR _size$[ebp]
	jmp	SHORT $L9344
$L9347:

; 78   :     if ((size + 4) < _frameLen) 

	mov	eax, DWORD PTR _size$[ebp]
	add	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR [ecx+4]
	jge	SHORT $L9348

; 79   :       return (size + 4 + (_frame[size + 2] << 8) + _frame[size + 3]);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _size$[ebp]
	movzx	edx, BYTE PTR [eax+ecx+2]
	shl	edx, 8
	mov	eax, DWORD PTR _size$[ebp]
	lea	eax, DWORD PTR [eax+edx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _size$[ebp]
	movzx	edx, BYTE PTR [edx+ecx+3]
	add	eax, edx
	jmp	SHORT $L9344
$L9348:

; 80   :     return 0;

	xor	eax, eax
$L9344:

; 81   :   }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetHeaderSize@RTPFrame@@QAEHXZ ENDP			; RTPFrame::GetHeaderSize
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?GetTimestamp@RTPFrame@@QAEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetTimestamp@RTPFrame@@QAEKXZ PROC NEAR		; RTPFrame::GetTimestamp, COMDAT
; _this$ = ecx

; 111  :   unsigned long GetTimestamp() {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 112  :     if (_frameLen < 8)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 8
	jge	SHORT $L9364

; 113  :       return 0;

	xor	eax, eax
	jmp	SHORT $L9363
$L9364:

; 114  :     return ((_frame[4] << 24) + (_frame[5] << 16) + (_frame[6] << 8) + _frame[7]);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	movzx	eax, BYTE PTR [edx+4]
	shl	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	movzx	ecx, BYTE PTR [edx+5]
	shl	ecx, 16					; 00000010H
	add	eax, ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	movzx	edx, BYTE PTR [ecx+6]
	shl	edx, 8
	add	eax, edx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	movzx	ecx, BYTE PTR [edx+7]
	add	eax, ecx
$L9363:

; 115  :   }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetTimestamp@RTPFrame@@QAEKXZ ENDP			; RTPFrame::GetTimestamp
; Function compile flags: /Odt /RTCsu
; File d:\chy\projects\my\eqcores2\opal\plugins\video\h.264\shared\h264frame.h
_TEXT	ENDS
;	COMDAT ?SetTimestamp@H264Frame@@QAEX_K@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_timestamp$ = 8						; size = 8
?SetTimestamp@H264Frame@@QAEX_K@Z PROC NEAR		; H264Frame::SetTimestamp, COMDAT
; _this$ = ecx

; 165  :   {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 166  :     _timestamp = timestamp;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _timestamp$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _timestamp$[ebp+4]
	mov	DWORD PTR [eax+4], edx

; 167  :   }

	mov	esp, ebp
	pop	ebp
	ret	8
?SetTimestamp@H264Frame@@QAEX_K@Z ENDP			; H264Frame::SetTimestamp
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?HasRTPFrames@H264Frame@@QAE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?HasRTPFrames@H264Frame@@QAE_NXZ PROC NEAR		; H264Frame::HasRTPFrames, COMDAT
; _this$ = ecx

; 170  :   {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 171  :     if (_currentNAL < _numberOfNALsInFrame) return true; else return false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+28]
	cmp	edx, DWORD PTR [ecx+24]
	jae	SHORT $L9856
	mov	al, 1
	jmp	SHORT $L9855
$L9856:
	xor	al, al
$L9855:

; 172  :   }

	mov	esp, ebp
	pop	ebp
	ret	0
?HasRTPFrames@H264Frame@@QAE_NXZ ENDP			; H264Frame::HasRTPFrames
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\ostream
_TEXT	ENDS
;	COMDAT ??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pfn$ = 8						; size = 4
??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z PROC NEAR ; std::basic_ostream<char,std::char_traits<char> >::operator<<, COMDAT
; _this$ = ecx

; 138  : 		{	// call basic_ostream manipulator

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 139  : 		return ((*_Pfn)(*this));

	mov	esi, esp
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	DWORD PTR __Pfn$[ebp]
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 140  : 		}

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::operator<<
_TEXT	ENDS
PUBLIC	?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate
PUBLIC	?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::rdbuf
PUBLIC	?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::basic_ios<char,std::char_traits<char> >::fill
PUBLIC	??1locale@std@@QAE@XZ				; std::locale::~locale
PUBLIC	?flags@ios_base@std@@QBEHXZ			; std::ios_base::flags
PUBLIC	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
PUBLIC	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
PUBLIC	??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
PUBLIC	?getloc@ios_base@std@@QBE?AVlocale@2@XZ		; std::ios_base::getloc
PUBLIC	??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z ; std::use_facet<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >
PUBLIC	?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DJ@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::put
PUBLIC	??0?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z ; std::ostreambuf_iterator<char,std::char_traits<char> >::ostreambuf_iterator<char,std::char_traits<char> >
PUBLIC	?failed@?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::ostreambuf_iterator<char,std::char_traits<char> >::failed
;	COMDAT xdata$x
xdata$x	SEGMENT
$T13527	DD	0ffffffffH
	DD	FLAT:$L13519
	DD	00H
	DD	FLAT:$L13520
	DD	00H
	DD	00H
	DD	00H
	DD	00H
$T13529	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L13518
$T13528	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:$T13529
$T13522	DD	019930520H
	DD	04H
	DD	FLAT:$T13527
	DD	01H
	DD	FLAT:$T13528
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
tv165 = -104						; size = 4
tv164 = -100						; size = 4
tv163 = -93						; size = 1
tv132 = -92						; size = 4
tv88 = -88						; size = 4
tv160 = -84						; size = 4
tv65 = -80						; size = 4
$T13516 = -76						; size = 4
$T13515 = -72						; size = 8
$T13514 = -64						; size = 8
$T13509 = -56						; size = 4
__Tmp$11058 = -52					; size = 4
__Bfl$11057 = -48					; size = 4
__Nput_fac$11051 = -44					; size = 4
__Ok$ = -36						; size = 8
__State$ = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Val$ = 8						; size = 4
??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z PROC NEAR ; std::basic_ostream<char,std::char_traits<char> >::operator<<, COMDAT
; _this$ = ecx

; 228  : 		{	// insert an int

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-104]
	mov	ecx, 22					; 00000016H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 229  : 		ios_base::iostate _State = ios_base::goodbit;

	mov	DWORD PTR __State$[ebp], 0

; 230  : 		const sentry _Ok(*this);

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Ok$[ebp]
	call	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 231  : 
; 232  : 		if (_Ok)

	lea	ecx, DWORD PTR __Ok$[ebp]
	call	??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	$L13517

; 233  : 			{	// state okay, use facet to insert
; 234  : 			const _Nput& _Nput_fac = _USE(ios_base::getloc(), _Nput);

	lea	edx, DWORD PTR $T13509[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	ecx, edx
	call	?getloc@ios_base@std@@QBE?AVlocale@2@XZ	; std::ios_base::getloc
	mov	DWORD PTR tv65[ebp], eax
	mov	eax, DWORD PTR tv65[ebp]
	mov	DWORD PTR tv160[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	mov	ecx, DWORD PTR tv160[ebp]
	push	ecx
	call	??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z ; std::use_facet<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >
	add	esp, 4
	mov	DWORD PTR __Nput_fac$11051[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+12], 0
	lea	ecx, DWORD PTR $T13509[ebp]
	call	??1locale@std@@QAE@XZ			; std::locale::~locale

; 235  : 			ios_base::fmtflags _Bfl =
; 236  : 				ios_base::flags() & ios_base::basefield;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [eax+4]
	call	?flags@ios_base@std@@QBEHXZ		; std::ios_base::flags
	and	eax, 3584				; 00000e00H
	mov	DWORD PTR __Bfl$11057[ebp], eax

; 237  : 			long _Tmp = (_Bfl == ios_base::oct
; 238  : 				|| _Bfl == ios_base::hex)
; 239  : 				? (long)(unsigned int)_Val : (long)_Val;

	cmp	DWORD PTR __Bfl$11057[ebp], 1024	; 00000400H
	je	SHORT $L13510
	cmp	DWORD PTR __Bfl$11057[ebp], 2048	; 00000800H
	je	SHORT $L13510
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR tv88[ebp], ecx
	jmp	SHORT $L13511
$L13510:
	mov	edx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR tv88[ebp], edx
$L13511:
	mov	eax, DWORD PTR tv88[ebp]
	mov	DWORD PTR __Tmp$11058[ebp], eax

; 240  : 
; 241  : 			_TRY_IO_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 2

; 242  : 			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
; 243  : 				_Myios::fill(), _Tmp).failed())

	cmp	DWORD PTR _this$[ebp], 0
	jne	SHORT $L13512
	mov	DWORD PTR tv132[ebp], 0
	jmp	SHORT $L13513
$L13512:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [edx+4]
	mov	DWORD PTR tv132[ebp], eax
$L13513:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+4]
	call	?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::basic_ios<char,std::char_traits<char> >::fill
	mov	BYTE PTR tv163[ebp], al
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	ecx, edx
	call	?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::rdbuf
	mov	DWORD PTR tv164[ebp], eax
	mov	eax, DWORD PTR __Tmp$11058[ebp]
	push	eax
	mov	cl, BYTE PTR tv163[ebp]
	push	ecx
	mov	edx, DWORD PTR tv132[ebp]
	push	edx
	mov	eax, DWORD PTR tv164[ebp]
	push	eax
	lea	ecx, DWORD PTR $T13514[ebp]
	call	??0?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z ; std::ostreambuf_iterator<char,std::char_traits<char> >::ostreambuf_iterator<char,std::char_traits<char> >
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	lea	eax, DWORD PTR $T13515[ebp]
	push	eax
	mov	ecx, DWORD PTR __Nput_fac$11051[ebp]
	call	?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DJ@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::put
	mov	DWORD PTR tv165[ebp], eax
	mov	ecx, DWORD PTR tv165[ebp]
	call	?failed@?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::ostreambuf_iterator<char,std::char_traits<char> >::failed
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $L11237

; 244  : 				_State |= ios_base::badbit;

	mov	edx, DWORD PTR __State$[ebp]
	or	edx, 4
	mov	DWORD PTR __State$[ebp], edx
$L11237:
	jmp	SHORT $L13517
$L13518:

; 245  : 			_CATCH_IO_END

	push	1
	push	4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	ecx, edx
	call	?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate
	mov	eax, $L13517
	ret	0
$L13517:
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 246  : 			}
; 247  : 
; 248  : 		_Myios::setstate(_State);

	push	0
	mov	eax, DWORD PTR __State$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+4]
	call	?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate

; 249  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR $T13516[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	lea	ecx, DWORD PTR __Ok$[ebp]
	call	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
	mov	eax, DWORD PTR $T13516[ebp]

; 250  : 		}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L13526
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 104				; 00000068H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
$L13526:
	DD	1
	DD	$L13525
$L13525:
	DD	-36					; ffffffdcH
	DD	8
	DD	$L13523
$L13523:
	DB	95					; 0000005fH
	DB	79					; 0000004fH
	DB	107					; 0000006bH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L13519:
	lea	ecx, DWORD PTR __Ok$[ebp]
	jmp	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
$L13520:
	lea	ecx, DWORD PTR $T13509[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__ehhandler$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z:
	mov	eax, OFFSET FLAT:$T13522
	jmp	___CxxFrameHandler
text$x	ENDS
??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::operator<<
PUBLIC	?_Decref@facet@locale@std@@QAEPAV123@XZ		; std::locale::facet::_Decref
PUBLIC	??$_DebugHeapDelete@Vfacet@locale@std@@@std@@YAXPAVfacet@locale@0@@Z ; std::_DebugHeapDelete<std::locale::facet>
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xlocale
;	COMDAT ??1locale@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1locale@std@@QAE@XZ PROC NEAR				; std::locale::~locale, COMDAT
; _this$ = ecx

; 245  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 246  : 		if (_Ptr != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L5692

; 247  : 			_DELETE_CRT(_Ptr->_Decref());

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?_Decref@facet@locale@std@@QAEPAV123@XZ	; std::locale::facet::_Decref
	push	eax
	call	??$_DebugHeapDelete@Vfacet@locale@std@@@std@@YAXPAVfacet@locale@0@@Z ; std::_DebugHeapDelete<std::locale::facet>
	add	esp, 4
$L5692:

; 248  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1locale@std@@QAE@XZ ENDP				; std::locale::~locale
_TEXT	ENDS
EXTRN	??0_Lockit@std@@QAE@H@Z:NEAR			; std::_Lockit::_Lockit
EXTRN	??1_Lockit@std@@QAE@XZ:NEAR			; std::_Lockit::~_Lockit
; Function compile flags: /Odt /RTCsu
;	COMDAT ?_Decref@facet@locale@std@@QAEPAV123@XZ
_TEXT	SEGMENT
$T13536 = -20						; size = 4
__Lock$ = -12						; size = 4
_this$ = -4						; size = 4
?_Decref@facet@locale@std@@QAEPAV123@XZ PROC NEAR	; std::locale::facet::_Decref, COMDAT
; _this$ = ecx

; 111  : 			{	// safely decrement the reference count, return this when dead

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 112  : 			_Lockit _Lock(_LOCK_LOCALE);

	push	0
	lea	ecx, DWORD PTR __Lock$[ebp]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit

; 113  : 
; 114  : 			if (0 < _Refs && _Refs < (size_t)(-1))

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jbe	SHORT $L5681
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4], -1
	jae	SHORT $L5681

; 115  : 				--_Refs;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax
$L5681:

; 116  : 			return (_Refs == 0 ? this : 0);

	mov	edx, DWORD PTR _this$[ebp]
	xor	eax, eax
	cmp	DWORD PTR [edx+4], 0
	setne	al
	dec	eax
	and	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR $T13536[ebp], eax
	lea	ecx, DWORD PTR __Lock$[ebp]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	mov	eax, DWORD PTR $T13536[ebp]

; 117  : 			}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L13540
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$L13540:
	DD	1
	DD	$L13539
$L13539:
	DD	-12					; fffffff4H
	DD	4
	DD	$L13538
$L13538:
	DB	95					; 0000005fH
	DB	76					; 0000004cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	0
?_Decref@facet@locale@std@@QAEPAV123@XZ ENDP		; std::locale::facet::_Decref
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xiosbase
_TEXT	ENDS
;	COMDAT ?flags@ios_base@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?flags@ios_base@std@@QBEHXZ PROC NEAR			; std::ios_base::flags, COMDAT
; _this$ = ecx

; 324  : 		{	// return format flags

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 325  : 		return (_Fmtfl);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]

; 326  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?flags@ios_base@std@@QBEHXZ ENDP			; std::ios_base::flags
_TEXT	ENDS
PUBLIC	??0locale@std@@QAE@ABV01@@Z			; std::locale::locale
; Function compile flags: /Odt /RTCsu
;	COMDAT ?getloc@ios_base@std@@QBE?AVlocale@2@XZ
_TEXT	SEGMENT
$T13546 = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?getloc@ios_base@std@@QBE?AVlocale@2@XZ PROC NEAR	; std::ios_base::getloc, COMDAT
; _this$ = ecx

; 381  : 		{	// get locale

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T13546[ebp], 0

; 382  : 		return (*_Ploc);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0locale@std@@QAE@ABV01@@Z		; std::locale::locale
	mov	edx, DWORD PTR $T13546[ebp]
	or	edx, 1
	mov	DWORD PTR $T13546[ebp], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 383  : 		}

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?getloc@ios_base@std@@QBE?AVlocale@2@XZ ENDP		; std::ios_base::getloc
_TEXT	ENDS
PUBLIC	?_Incref@facet@locale@std@@QAEXXZ		; std::locale::facet::_Incref
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xlocale
;	COMDAT ??0locale@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??0locale@std@@QAE@ABV01@@Z PROC NEAR			; std::locale::locale, COMDAT
; _this$ = ecx

; 231  : 		{	// construct by copying

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 232  : 		_Ptr->_Incref();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?_Incref@facet@locale@std@@QAEXXZ	; std::locale::facet::_Incref

; 233  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0locale@std@@QAE@ABV01@@Z ENDP			; std::locale::locale
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?_Incref@facet@locale@std@@QAEXXZ
_TEXT	SEGMENT
__Lock$ = -12						; size = 4
_this$ = -4						; size = 4
?_Incref@facet@locale@std@@QAEXXZ PROC NEAR		; std::locale::facet::_Incref, COMDAT
; _this$ = ecx

; 103  : 			{	// safely increment the reference count

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 104  : 			_Lockit _Lock(_LOCK_LOCALE);

	push	0
	lea	ecx, DWORD PTR __Lock$[ebp]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit

; 105  : 
; 106  : 			if (_Refs < (size_t)(-1))

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], -1
	jae	SHORT $L5676

; 107  : 				++_Refs;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], edx
$L5676:

; 108  : 			}

	lea	ecx, DWORD PTR __Lock$[ebp]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L13555
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$L13555:
	DD	1
	DD	$L13554
$L13554:
	DD	-12					; fffffff4H
	DD	4
	DD	$L13553
$L13553:
	DB	95					; 0000005fH
	DB	76					; 0000004cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	0
?_Incref@facet@locale@std@@QAEXXZ ENDP			; std::locale::facet::_Incref
_TEXT	ENDS
PUBLIC	?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z	; std::char_traits<char>::eq_int_type
PUBLIC	?eof@?$char_traits@D@std@@SAHXZ			; std::char_traits<char>::eof
PUBLIC	?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z ; std::basic_streambuf<char,std::char_traits<char> >::sputc
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\ostream
xdata$x	SEGMENT
$T13570	DD	0ffffffffH
	DD	FLAT:$L13563
	DD	00H
	DD	00H
	DD	00H
	DD	00H
$T13572	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L13562
$T13571	DD	01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:$T13572
$T13565	DD	019930520H
	DD	03H
	DD	FLAT:$T13570
	DD	01H
	DD	FLAT:$T13571
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z
_TEXT	SEGMENT
tv134 = -65						; size = 1
tv133 = -64						; size = 4
tv132 = -60						; size = 4
tv65 = -56						; size = 4
$T13560 = -52						; size = 4
$T13559 = -48						; size = 4
$T13558 = -44						; size = 4
__Ok$ = -36						; size = 8
__State$ = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Ch$ = 8						; size = 1
?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z PROC NEAR ; std::basic_ostream<char,std::char_traits<char> >::put, COMDAT
; _this$ = ecx

; 471  : 		{	// insert a character

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	sub	esp, 52					; 00000034H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-68]
	mov	ecx, 13					; 0000000dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 472  : 		ios_base::iostate _State = ios_base::goodbit;

	mov	DWORD PTR __State$[ebp], 0

; 473  : 		const sentry _Ok(*this);

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Ok$[ebp]
	call	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 474  : 
; 475  : 		if (!_Ok)

	lea	ecx, DWORD PTR __Ok$[ebp]
	call	??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $L11243

; 476  : 			_State |= ios_base::badbit;

	mov	edx, DWORD PTR __State$[ebp]
	or	edx, 4
	mov	DWORD PTR __State$[ebp], edx

; 477  : 		else

	jmp	SHORT $L13561
$L11243:

; 478  : 			{	// state okay, insert character
; 479  : 			_TRY_IO_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 480  : 			if (_Traits::eq_int_type(_Traits::eof(),
; 481  : 				_Myios::rdbuf()->sputc(_Ch)))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	ecx, edx
	call	?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::rdbuf
	mov	DWORD PTR tv65[ebp], eax
	mov	al, BYTE PTR __Ch$[ebp]
	push	eax
	mov	ecx, DWORD PTR tv65[ebp]
	call	?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z ; std::basic_streambuf<char,std::char_traits<char> >::sputc
	mov	DWORD PTR tv132[ebp], eax
	mov	ecx, DWORD PTR tv132[ebp]
	mov	DWORD PTR $T13558[ebp], ecx
	call	?eof@?$char_traits@D@std@@SAHXZ		; std::char_traits<char>::eof
	mov	DWORD PTR tv133[ebp], eax
	mov	edx, DWORD PTR tv133[ebp]
	mov	DWORD PTR $T13559[ebp], edx
	lea	eax, DWORD PTR $T13558[ebp]
	push	eax
	lea	ecx, DWORD PTR $T13559[ebp]
	push	ecx
	call	?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z ; std::char_traits<char>::eq_int_type
	add	esp, 8
	mov	BYTE PTR tv134[ebp], al
	movzx	edx, BYTE PTR tv134[ebp]
	test	edx, edx
	je	SHORT $L11248

; 482  : 				_State |= ios_base::badbit;

	mov	eax, DWORD PTR __State$[ebp]
	or	eax, 4
	mov	DWORD PTR __State$[ebp], eax
$L11248:
	jmp	SHORT $L13561
$L13562:

; 483  : 			_CATCH_IO_END

	push	1
	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+4]
	call	?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate
	mov	eax, $L13561
	ret	0
$L13561:
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 484  : 			}
; 485  : 
; 486  : 		_Myios::setstate(_State);

	push	0
	mov	eax, DWORD PTR __State$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+4]
	call	?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate

; 487  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR $T13560[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	lea	ecx, DWORD PTR __Ok$[ebp]
	call	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
	mov	eax, DWORD PTR $T13560[ebp]

; 488  : 		}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L13569
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 68					; 00000044H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
$L13569:
	DD	1
	DD	$L13568
$L13568:
	DD	-36					; ffffffdcH
	DD	8
	DD	$L13566
$L13566:
	DB	95					; 0000005fH
	DB	79					; 0000004fH
	DB	107					; 0000006bH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L13563:
	lea	ecx, DWORD PTR __Ok$[ebp]
	jmp	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
__ehhandler$?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z:
	mov	eax, OFFSET FLAT:$T13565
	jmp	___CxxFrameHandler
text$x	ENDS
?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::put
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\iosfwd
;	COMDAT ?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z PROC NEAR	; std::char_traits<char>::eq_int_type, COMDAT

; 390  : 		{	// test for metacharacter equality

	push	ebp
	mov	ebp, esp

; 391  : 		return (_Left == _Right);

	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [eax]
	sub	eax, DWORD PTR [ecx]
	neg	eax
	sbb	eax, eax
	inc	eax

; 392  : 		}

	pop	ebp
	ret	0
?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z ENDP	; std::char_traits<char>::eq_int_type
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?eof@?$char_traits@D@std@@SAHXZ
_TEXT	SEGMENT
?eof@?$char_traits@D@std@@SAHXZ PROC NEAR		; std::char_traits<char>::eof, COMDAT

; 395  : 		{	// return end-of-file metacharacter

	push	ebp
	mov	ebp, esp

; 396  : 		return (EOF);

	or	eax, -1

; 397  : 		}

	pop	ebp
	ret	0
?eof@?$char_traits@D@std@@SAHXZ ENDP			; std::char_traits<char>::eof
_TEXT	ENDS
PUBLIC	?pubsync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::pubsync
PUBLIC	?fail@ios_base@std@@QBE_NXZ			; std::ios_base::fail
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\ostream
;	COMDAT ?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
_TEXT	SEGMENT
__State$ = -8						; size = 4
_this$ = -4						; size = 4
?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ PROC NEAR ; std::basic_ostream<char,std::char_traits<char> >::flush, COMDAT
; _this$ = ecx

; 511  : 		{	// flush output stream

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 512  : 		ios_base::iostate _State = ios_base::goodbit;

	mov	DWORD PTR __State$[ebp], 0

; 513  : 		if (!ios_base::fail() && _Myios::rdbuf()->pubsync() == -1)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	ecx, edx
	call	?fail@ios_base@std@@QBE_NXZ		; std::ios_base::fail
	movzx	eax, al
	test	eax, eax
	jne	SHORT $L11253
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+4]
	call	?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::rdbuf
	mov	ecx, eax
	call	?pubsync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::pubsync
	cmp	eax, -1
	jne	SHORT $L11253

; 514  : 			_State |= ios_base::badbit;	// sync failed

	mov	eax, DWORD PTR __State$[ebp]
	or	eax, 4
	mov	DWORD PTR __State$[ebp], eax
$L11253:

; 515  : 		_Myios::setstate(_State);

	push	0
	mov	ecx, DWORD PTR __State$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [eax+4]
	call	?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate

; 516  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 517  : 		}

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::flush
_TEXT	ENDS
PUBLIC	?rdstate@ios_base@std@@QBEHXZ			; std::ios_base::rdstate
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xiosbase
;	COMDAT ?fail@ios_base@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?fail@ios_base@std@@QBE_NXZ PROC NEAR			; std::ios_base::fail, COMDAT
; _this$ = ecx

; 297  : 		{	// test if badbit or failbit is set in stream state

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 298  : 		return (((int)rdstate()
; 299  : 			& ((int)badbit | (int)failbit)) != 0);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?rdstate@ios_base@std@@QBEHXZ		; std::ios_base::rdstate
	and	eax, 6
	neg	eax
	sbb	eax, eax
	neg	eax

; 300  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?fail@ios_base@std@@QBE_NXZ ENDP			; std::ios_base::fail
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?rdstate@ios_base@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?rdstate@ios_base@std@@QBEHXZ PROC NEAR			; std::ios_base::rdstate, COMDAT
; _this$ = ecx

; 265  : 		{	// return stream state

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 266  : 		return (_Mystate);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]

; 267  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?rdstate@ios_base@std@@QBEHXZ ENDP			; std::ios_base::rdstate
_TEXT	ENDS
PUBLIC	?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::clear
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\ios
;	COMDAT ?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__State$ = 8						; size = 4
__Except$ = 12						; size = 1
?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z PROC NEAR ; std::basic_ios<char,std::char_traits<char> >::setstate, COMDAT
; _this$ = ecx

; 49   : 		{	// merge _State into state, possible reraise exception

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 50   : 		if (_State != goodbit)

	cmp	DWORD PTR __State$[ebp], 0
	je	SHORT $L11257

; 51   : 			clear((iostate)((int)rdstate() | (int)_State), _Except);

	mov	al, BYTE PTR __Except$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?rdstate@ios_base@std@@QBEHXZ		; std::ios_base::rdstate
	or	eax, DWORD PTR __State$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::clear
$L11257:

; 52   : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ENDP ; std::basic_ios<char,std::char_traits<char> >::setstate
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ PROC NEAR ; std::basic_ios<char,std::char_traits<char> >::rdbuf, COMDAT
; _this$ = ecx

; 80   : 		{	// return stream buffer pointer

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 81   : 		return (_Mystrbuf);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+40]

; 82   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ENDP ; std::basic_ios<char,std::char_traits<char> >::rdbuf
_TEXT	ENDS
EXTRN	?clear@ios_base@std@@QAEXH_N@Z:NEAR		; std::ios_base::clear
; Function compile flags: /Odt /RTCsu
;	COMDAT ?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
__State$ = 8						; size = 4
__Except$ = 12						; size = 1
?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z PROC NEAR ; std::basic_ios<char,std::char_traits<char> >::clear, COMDAT
; _this$ = ecx

; 38   : 		{	// set state, possibly reraise exception

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 39   : 		ios_base::clear((iostate)(_Mystrbuf == 0
; 40   : 			? (int)_State | (int)badbit : (int)_State), _Except);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+40], 0
	jne	SHORT $L13591
	mov	ecx, DWORD PTR __State$[ebp]
	or	ecx, 4
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $L13592
$L13591:
	mov	edx, DWORD PTR __State$[ebp]
	mov	DWORD PTR tv69[ebp], edx
$L13592:
	mov	al, BYTE PTR __Except$[ebp]
	push	eax
	mov	ecx, DWORD PTR tv69[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear

; 41   : 		}

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ENDP ; std::basic_ios<char,std::char_traits<char> >::clear
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ PROC NEAR ; std::basic_ios<char,std::char_traits<char> >::fill, COMDAT
; _this$ = ecx

; 101  : 		{	// return fill character

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 102  : 		return (_Fillch);

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+48]

; 103  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ ENDP ; std::basic_ios<char,std::char_traits<char> >::fill
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\streambuf
_TEXT	ENDS
;	COMDAT ?pubsync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?pubsync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ PROC NEAR ; std::basic_streambuf<char,std::char_traits<char> >::pubsync, COMDAT
; _this$ = ecx

; 95   : 		{	// synchronize with external agent

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 96   : 		return (sync());

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+44]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 97   : 		}

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?pubsync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::pubsync
_TEXT	ENDS
PUBLIC	?to_int_type@?$char_traits@D@std@@SAHABD@Z	; std::char_traits<char>::to_int_type
PUBLIC	?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::pptr
PUBLIC	?epptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::epptr
PUBLIC	?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Pninc
; Function compile flags: /Odt /RTCsu
;	COMDAT ?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
_TEXT	SEGMENT
tv83 = -12						; size = 4
$T13600 = -8						; size = 4
_this$ = -4						; size = 4
__Ch$ = 8						; size = 1
?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z PROC NEAR ; std::basic_streambuf<char,std::char_traits<char> >::sputc, COMDAT
; _this$ = ecx

; 145  : 		{	// put a character

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 146  : 		return (pptr() != 0 && pptr() < epptr()
; 147  : 			? _Traits::to_int_type(*_Pninc() = _Ch)
; 148  : 			: overflow(_Traits::to_int_type(_Ch)));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::pptr
	test	eax, eax
	je	SHORT $L13599
	mov	ecx, DWORD PTR _this$[ebp]
	call	?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::pptr
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?epptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::epptr
	cmp	esi, eax
	jae	SHORT $L13599
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Pninc
	mov	DWORD PTR $T13600[ebp], eax
	mov	eax, DWORD PTR $T13600[ebp]
	mov	cl, BYTE PTR __Ch$[ebp]
	mov	BYTE PTR [eax], cl
	mov	edx, DWORD PTR $T13600[ebp]
	push	edx
	call	?to_int_type@?$char_traits@D@std@@SAHABD@Z ; std::char_traits<char>::to_int_type
	add	esp, 4
	mov	DWORD PTR tv83[ebp], eax
	jmp	SHORT $L13601
$L13599:
	lea	eax, DWORD PTR __Ch$[ebp]
	push	eax
	call	?to_int_type@?$char_traits@D@std@@SAHABD@Z ; std::char_traits<char>::to_int_type
	add	esp, 4
	mov	esi, esp
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+4]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv83[ebp], eax
$L13601:
	mov	eax, DWORD PTR tv83[ebp]

; 149  : 		}

	pop	esi
	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::sputc
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\iosfwd
_TEXT	ENDS
;	COMDAT ?to_int_type@?$char_traits@D@std@@SAHABD@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 4
?to_int_type@?$char_traits@D@std@@SAHABD@Z PROC NEAR	; std::char_traits<char>::to_int_type, COMDAT

; 384  : 		{	// convert character to metacharacter

	push	ebp
	mov	ebp, esp

; 385  : 		return ((unsigned char)_Ch);

	mov	eax, DWORD PTR __Ch$[ebp]
	movzx	eax, BYTE PTR [eax]

; 386  : 		}

	pop	ebp
	ret	0
?to_int_type@?$char_traits@D@std@@SAHABD@Z ENDP		; std::char_traits<char>::to_int_type
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\streambuf
_TEXT	ENDS
;	COMDAT ?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ PROC NEAR ; std::basic_streambuf<char,std::char_traits<char> >::pptr, COMDAT
; _this$ = ecx

; 184  : 		{	// return current position in write buffer

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 185  : 		return (*_IPnext);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	eax, DWORD PTR [ecx]

; 186  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::pptr
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?epptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?epptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ PROC NEAR ; std::basic_streambuf<char,std::char_traits<char> >::epptr, COMDAT
; _this$ = ecx

; 207  : 		{	// return end of write buffer

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 208  : 		return (*_IPnext + *_IPcount);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+52]
	mov	ecx, DWORD PTR [ecx]
	add	ecx, DWORD PTR [eax]
	mov	eax, ecx

; 209  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?epptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::epptr
_TEXT	ENDS
PUBLIC	?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::tie
PUBLIC	?good@ios_base@std@@QBE_NXZ			; std::ios_base::good
PUBLIC	??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
PUBLIC	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\ostream
xdata$x	SEGMENT
$T13614	DD	0ffffffffH
	DD	FLAT:$L13610
$T13612	DD	019930520H
	DD	01H
	DD	FLAT:$T13614
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ostr$ = 8						; size = 4
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC NEAR ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry, COMDAT
; _this$ = ecx

; 88   : 			{	// construct locking and testing stream

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	mov	DWORD PTR [ebp-16], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Ostr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 89   : 			if (_Ostr.good() && _Ostr.tie() != 0)

	mov	ecx, DWORD PTR __Ostr$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Ostr$[ebp]
	add	ecx, DWORD PTR [edx+4]
	call	?good@ios_base@std@@QBE_NXZ		; std::ios_base::good
	movzx	eax, al
	test	eax, eax
	je	SHORT $L11757
	mov	ecx, DWORD PTR __Ostr$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Ostr$[ebp]
	add	ecx, DWORD PTR [edx+4]
	call	?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::tie
	test	eax, eax
	je	SHORT $L11757

; 90   : 				_Ostr.tie()->flush();

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	ecx, edx
	call	?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::tie
	mov	ecx, eax
	call	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush
$L11757:

; 91   : 			_Ok = _Ostr.good();	// store test only after flushing tie

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	ecx, edx
	call	?good@ios_base@std@@QBE_NXZ		; std::ios_base::good
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+4], al

; 92   : 			}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L13610:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z:
	mov	eax, OFFSET FLAT:$T13612
	jmp	___CxxFrameHandler
text$x	ENDS
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xiosbase
;	COMDAT ?good@ios_base@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?good@ios_base@std@@QBE_NXZ PROC NEAR			; std::ios_base::good, COMDAT
; _this$ = ecx

; 287  : 		{	// test if no state bits are set

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 288  : 		return (rdstate() == goodbit);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?rdstate@ios_base@std@@QBEHXZ		; std::ios_base::rdstate
	neg	eax
	sbb	eax, eax
	inc	eax

; 289  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?good@ios_base@std@@QBE_NXZ ENDP			; std::ios_base::good
_TEXT	ENDS
PUBLIC	?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_ostream<char,std::char_traits<char> >::_Osfx
EXTRN	?uncaught_exception@std@@YA_NXZ:NEAR		; std::uncaught_exception
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\ostream
xdata$x	SEGMENT
$T13625	DD	0ffffffffH
	DD	FLAT:$L13621
$T13623	DD	019930520H
	DD	01H
	DD	FLAT:$T13625
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC NEAR ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry, COMDAT
; _this$ = ecx

; 95   : 			{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	mov	DWORD PTR [ebp-16], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 96   : 
; 97   :  #if _HAS_EXCEPTIONS
; 98   : 			if (!uncaught_exception())

	call	?uncaught_exception@std@@YA_NXZ		; std::uncaught_exception
	movzx	eax, al
	test	eax, eax
	jne	SHORT $L11759

; 99   : 				this->_Myostr._Osfx();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_ostream<char,std::char_traits<char> >::_Osfx
$L11759:

; 100  : 			}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L13621:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__ehhandler$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ:
	mov	eax, OFFSET FLAT:$T13623
	jmp	___CxxFrameHandler
text$x	ENDS
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
; Function compile flags: /Odt /RTCsu
;	COMDAT ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ PROC NEAR ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool, COMDAT
; _this$ = ecx

; 108  : 			{	// test if stream state okay

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 109  : 			return (_Ok);

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+4]

; 110  : 			}

	mov	esp, ebp
	pop	ebp
	ret	0
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xlocnum
_TEXT	ENDS
;	COMDAT ?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DJ@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 1
__Val$ = 28						; size = 4
?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DJ@Z PROC NEAR ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::put, COMDAT
; _this$ = ecx

; 836  : 		{	// put formatted long to _Dest

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 837  : 		return (do_put(_Dest, _Iosbase, _Fill, _Val));

	mov	esi, esp
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	cl, BYTE PTR __Fill$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Iosbase$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+28]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 838  : 		}

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DJ@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::put
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xutility
_TEXT	ENDS
;	COMDAT ??0?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Sb$ = 8						; size = 4
??0?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z PROC NEAR ; std::ostreambuf_iterator<char,std::char_traits<char> >::ostreambuf_iterator<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 971  : 		{	// construct from stream buffer _Sb

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Sb$[ebp]
	mov	DWORD PTR [ecx+4], edx

; 972  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z ENDP ; std::ostreambuf_iterator<char,std::char_traits<char> >::ostreambuf_iterator<char,std::char_traits<char> >
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?failed@?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?failed@?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NXZ PROC NEAR ; std::ostreambuf_iterator<char,std::char_traits<char> >::failed, COMDAT
; _this$ = ecx

; 1004 : 		{	// return true if any stores failed

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1005 : 		return (_Failed);

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax]

; 1006 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?failed@?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NXZ ENDP ; std::ostreambuf_iterator<char,std::char_traits<char> >::failed
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\ostream
_TEXT	ENDS
;	COMDAT ?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ PROC NEAR ; std::basic_ostream<char,std::char_traits<char> >::_Osfx, COMDAT
; _this$ = ecx

; 132  : 		{	// perform any wrapup

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 133  : 		if (ios_base::flags() & ios_base::unitbuf)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	ecx, edx
	call	?flags@ios_base@std@@QBEHXZ		; std::ios_base::flags
	and	eax, 2
	je	SHORT $L11984

; 134  : 			flush();	// flush stream as needed

	mov	ecx, DWORD PTR _this$[ebp]
	call	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush
$L11984:

; 135  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Osfx
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\ios
_TEXT	ENDS
;	COMDAT ?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ PROC NEAR ; std::basic_ios<char,std::char_traits<char> >::tie, COMDAT
; _this$ = ecx

; 68   : 		{	// return tie pointer

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 69   : 		return (_Tiestr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+44]

; 70   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ ENDP ; std::basic_ios<char,std::char_traits<char> >::tie
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\streambuf
_TEXT	ENDS
;	COMDAT ?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ
_TEXT	SEGMENT
tv76 = -8						; size = 4
_this$ = -4						; size = 4
?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ PROC NEAR ; std::basic_streambuf<char,std::char_traits<char> >::_Pninc, COMDAT
; _this$ = ecx

; 244  : 		{	// decrement current position in write buffer

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 245  : 		--*_IPcount;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	mov	edx, DWORD PTR [ecx]
	sub	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	mov	DWORD PTR [ecx], edx

; 246  : 		return ((*_IPnext)++);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv76[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR tv76[ebp]

; 247  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Pninc
_TEXT	ENDS
PUBLIC	?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Lock
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\ostream
;	COMDAT ??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ostr$ = 8						; size = 4
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC NEAR ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base, COMDAT
; _this$ = ecx

; 68   : 			{	// lock the stream buffer, if there

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ostr$[ebp]
	mov	DWORD PTR [eax], ecx

; 69   : 			if (_Myostr.rdbuf() != 0)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, DWORD PTR [ecx+4]
	mov	ecx, eax
	call	?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::rdbuf
	test	eax, eax
	je	SHORT $L11993

; 70   : 				_Myostr.rdbuf()->_Lock();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	add	ecx, DWORD PTR [eax+4]
	call	?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::rdbuf
	mov	ecx, eax
	call	?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Lock
$L11993:

; 71   : 			}

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
_TEXT	ENDS
EXTRN	?_Lock@_Mutex@std@@QAEXXZ:NEAR			; std::_Mutex::_Lock
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\streambuf
;	COMDAT ?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEXXZ PROC NEAR ; std::basic_streambuf<char,std::char_traits<char> >::_Lock, COMDAT
; _this$ = ecx

; 157  : 		{	// set the thread lock

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 158  : 		_Mylock._Lock();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?_Lock@_Mutex@std@@QAEXXZ		; std::_Mutex::_Lock

; 159  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEXXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Lock
_TEXT	ENDS
PUBLIC	?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Unlock
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\ostream
;	COMDAT ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC NEAR ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base, COMDAT
; _this$ = ecx

; 74   : 			{	// destroy after unlocking

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 75   : 			if (_Myostr.rdbuf() != 0)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR [edx+4]
	call	?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::rdbuf
	test	eax, eax
	je	SHORT $L11996

; 76   : 				_Myostr.rdbuf()->_Unlock();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	add	ecx, DWORD PTR [eax+4]
	call	?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::rdbuf
	mov	ecx, eax
	call	?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Unlock
$L11996:

; 77   : 			}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
_TEXT	ENDS
EXTRN	?_Unlock@_Mutex@std@@QAEXXZ:NEAR		; std::_Mutex::_Unlock
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\streambuf
;	COMDAT ?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEXXZ PROC NEAR ; std::basic_streambuf<char,std::char_traits<char> >::_Unlock, COMDAT
; _this$ = ecx

; 162  : 		{	// clear the thread lock

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 163  : 		_Mylock._Unlock();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?_Unlock@_Mutex@std@@QAEXXZ		; std::_Mutex::_Unlock

; 164  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEXXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Unlock
_TEXT	ENDS
EXTRN	_free:NEAR
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xdebug
;	COMDAT ??$_DebugHeapDelete@Vfacet@locale@std@@@std@@YAXPAVfacet@locale@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_DebugHeapDelete@Vfacet@locale@std@@@std@@YAXPAVfacet@locale@0@@Z PROC NEAR ; std::_DebugHeapDelete<std::locale::facet>, COMDAT

; 57   : 	{	// delete from the debug CRT heap even if operator delete exists

	push	ebp
	mov	ebp, esp
	push	esi

; 58   : 	if (_Ptr != 0)

	cmp	DWORD PTR __Ptr$[ebp], 0
	je	SHORT $L12285

; 59   : 		{	// worth deleting
; 60   : 		_Ptr->~_Ty();

	mov	esi, esp
	push	0
	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Ptr$[ebp]
	call	DWORD PTR [edx]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 61   : 		// delete as _NORMAL_BLOCK, not _CRT_BLOCK, since we might have
; 62   : 		// facets allocated by normal new.
; 63   : 		free(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	_free
	add	esp, 4
$L12285:

; 64   : 		}
; 65   : 	}

	pop	esi
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
??$_DebugHeapDelete@Vfacet@locale@std@@@std@@YAXPAVfacet@locale@0@@Z ENDP ; std::_DebugHeapDelete<std::locale::facet>
_TEXT	ENDS
PUBLIC	?length@?$char_traits@D@std@@SAIPBD@Z		; std::char_traits<char>::length
PUBLIC	?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHPBDH@Z ; std::basic_streambuf<char,std::char_traits<char> >::sputn
PUBLIC	?width@ios_base@std@@QBEHXZ			; std::ios_base::width
PUBLIC	?width@ios_base@std@@QAEHH@Z			; std::ios_base::width
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\ostream
xdata$x	SEGMENT
$T13670	DD	0ffffffffH
	DD	FLAT:$L13663
	DD	00H
	DD	00H
	DD	00H
	DD	00H
$T13672	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L13662
$T13671	DD	01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:$T13672
$T13665	DD	019930520H
	DD	03H
	DD	FLAT:$T13670
	DD	01H
	DD	FLAT:$T13671
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
_TEXT	SEGMENT
tv209 = -117						; size = 1
tv208 = -116						; size = 4
tv207 = -112						; size = 4
tv206 = -108						; size = 4
tv205 = -101						; size = 1
tv204 = -100						; size = 4
tv203 = -96						; size = 4
tv202 = -89						; size = 1
tv201 = -88						; size = 4
tv200 = -84						; size = 4
tv199 = -80						; size = 4
tv198 = -73						; size = 1
tv83 = -72						; size = 4
tv81 = -68						; size = 4
$T13660 = -64						; size = 4
$T13659 = -60						; size = 4
$T13658 = -56						; size = 4
$T13657 = -52						; size = 4
$T13656 = -48						; size = 4
__Ok$ = -40						; size = 8
__Pad$ = -28						; size = 4
__Count$ = -24						; size = 4
__State$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Ostr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z PROC NEAR ; std::operator<<<std::char_traits<char> >, COMDAT

; 700  : 	{	// insert NTBS into char stream

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	sub	esp, 104				; 00000068H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-120]
	mov	ecx, 26					; 0000001aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	DWORD PTR __$EHRec$[ebp], esp

; 701  : 	typedef char _Elem;
; 702  : 	typedef basic_ostream<_Elem, _Traits> _Myos;
; 703  : 	ios_base::iostate _State = ios_base::goodbit;

	mov	DWORD PTR __State$[ebp], 0

; 704  : 	streamsize _Count = (streamsize)_Traits::length(_Val);	// may overflow

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	call	?length@?$char_traits@D@std@@SAIPBD@Z	; std::char_traits<char>::length
	add	esp, 4
	mov	DWORD PTR __Count$[ebp], eax

; 705  : 	streamsize _Pad = _Ostr.width() <= 0 || _Ostr.width() <= _Count
; 706  : 		? 0 : _Ostr.width() - _Count;

	mov	ecx, DWORD PTR __Ostr$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Ostr$[ebp]
	add	ecx, DWORD PTR [edx+4]
	call	?width@ios_base@std@@QBEHXZ		; std::ios_base::width
	test	eax, eax
	jle	SHORT $L13654
	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	ecx, edx
	call	?width@ios_base@std@@QBEHXZ		; std::ios_base::width
	cmp	eax, DWORD PTR __Count$[ebp]
	jle	SHORT $L13654
	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	ecx, edx
	call	?width@ios_base@std@@QBEHXZ		; std::ios_base::width
	sub	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR tv81[ebp], eax
	jmp	SHORT $L13655
$L13654:
	mov	DWORD PTR tv81[ebp], 0
$L13655:
	mov	eax, DWORD PTR tv81[ebp]
	mov	DWORD PTR __Pad$[ebp], eax

; 707  : 	const typename _Myos::sentry _Ok(_Ostr);

	mov	ecx, DWORD PTR __Ostr$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Ok$[ebp]
	call	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 708  : 
; 709  : 	if (!_Ok)

	lea	ecx, DWORD PTR __Ok$[ebp]
	call	??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
	movzx	edx, al
	test	edx, edx
	jne	SHORT $L12399

; 710  : 		_State |= ios_base::badbit;

	mov	eax, DWORD PTR __State$[ebp]
	or	eax, 4
	mov	DWORD PTR __State$[ebp], eax

; 711  : 	else

	jmp	$L13661
$L12399:

; 712  : 		{	// state okay, insert
; 713  : 		_TRY_IO_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 714  : 		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)

	mov	ecx, DWORD PTR __Ostr$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Ostr$[ebp]
	add	ecx, DWORD PTR [edx+4]
	call	?flags@ios_base@std@@QBEHXZ		; std::ios_base::flags
	mov	DWORD PTR tv83[ebp], eax
	mov	eax, DWORD PTR tv83[ebp]
	and	eax, 448				; 000001c0H
	cmp	eax, 64					; 00000040H
	je	$L12402

; 715  : 			for (; 0 < _Pad; --_Pad)	// pad on left

	jmp	SHORT $L12403
$L12404:
	mov	ecx, DWORD PTR __Pad$[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Pad$[ebp], ecx
$L12403:
	cmp	DWORD PTR __Pad$[ebp], 0
	jle	SHORT $L12402

; 716  : 				if (_Traits::eq_int_type(_Traits::eof(),
; 717  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))

	mov	edx, DWORD PTR __Ostr$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR __Ostr$[ebp]
	add	ecx, DWORD PTR [eax+4]
	call	?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::basic_ios<char,std::char_traits<char> >::fill
	mov	BYTE PTR tv198[ebp], al
	mov	ecx, DWORD PTR __Ostr$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Ostr$[ebp]
	add	ecx, DWORD PTR [edx+4]
	call	?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::rdbuf
	mov	DWORD PTR tv199[ebp], eax
	mov	al, BYTE PTR tv198[ebp]
	push	eax
	mov	ecx, DWORD PTR tv199[ebp]
	call	?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z ; std::basic_streambuf<char,std::char_traits<char> >::sputc
	mov	DWORD PTR tv200[ebp], eax
	mov	ecx, DWORD PTR tv200[ebp]
	mov	DWORD PTR $T13656[ebp], ecx
	call	?eof@?$char_traits@D@std@@SAHXZ		; std::char_traits<char>::eof
	mov	DWORD PTR tv201[ebp], eax
	mov	edx, DWORD PTR tv201[ebp]
	mov	DWORD PTR $T13657[ebp], edx
	lea	eax, DWORD PTR $T13656[ebp]
	push	eax
	lea	ecx, DWORD PTR $T13657[ebp]
	push	ecx
	call	?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z ; std::char_traits<char>::eq_int_type
	add	esp, 8
	mov	BYTE PTR tv202[ebp], al
	movzx	edx, BYTE PTR tv202[ebp]
	test	edx, edx
	je	SHORT $L12408

; 718  : 					{	// insertion failed, quit
; 719  : 					_State |= ios_base::badbit;

	mov	eax, DWORD PTR __State$[ebp]
	or	eax, 4
	mov	DWORD PTR __State$[ebp], eax

; 720  : 					break;

	jmp	SHORT $L12402
$L12408:

; 721  : 					}
; 722  : 
; 723  : 		if (_State == ios_base::goodbit

	jmp	SHORT $L12404
$L12402:

; 724  : 			&& _Ostr.rdbuf()->sputn(_Val, _Count) != _Count)

	cmp	DWORD PTR __State$[ebp], 0
	jne	SHORT $L12409
	mov	ecx, DWORD PTR __Ostr$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Ostr$[ebp]
	add	ecx, DWORD PTR [edx+4]
	call	?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::rdbuf
	mov	DWORD PTR tv203[ebp], eax
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	ecx, DWORD PTR tv203[ebp]
	call	?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHPBDH@Z ; std::basic_streambuf<char,std::char_traits<char> >::sputn
	mov	DWORD PTR tv204[ebp], eax
	mov	edx, DWORD PTR tv204[ebp]
	cmp	edx, DWORD PTR __Count$[ebp]
	je	SHORT $L12409

; 725  : 			_State |= ios_base::badbit;

	mov	eax, DWORD PTR __State$[ebp]
	or	eax, 4
	mov	DWORD PTR __State$[ebp], eax
$L12409:

; 726  : 
; 727  : 		if (_State == ios_base::goodbit)

	cmp	DWORD PTR __State$[ebp], 0
	jne	$L12410

; 728  : 			for (; 0 < _Pad; --_Pad)	// pad on right

	jmp	SHORT $L12411
$L12412:
	mov	ecx, DWORD PTR __Pad$[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Pad$[ebp], ecx
$L12411:
	cmp	DWORD PTR __Pad$[ebp], 0
	jle	SHORT $L12410

; 729  : 				if (_Traits::eq_int_type(_Traits::eof(),
; 730  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))

	mov	edx, DWORD PTR __Ostr$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR __Ostr$[ebp]
	add	ecx, DWORD PTR [eax+4]
	call	?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::basic_ios<char,std::char_traits<char> >::fill
	mov	BYTE PTR tv205[ebp], al
	mov	ecx, DWORD PTR __Ostr$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Ostr$[ebp]
	add	ecx, DWORD PTR [edx+4]
	call	?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::rdbuf
	mov	DWORD PTR tv206[ebp], eax
	mov	al, BYTE PTR tv205[ebp]
	push	eax
	mov	ecx, DWORD PTR tv206[ebp]
	call	?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z ; std::basic_streambuf<char,std::char_traits<char> >::sputc
	mov	DWORD PTR tv207[ebp], eax
	mov	ecx, DWORD PTR tv207[ebp]
	mov	DWORD PTR $T13658[ebp], ecx
	call	?eof@?$char_traits@D@std@@SAHXZ		; std::char_traits<char>::eof
	mov	DWORD PTR tv208[ebp], eax
	mov	edx, DWORD PTR tv208[ebp]
	mov	DWORD PTR $T13659[ebp], edx
	lea	eax, DWORD PTR $T13658[ebp]
	push	eax
	lea	ecx, DWORD PTR $T13659[ebp]
	push	ecx
	call	?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z ; std::char_traits<char>::eq_int_type
	add	esp, 8
	mov	BYTE PTR tv209[ebp], al
	movzx	edx, BYTE PTR tv209[ebp]
	test	edx, edx
	je	SHORT $L12416

; 731  : 					{	// insertion failed, quit
; 732  : 					_State |= ios_base::badbit;

	mov	eax, DWORD PTR __State$[ebp]
	or	eax, 4
	mov	DWORD PTR __State$[ebp], eax

; 733  : 					break;

	jmp	SHORT $L12410
$L12416:

; 734  : 					}
; 735  : 		_Ostr.width(0);

	jmp	SHORT $L12412
$L12410:
	push	0
	mov	ecx, DWORD PTR __Ostr$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Ostr$[ebp]
	add	ecx, DWORD PTR [edx+4]
	call	?width@ios_base@std@@QAEHH@Z		; std::ios_base::width
	jmp	SHORT $L13661
$L13662:

; 736  : 		_CATCH_IO_(_Ostr)

	push	1
	push	4
	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	ecx, edx
	call	?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate
	mov	eax, $L13661
	ret	0
$L13661:
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 737  : 		}
; 738  : 
; 739  : 	_Ostr.setstate(_State);

	push	0
	mov	eax, DWORD PTR __State$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ostr$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Ostr$[ebp]
	add	ecx, DWORD PTR [edx+4]
	call	?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate

; 740  : 	return (_Ostr);

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	DWORD PTR $T13660[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	lea	ecx, DWORD PTR __Ok$[ebp]
	call	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
	mov	eax, DWORD PTR $T13660[ebp]

; 741  : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L13669
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 120				; 00000078H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$L13669:
	DD	1
	DD	$L13668
$L13668:
	DD	-40					; ffffffd8H
	DD	8
	DD	$L13666
$L13666:
	DB	95					; 0000005fH
	DB	79					; 0000004fH
	DB	107					; 0000006bH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L13663:
	lea	ecx, DWORD PTR __Ok$[ebp]
	jmp	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
__ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z:
	mov	eax, OFFSET FLAT:$T13665
	jmp	___CxxFrameHandler
text$x	ENDS
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ENDP ; std::operator<<<std::char_traits<char> >
EXTRN	_strlen:NEAR
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\iosfwd
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
?length@?$char_traits@D@std@@SAIPBD@Z PROC NEAR		; std::char_traits<char>::length, COMDAT

; 351  : 		{	// find length of null-terminated string

	push	ebp
	mov	ebp, esp

; 352  : 		return (::strlen(_First));

	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	_strlen
	add	esp, 4

; 353  : 		}

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
?length@?$char_traits@D@std@@SAIPBD@Z ENDP		; std::char_traits<char>::length
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xiosbase
_TEXT	ENDS
;	COMDAT ?width@ios_base@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?width@ios_base@std@@QBEHXZ PROC NEAR			; std::ios_base::width, COMDAT
; _this$ = ecx

; 369  : 		{	// return width

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 370  : 		return (_Wide);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+24]

; 371  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?width@ios_base@std@@QBEHXZ ENDP			; std::ios_base::width
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?width@ios_base@std@@QAEHH@Z
_TEXT	SEGMENT
__Oldwidth$ = -8					; size = 4
_this$ = -4						; size = 4
__Newwidth$ = 8						; size = 4
?width@ios_base@std@@QAEHH@Z PROC NEAR			; std::ios_base::width, COMDAT
; _this$ = ecx

; 374  : 		{	// set width to argument

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 375  : 		streamsize _Oldwidth = _Wide;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR __Oldwidth$[ebp], ecx

; 376  : 		_Wide = _Newwidth;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Newwidth$[ebp]
	mov	DWORD PTR [edx+24], eax

; 377  : 		return (_Oldwidth);

	mov	eax, DWORD PTR __Oldwidth$[ebp]

; 378  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?width@ios_base@std@@QAEHH@Z ENDP			; std::ios_base::width
_TEXT	ENDS
PUBLIC	__TI2?AVbad_cast@@
PUBLIC	__CTA2?AVbad_cast@@
PUBLIC	??_R0?AVbad_cast@@@8				; bad_cast `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_cast@@@8??0bad_cast@@QAE@ABV0@@Z12
PUBLIC	??_R0?AVexception@@@8				; exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
PUBLIC	??_C@_08EPJLHIJG@bad?5cast?$AA@			; `string'
PUBLIC	?_Psave@?$_Facetptr@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >::_Psave
PUBLIC	??Bid@locale@std@@QAEIXZ			; std::locale::id::operator unsigned int
PUBLIC	?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Getcat
EXTRN	??0exception@@QAE@ABV0@@Z:NEAR			; exception::exception
EXTRN	__CxxThrowException@8:NEAR
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??0bad_cast@@QAE@PBD@Z:NEAR			; bad_cast::bad_cast
EXTRN	??0bad_cast@@QAE@ABV0@@Z:NEAR			; bad_cast::bad_cast
EXTRN	??1bad_cast@@UAE@XZ:NEAR			; bad_cast::~bad_cast
EXTRN	?_Register@facet@locale@std@@QAEXXZ:NEAR	; std::locale::facet::_Register
EXTRN	?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z:NEAR	; std::locale::_Getfacet
;	COMDAT ?_Psave@?$_Facetptr@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xlocale
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B DD 01H DUP (?) ; std::_Facetptr<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >::_Psave
_BSS	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
$T13694	DD	0ffffffffH
	DD	FLAT:$L13686
$T13688	DD	019930520H
	DD	01H
	DD	FLAT:$T13694
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_C@_08EPJLHIJG@bad?5cast?$AA@
CONST	SEGMENT
??_C@_08EPJLHIJG@bad?5cast?$AA@ DB 'bad cast', 00H	; `string'
CONST	ENDS
;	COMDAT __TI2?AVbad_cast@@
xdata$x	SEGMENT
__TI2?AVbad_cast@@ DD 00H
	DD	FLAT:??1bad_cast@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_cast@@
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_cast@@
xdata$x	SEGMENT
__CTA2?AVbad_cast@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_cast@@@8??0bad_cast@@QAE@ABV0@@Z12
	DD	FLAT:__CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	ENDS
;	COMDAT __CT??_R0?AVbad_cast@@@8??0bad_cast@@QAE@ABV0@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_cast@@@8??0bad_cast@@QAE@ABV0@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_cast@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_cast@@QAE@ABV0@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_cast@@@8
_DATA	SEGMENT
??_R0?AVbad_cast@@@8 DD FLAT:??_7type_info@@6B@		; bad_cast `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_cast@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@@QAE@ABV0@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@@@8
_DATA	SEGMENT
??_R0?AVexception@@@8 DD FLAT:??_7type_info@@6B@	; exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@@', 00H
; Function compile flags: /Odt /RTCsu
_DATA	ENDS
;	COMDAT ??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z
_TEXT	SEGMENT
$T13685 = -64						; size = 4
$T13683 = -60						; size = 12
__Pfmod$12445 = -48					; size = 4
__Pf$ = -44						; size = 4
__Id$ = -40						; size = 4
__Psave$ = -32						; size = 4
__Lock$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Loc$ = 8						; size = 4
??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z PROC NEAR ; std::use_facet<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >, COMDAT

; 315  : 	{	// get facet reference from locale

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 52					; 00000034H
	push	edi
	lea	edi, DWORD PTR [ebp-64]
	mov	ecx, 13					; 0000000dH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 316  : 	_Lockit _Lock(_LOCK_LOCALE);	// the thread lock, make get atomic

	push	0
	lea	ecx, DWORD PTR __Lock$[ebp]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 317  : 	const locale::facet *_Psave =
; 318  : 		_Facetptr<_Facet>::_Psave;	// static pointer to lazy facet

	mov	eax, DWORD PTR ?_Psave@?$_Facetptr@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >::_Psave
	mov	DWORD PTR __Psave$[ebp], eax

; 319  : 
; 320  : 	size_t _Id = _Facet::id;

	mov	ecx, OFFSET FLAT:?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id
	call	??Bid@locale@std@@QAEIXZ		; std::locale::id::operator unsigned int
	mov	DWORD PTR __Id$[ebp], eax

; 321  : 	const locale::facet *_Pf = _Loc._Getfacet(_Id);

	mov	ecx, DWORD PTR __Id$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Loc$[ebp]
	call	?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z ; std::locale::_Getfacet
	mov	DWORD PTR __Pf$[ebp], eax

; 322  : 
; 323  : 	if (_Pf != 0)

	cmp	DWORD PTR __Pf$[ebp], 0
	je	SHORT $L12436

; 324  : 		;	// got facet from locale
; 325  : 	else if (_Psave != 0)

	jmp	SHORT $L12437
$L12436:
	cmp	DWORD PTR __Psave$[ebp], 0
	je	SHORT $L12438

; 326  : 		_Pf = _Psave;	// lazy facet already allocated

	mov	edx, DWORD PTR __Psave$[ebp]
	mov	DWORD PTR __Pf$[ebp], edx

; 327  : 	else if (_Facet::_Getcat(&_Psave) == (size_t)(-1))

	jmp	SHORT $L12437
$L12438:
	lea	eax, DWORD PTR __Psave$[ebp]
	push	eax
	call	?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Getcat
	add	esp, 4
	cmp	eax, -1
	jne	SHORT $L12441

; 328  : 
; 329  :  #if _HAS_EXCEPTIONS
; 330  : 		throw bad_cast();	// lazy disallowed

	push	OFFSET FLAT:??_C@_08EPJLHIJG@bad?5cast?$AA@
	lea	ecx, DWORD PTR $T13683[ebp]
	call	??0bad_cast@@QAE@PBD@Z			; bad_cast::bad_cast
	push	OFFSET FLAT:__TI2?AVbad_cast@@
	lea	ecx, DWORD PTR $T13683[ebp]
	push	ecx
	call	__CxxThrowException@8
$L12441:

; 331  : 
; 332  :  #else /* _HAS_EXCEPTIONS */
; 333  : 		abort();	// lazy disallowed
; 334  :  #endif /* _HAS_EXCEPTIONS */
; 335  : 
; 336  : 	else
; 337  : 		{	// queue up lazy facet for destruction
; 338  : 		_Pf = _Psave;

	mov	edx, DWORD PTR __Psave$[ebp]
	mov	DWORD PTR __Pf$[ebp], edx

; 339  : 		_Facetptr<_Facet>::_Psave = _Psave;

	mov	eax, DWORD PTR __Psave$[ebp]
	mov	DWORD PTR ?_Psave@?$_Facetptr@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B, eax ; std::_Facetptr<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >::_Psave

; 340  : 
; 341  : 		locale::facet *_Pfmod = (_Facet *)_Psave;

	mov	ecx, DWORD PTR __Psave$[ebp]
	mov	DWORD PTR __Pfmod$12445[ebp], ecx

; 342  : 		_Pfmod->_Incref();

	mov	ecx, DWORD PTR __Pfmod$12445[ebp]
	call	?_Incref@facet@locale@std@@QAEXXZ	; std::locale::facet::_Incref

; 343  : 		_Pfmod->_Register();

	mov	ecx, DWORD PTR __Pfmod$12445[ebp]
	call	?_Register@facet@locale@std@@QAEXXZ	; std::locale::facet::_Register
$L12437:

; 344  : 		}
; 345  : 
; 346  : 	return ((const _Facet&)(*_Pf));	// should be dynamic_cast

	mov	edx, DWORD PTR __Pf$[ebp]
	mov	DWORD PTR $T13685[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Lock$[ebp]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	mov	eax, DWORD PTR $T13685[ebp]
$L13682:

; 347  : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L13693
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	add	esp, 64					; 00000040H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$L13693:
	DD	2
	DD	$L13692
$L13692:
	DD	-20					; ffffffecH
	DD	4
	DD	$L13689
	DD	-32					; ffffffe0H
	DD	4
	DD	$L13690
$L13690:
	DB	95					; 0000005fH
	DB	80					; 00000050H
	DB	115					; 00000073H
	DB	97					; 00000061H
	DB	118					; 00000076H
	DB	101					; 00000065H
	DB	0
$L13689:
	DB	95					; 0000005fH
	DB	76					; 0000004cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L13686:
	lea	ecx, DWORD PTR __Lock$[ebp]
	jmp	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
__ehhandler$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z:
	mov	eax, OFFSET FLAT:$T13688
	jmp	___CxxFrameHandler
text$x	ENDS
??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z ENDP ; std::use_facet<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >
EXTRN	?_Id_cnt@id@locale@std@@0HA:DWORD		; std::locale::id::_Id_cnt
; Function compile flags: /Odt /RTCsu
;	COMDAT ??Bid@locale@std@@QAEIXZ
_TEXT	SEGMENT
__Lock$5668 = -12					; size = 4
_this$ = -4						; size = 4
??Bid@locale@std@@QAEIXZ PROC NEAR			; std::locale::id::operator unsigned int, COMDAT
; _this$ = ecx

; 70   : 			{	// get stamp, with lazy allocation

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 71   : 			if (_Id == 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $L5667

; 72   : 				{	// still zero, allocate stamp
; 73   : 				_Lockit _Lock(_LOCK_LOCALE);

	push	0
	lea	ecx, DWORD PTR __Lock$5668[ebp]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit

; 74   : 				if (_Id == 0)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $L5669

; 75   : 					_Id = ++_Id_cnt;

	mov	edx, DWORD PTR ?_Id_cnt@id@locale@std@@0HA ; std::locale::id::_Id_cnt
	add	edx, 1
	mov	DWORD PTR ?_Id_cnt@id@locale@std@@0HA, edx ; std::locale::id::_Id_cnt
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ?_Id_cnt@id@locale@std@@0HA ; std::locale::id::_Id_cnt
	mov	DWORD PTR [eax], ecx
$L5669:

; 76   : 				}

	lea	ecx, DWORD PTR __Lock$5668[ebp]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
$L5667:

; 77   : 			return (_Id);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]

; 78   : 			}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L13703
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$L13703:
	DD	1
	DD	$L13702
$L13702:
	DD	-12					; fffffff4H
	DD	4
	DD	$L13701
$L13701:
	DB	95					; 0000005fH
	DB	76					; 0000004cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	0
??Bid@locale@std@@QAEIXZ ENDP				; std::locale::id::operator unsigned int
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\streambuf
_TEXT	ENDS
;	COMDAT ?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHPBDH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHPBDH@Z PROC NEAR ; std::basic_streambuf<char,std::char_traits<char> >::sputn, COMDAT
; _this$ = ecx

; 152  : 		{	// put _Count characters from array beginning at _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 153  : 		return (xsputn(_Ptr, _Count));

	mov	esi, esp
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+28]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 154  : 		}

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHPBDH@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::sputn
_TEXT	ENDS
PUBLIC	??_C@_0EN@IBFBLEEG@D?3?2Program?5Files?5?$CIx86?$CJ?2Microsoft@ ; `string'
PUBLIC	??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@I@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >
EXTRN	??2@YAPAXIABU_DebugHeapTag_t@std@@PADH@Z:NEAR	; operator new
EXTRN	??3@YAXPAXABU_DebugHeapTag_t@std@@PADH@Z:NEAR	; operator delete
EXTRN	?_DebugHeapTag@std@@3U_DebugHeapTag_t@1@B:DWORD	; std::_DebugHeapTag
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xlocnum
xdata$x	SEGMENT
$T13716	DD	0ffffffffH
	DD	FLAT:$L13712
$T13714	DD	019930520H
	DD	01H
	DD	FLAT:$T13716
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_C@_0EN@IBFBLEEG@D?3?2Program?5Files?5?$CIx86?$CJ?2Microsoft@
CONST	SEGMENT
??_C@_0EN@IBFBLEEG@D?3?2Program?5Files?5?$CIx86?$CJ?2Microsoft@ DB 'D:\Pr'
	DB	'ogram Files (x86)\Microsoft Visual Studio .NET 2003\Vc7\inclu'
	DB	'de\xlocnum', 00H				; `string'
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@@Z
_TEXT	SEGMENT
tv80 = -24						; size = 4
$T13709 = -20						; size = 4
$T13708 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ppf$ = 8						; size = 4
?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@@Z PROC NEAR ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Getcat, COMDAT

; 791  : 		{	// return locale category mask and construct standard facet

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-24], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-20], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-16], -858993460		; ccccccccH

; 792  : 		if (_Ppf != 0 && *_Ppf == 0)

	cmp	DWORD PTR __Ppf$[ebp], 0
	je	SHORT $L12492
	mov	eax, DWORD PTR __Ppf$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $L12492

; 793  : 			*_Ppf = _NEW_CRT num_put<_Elem, _OutIt>;

	push	793					; 00000319H
	push	OFFSET FLAT:??_C@_0EN@IBFBLEEG@D?3?2Program?5Files?5?$CIx86?$CJ?2Microsoft@
	push	OFFSET FLAT:?_DebugHeapTag@std@@3U_DebugHeapTag_t@1@B ; std::_DebugHeapTag
	push	16					; 00000010H
	call	??2@YAPAXIABU_DebugHeapTag_t@std@@PADH@Z ; operator new
	add	esp, 16					; 00000010H
	mov	DWORD PTR $T13709[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T13709[ebp], 0
	je	SHORT $L13710
	push	0
	mov	ecx, DWORD PTR $T13709[ebp]
	call	??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@I@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >
	mov	DWORD PTR tv80[ebp], eax
	jmp	SHORT $L13711
$L13710:
	mov	DWORD PTR tv80[ebp], 0
$L13711:
	mov	ecx, DWORD PTR tv80[ebp]
	mov	DWORD PTR $T13708[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR __Ppf$[ebp]
	mov	eax, DWORD PTR $T13708[ebp]
	mov	DWORD PTR [edx], eax
$L12492:

; 794  : 		return (_X_NUMERIC);

	mov	eax, 4

; 795  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 24					; 00000018H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L13712:
	push	793					; 00000319H
	push	OFFSET FLAT:??_C@_0EN@IBFBLEEG@D?3?2Program?5Files?5?$CIx86?$CJ?2Microsoft@
	push	OFFSET FLAT:?_DebugHeapTag@std@@3U_DebugHeapTag_t@1@B ; std::_DebugHeapTag
	mov	eax, DWORD PTR $T13709[ebp]
	push	eax
	call	??3@YAXPAXABU_DebugHeapTag_t@std@@PADH@Z ; operator delete
	add	esp, 16					; 00000010H
	ret	0
__ehhandler$?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@@Z:
	mov	eax, OFFSET FLAT:$T13714
	jmp	___CxxFrameHandler
text$x	ENDS
?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Getcat
PUBLIC	??_R1A@?0A@A@facet@locale@std@@8		; std::locale::facet::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	??_R0?AVfacet@locale@std@@@8			; std::locale::facet `RTTI Type Descriptor'
PUBLIC	??_R4?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@ ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@8 ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > `RTTI Type Descriptor'
PUBLIC	??_R3?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@A@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	??1facet@locale@std@@UAE@XZ			; std::locale::facet::~facet
PUBLIC	??0facet@locale@std@@IAE@I@Z			; std::locale::facet::facet
PUBLIC	?_Init@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEXABV_Locinfo@2@@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Init
PUBLIC	??_C@_01GFHCPBMG@C?$AA@				; `string'
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DJ@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DK@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_J@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_K@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBX@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	??_7?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@ ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`vftable'
PUBLIC	??_G?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`scalar deleting destructor'
EXTRN	??0_Locinfo@std@@QAE@PBD@Z:NEAR			; std::_Locinfo::_Locinfo
EXTRN	??1_Locinfo@std@@QAE@XZ:NEAR			; std::_Locinfo::~_Locinfo
EXTRN	??_E?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z:NEAR ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`vector deleting destructor'
;	COMDAT xdata$x
xdata$x	SEGMENT
$T13727	DD	0ffffffffH
	DD	FLAT:$L13722
	DD	00H
	DD	FLAT:$L13723
$T13725	DD	019930520H
	DD	02H
	DD	FLAT:$T13727
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_7?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@
CONST	SEGMENT
??_7?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@ DD FLAT:??_R4?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@ ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`vftable'
	DD	FLAT:??_E?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z
	DD	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBX@Z
	DD	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z
	DD	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z
	DD	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_K@Z
	DD	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_J@Z
	DD	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DK@Z
	DD	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DJ@Z
	DD	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z
CONST	ENDS
;	COMDAT ??_C@_01GFHCPBMG@C?$AA@
CONST	SEGMENT
??_C@_01GFHCPBMG@C?$AA@ DB 'C', 00H			; `string'
CONST	ENDS
;	COMDAT ??_R4?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@ DD 00H ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@8
	DD	FLAT:??_R3?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@8
_DATA	SEGMENT
??_R0?AV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@'
	DB	'std@@@std@@@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R3?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	SEGMENT
??_R3?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 DD 00H ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	SEGMENT
??_R2?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 DD FLAT:??_R1A@?0A@A@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@A@facet@locale@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@A@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 DD FLAT:??_R0?AV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@8 ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@facet@locale@std@@8
rdata$r	SEGMENT
??_R1A@?0A@A@facet@locale@std@@8 DD FLAT:??_R0?AVfacet@locale@std@@@8 ; std::locale::facet::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
rdata$r	ENDS
;	COMDAT ??_R0?AVfacet@locale@std@@@8
_DATA	SEGMENT
??_R0?AVfacet@locale@std@@@8 DD FLAT:??_7type_info@@6B@	; std::locale::facet `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVfacet@locale@std@@', 00H
; Function compile flags: /Odt /RTCsu
_DATA	ENDS
;	COMDAT ??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@I@Z
_TEXT	SEGMENT
tv77 = -140						; size = 4
tv65 = -136						; size = 4
$T13721 = -132						; size = 116
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Refs$ = 8						; size = 4
??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@I@Z PROC NEAR ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >, COMDAT
; _this$ = ecx

; 815  : 		{	// construct from current locale

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@I@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 128				; 00000080H
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-140]
	mov	ecx, 32					; 00000020H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Refs$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0facet@locale@std@@IAE@I@Z		; std::locale::facet::facet
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET FLAT:??_7?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@

; 816  : 		_Init(_Locinfo());

	push	OFFSET FLAT:??_C@_01GFHCPBMG@C?$AA@
	lea	ecx, DWORD PTR $T13721[ebp]
	call	??0_Locinfo@std@@QAE@PBD@Z		; std::_Locinfo::_Locinfo
	mov	DWORD PTR tv65[ebp], eax
	mov	edx, DWORD PTR tv65[ebp]
	mov	DWORD PTR tv77[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR tv77[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Init@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEXABV_Locinfo@2@@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Init
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T13721[ebp]
	call	??1_Locinfo@std@@QAE@XZ			; std::_Locinfo::~_Locinfo

; 817  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	add	esp, 140				; 0000008cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L13722:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1facet@locale@std@@UAE@XZ		; std::locale::facet::~facet
$L13723:
	lea	ecx, DWORD PTR $T13721[ebp]
	jmp	??1_Locinfo@std@@QAE@XZ			; std::_Locinfo::~_Locinfo
__ehhandler$??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@I@Z:
	mov	eax, OFFSET FLAT:$T13725
	jmp	___CxxFrameHandler
text$x	ENDS
??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@I@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >
PUBLIC	??_R4facet@locale@std@@6B@			; std::locale::facet::`RTTI Complete Object Locator'
PUBLIC	??_R3facet@locale@std@@8			; std::locale::facet::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2facet@locale@std@@8			; std::locale::facet::`RTTI Base Class Array'
PUBLIC	??_7facet@locale@std@@6B@			; std::locale::facet::`vftable'
PUBLIC	??_Gfacet@locale@std@@UAEPAXI@Z			; std::locale::facet::`scalar deleting destructor'
EXTRN	??_Efacet@locale@std@@UAEPAXI@Z:NEAR		; std::locale::facet::`vector deleting destructor'
;	COMDAT ??_7facet@locale@std@@6B@
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xlocale
CONST	SEGMENT
??_7facet@locale@std@@6B@ DD FLAT:??_R4facet@locale@std@@6B@ ; std::locale::facet::`vftable'
	DD	FLAT:??_Efacet@locale@std@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R4facet@locale@std@@6B@
rdata$r	SEGMENT
??_R4facet@locale@std@@6B@ DD 00H			; std::locale::facet::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVfacet@locale@std@@@8
	DD	FLAT:??_R3facet@locale@std@@8
rdata$r	ENDS
;	COMDAT ??_R3facet@locale@std@@8
rdata$r	SEGMENT
??_R3facet@locale@std@@8 DD 00H				; std::locale::facet::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2facet@locale@std@@8
rdata$r	ENDS
;	COMDAT ??_R2facet@locale@std@@8
rdata$r	SEGMENT
??_R2facet@locale@std@@8 DD FLAT:??_R1A@?0A@A@facet@locale@std@@8 ; std::locale::facet::`RTTI Base Class Array'
; Function compile flags: /Odt /RTCsu
rdata$r	ENDS
;	COMDAT ??1facet@locale@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1facet@locale@std@@UAE@XZ PROC NEAR			; std::locale::facet::~facet, COMDAT
; _this$ = ecx

; 123  : 			{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7facet@locale@std@@6B@

; 124  : 			}

	mov	esp, ebp
	pop	ebp
	ret	0
??1facet@locale@std@@UAE@XZ ENDP			; std::locale::facet::~facet
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??0facet@locale@std@@IAE@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Initrefs$ = 8						; size = 4
??0facet@locale@std@@IAE@I@Z PROC NEAR			; std::locale::facet::facet, COMDAT
; _this$ = ecx

; 129  : 			{	// construct with initial reference count

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7facet@locale@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Initrefs$[ebp]
	mov	DWORD PTR [ecx+4], edx

; 130  : 			}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0facet@locale@std@@IAE@I@Z ENDP			; std::locale::facet::facet
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??_Gfacet@locale@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gfacet@locale@std@@UAEPAXI@Z PROC NEAR		; std::locale::facet::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1facet@locale@std@@UAE@XZ		; std::locale::facet::~facet
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $L5713
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L5713:
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gfacet@locale@std@@UAEPAXI@Z ENDP			; std::locale::facet::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
PUBLIC	??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z ; std::use_facet<std::numpunct<char> >
PUBLIC	?falsename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::falsename
PUBLIC	?truename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::truename
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put
PUBLIC	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:NEAR
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xlocnum
xdata$x	SEGMENT
$T13759	DD	0ffffffffH
	DD	FLAT:$L13746
	DD	0ffffffffH
	DD	FLAT:$L13747
	DD	01H
	DD	FLAT:$L13748
	DD	01H
	DD	FLAT:$L13749
$T13751	DD	019930520H
	DD	04H
	DD	FLAT:$T13759
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z
_TEXT	SEGMENT
tv148 = -168						; size = 4
tv184 = -164						; size = 4
tv187 = -160						; size = 4
tv182 = -156						; size = 4
tv85 = -152						; size = 4
tv179 = -148						; size = 4
tv186 = -144						; size = 4
$T13745 = -140						; size = 8
$T13744 = -132						; size = 8
$T13741 = -124						; size = 28
$T13740 = -96						; size = 28
$T13739 = -68						; size = 4
__Fillcount$11826 = -64					; size = 4
__Str$11782 = -56					; size = 28
__Punct_fac$11776 = -24					; size = 4
_this$ = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 1
__Val$ = 28						; size = 1
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z PROC NEAR ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT
; _this$ = ecx

; 881  : 		{	// put formatted bool to _Dest

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 156				; 0000009cH
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-168]
	mov	ecx, 39					; 00000027H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 882  : 		if (!(_Iosbase.flags() & ios_base::boolalpha))

	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?flags@ios_base@std@@QBEHXZ		; std::ios_base::flags
	and	eax, 16384				; 00004000H
	jne	SHORT $L11772

; 883  : 			return (do_put(_Dest, _Iosbase, _Fill, (long)_Val));

	movzx	eax, BYTE PTR __Val$[ebp]
	mov	esi, esp
	push	eax
	mov	cl, BYTE PTR __Fill$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Iosbase$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+28]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$L11771
$L11772:

; 884  : 		else
; 885  : 			{	// put "false" or "true"
; 886  : 			const _Mypunct& _Punct_fac = _USE(_Iosbase.getloc(), _Mypunct);

	lea	eax, DWORD PTR $T13739[ebp]
	push	eax
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?getloc@ios_base@std@@QBE?AVlocale@2@XZ	; std::ios_base::getloc
	mov	DWORD PTR tv186[ebp], eax
	mov	ecx, DWORD PTR tv186[ebp]
	mov	DWORD PTR tv179[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR tv179[ebp]
	push	edx
	call	??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z ; std::use_facet<std::numpunct<char> >
	add	esp, 4
	mov	DWORD PTR __Punct_fac$11776[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T13739[ebp]
	call	??1locale@std@@QAE@XZ			; std::locale::~locale

; 887  : 			_Mystr _Str;

	lea	ecx, DWORD PTR __Str$11782[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 888  : 			if (_Val)

	movzx	eax, BYTE PTR __Val$[ebp]
	test	eax, eax
	je	SHORT $L11783

; 889  : 				_Str.assign(_Punct_fac.truename());

	lea	ecx, DWORD PTR $T13740[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Punct_fac$11776[ebp]
	call	?truename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::truename
	mov	DWORD PTR tv85[ebp], eax
	mov	edx, DWORD PTR tv85[ebp]
	mov	DWORD PTR tv182[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	eax, DWORD PTR tv182[ebp]
	push	eax
	lea	ecx, DWORD PTR __Str$11782[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T13740[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 890  : 			else

	jmp	SHORT $L11824
$L11783:

; 891  : 				_Str.assign(_Punct_fac.falsename());

	lea	ecx, DWORD PTR $T13741[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Punct_fac$11776[ebp]
	call	?falsename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::falsename
	mov	DWORD PTR tv187[ebp], eax
	mov	edx, DWORD PTR tv187[ebp]
	mov	DWORD PTR tv184[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	eax, DWORD PTR tv184[ebp]
	push	eax
	lea	ecx, DWORD PTR __Str$11782[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T13741[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L11824:

; 892  : 
; 893  : 			size_t _Fillcount = _Iosbase.width() <= 0
; 894  : 				|| (size_t)_Iosbase.width() <= _Str.size()
; 895  : 					? 0 : (size_t)_Iosbase.width() - _Str.size();

	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?width@ios_base@std@@QBEHXZ		; std::ios_base::width
	test	eax, eax
	jle	SHORT $L13742
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?width@ios_base@std@@QBEHXZ		; std::ios_base::width
	mov	esi, eax
	lea	ecx, DWORD PTR __Str$11782[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	cmp	esi, eax
	jbe	SHORT $L13742
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?width@ios_base@std@@QBEHXZ		; std::ios_base::width
	mov	esi, eax
	lea	ecx, DWORD PTR __Str$11782[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	sub	esi, eax
	mov	DWORD PTR tv148[ebp], esi
	jmp	SHORT $L13743
$L13742:
	mov	DWORD PTR tv148[ebp], 0
$L13743:
	mov	ecx, DWORD PTR tv148[ebp]
	mov	DWORD PTR __Fillcount$11826[ebp], ecx

; 896  : 
; 897  : 			if ((_Iosbase.flags() & ios_base::adjustfield) != ios_base::left)

	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?flags@ios_base@std@@QBEHXZ		; std::ios_base::flags
	and	eax, 448				; 000001c0H
	cmp	eax, 64					; 00000040H
	je	SHORT $L11829

; 898  : 				{	// put leading fill
; 899  : 				_Dest = _Rep(_Dest, _Fill, _Fillcount);

	mov	edx, DWORD PTR __Fillcount$11826[ebp]
	push	edx
	mov	al, BYTE PTR __Fill$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR $T13744[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
	add	esp, 24					; 00000018H
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR __Dest$[ebp], edx
	mov	DWORD PTR __Dest$[ebp+4], eax

; 900  : 				_Fillcount = 0;

	mov	DWORD PTR __Fillcount$11826[ebp], 0
$L11829:

; 901  : 				}
; 902  : 			_Dest = _Put(_Dest, _Str.c_str(), _Str.size());	// put field

	lea	ecx, DWORD PTR __Str$11782[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	push	eax
	lea	ecx, DWORD PTR __Str$11782[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR $T13745[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put
	add	esp, 24					; 00000018H
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR __Dest$[ebp], edx
	mov	DWORD PTR __Dest$[ebp+4], eax

; 903  : 			_Iosbase.width(0);

	push	0
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?width@ios_base@std@@QAEHH@Z		; std::ios_base::width

; 904  : 			return (_Rep(_Dest, _Fill, _Fillcount));	// put trailing fill

	mov	ecx, DWORD PTR __Fillcount$11826[ebp]
	push	ecx
	mov	dl, BYTE PTR __Fill$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
	add	esp, 24					; 00000018H
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Str$11782[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$L11771:

; 905  : 			}
; 906  : 		}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L13757
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	call	@__security_check_cookie@4
	pop	edi
	pop	esi
	add	esp, 168				; 000000a8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
$L13757:
	DD	1
	DD	$L13756
$L13756:
	DD	-56					; ffffffc8H
	DD	28					; 0000001cH
	DD	$L13752
$L13752:
	DB	95					; 0000005fH
	DB	83					; 00000053H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L13746:
	lea	ecx, DWORD PTR $T13739[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
$L13747:
	lea	ecx, DWORD PTR __Str$11782[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L13748:
	lea	ecx, DWORD PTR $T13740[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L13749:
	lea	ecx, DWORD PTR $T13741[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z:
	mov	eax, OFFSET FLAT:$T13751
	jmp	___CxxFrameHandler
text$x	ENDS
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 456  : 		{	// destroy the string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 457  : 		_Tidy(true);

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 458  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
PUBLIC	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
; Function compile flags: /Odt /RTCsu
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str, COMDAT
; _this$ = ecx

; 1093 : 		{	// return pointer to null-terminated nonmutable array

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1094 : 		return (_Myptr());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr

; 1095 : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 1108 : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1109 : 		return (_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+20]

; 1110 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
PUBLIC	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::copy
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
PUBLIC	?deallocate@?$allocator@D@std@@QAEXPADI@Z	; std::allocator<char>::deallocate
; Function compile flags: /Odt /RTCsu
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z
_TEXT	SEGMENT
__Ptr$11525 = -8					; size = 4
_this$ = -4						; size = 4
__Built$ = 8						; size = 1
__Newsize$ = 12						; size = 4
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 1509 : 		{	// initialize buffer, deallocating any storage

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1510 : 		if (!_Built)

	movzx	eax, BYTE PTR __Built$[ebp]
	test	eax, eax
	jne	SHORT $L11522

; 1511 : 			;
; 1512 : 		else if (_BUF_SIZE <= _Myres)

	jmp	SHORT $L11523
$L11522:
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+24], 16			; 00000010H
	jb	SHORT $L11523

; 1513 : 			{	// copy any leftovers to small buffer and deallocate
; 1514 : 			_Elem *_Ptr = _Bx._Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Ptr$11525[ebp], eax

; 1515 : 			if (0 < _Newsize)

	cmp	DWORD PTR __Newsize$[ebp], 0
	jbe	SHORT $L11526

; 1516 : 				_Traits::copy(_Bx._Buf, _Ptr, _Newsize);

	mov	ecx, DWORD PTR __Newsize$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Ptr$11525[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH
$L11526:

; 1517 : 			_Mybase::_Alval.deallocate(_Ptr, _Myres + 1);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	add	edx, 1
	push	edx
	mov	eax, DWORD PTR __Ptr$11525[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate
$L11523:

; 1518 : 			}
; 1519 : 		_Myres = _BUF_SIZE - 1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+24], 15			; 0000000fH

; 1520 : 		_Eos(_Newsize);

	mov	edx, DWORD PTR __Newsize$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 1521 : 		}

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
_TEXT	ENDS
EXTRN	_memcpy:NEAR
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\iosfwd
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z PROC NEAR	; std::char_traits<char>::copy, COMDAT

; 357  : 		{	// copy [_First1, _First1 + _Count) to [_First2, ...)

	push	ebp
	mov	ebp, esp

; 358  : 		return ((_Elem *)::memcpy(_First1, _First2, _Count));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First2$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First1$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 359  : 		}

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::copy
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xstring
_TEXT	ENDS
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr, COMDAT
; _this$ = ecx

; 1536 : 		{	// determine current pointer to buffer for nonmutable string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1537 : 		return (_BUF_SIZE <= _Myres ? _Bx._Ptr : _Bx._Buf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24], 16			; 00000010H
	jb	SHORT $L13774
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv70[ebp], edx
	jmp	SHORT $L13775
$L13774:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	mov	DWORD PTR tv70[ebp], eax
$L13775:
	mov	eax, DWORD PTR tv70[ebp]

; 1538 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
_TEXT	ENDS
PUBLIC	??_C@_02EAOCLKAK@ld?$AA@			; `string'
PUBLIC	?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADPBDH@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ifmt
PUBLIC	?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput
EXTRN	_sprintf:NEAR
;	COMDAT ??_C@_02EAOCLKAK@ld?$AA@
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xlocnum
CONST	SEGMENT
??_C@_02EAOCLKAK@ld?$AA@ DB 'ld', 00H			; `string'
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DJ@Z
_TEXT	SEGMENT
__Fmt$ = -92						; size = 6
__Buf$ = -76						; size = 64
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 1
__Val$ = 28						; size = 4
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DJ@Z PROC NEAR ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT
; _this$ = ecx

; 910  : 		{	// put formatted long to _Dest

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-96]
	mov	ecx, 24					; 00000018H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 911  : 		char _Buf[2 * _MAX_INT_DIG], _Fmt[6];
; 912  : 		return (_Iput(_Dest, _Iosbase, _Fill, _Buf,
; 913  : 			::sprintf(_Buf, _Ifmt(_Fmt, "ld",
; 914  : 				_Iosbase.flags()), _Val)));

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?flags@ios_base@std@@QBEHXZ		; std::ios_base::flags
	push	eax
	push	OFFSET FLAT:??_C@_02EAOCLKAK@ld?$AA@
	lea	ecx, DWORD PTR __Fmt$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADPBDH@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ifmt
	add	esp, 16					; 00000010H
	push	eax
	lea	eax, DWORD PTR __Buf$[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH
	push	eax
	lea	ecx, DWORD PTR __Buf$[ebp]
	push	ecx
	mov	dl, BYTE PTR __Fill$[ebp]
	push	edx
	mov	eax, DWORD PTR __Iosbase$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput
	add	esp, 32					; 00000020H
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 915  : 		}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L13783
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	call	@__security_check_cookie@4
	pop	edi
	add	esp, 96					; 00000060H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
$L13783:
	DD	2
	DD	$L13782
$L13782:
	DD	-76					; ffffffb4H
	DD	64					; 00000040H
	DD	$L13779
	DD	-92					; ffffffa4H
	DD	6
	DD	$L13780
$L13780:
	DB	95					; 0000005fH
	DB	70					; 00000046H
	DB	109					; 0000006dH
	DB	116					; 00000074H
	DB	0
$L13779:
	DB	95					; 0000005fH
	DB	66					; 00000042H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	0
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DJ@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
_TEXT	ENDS
PUBLIC	??_C@_02BDDLJJBK@lu?$AA@			; `string'
;	COMDAT ??_C@_02BDDLJJBK@lu?$AA@
CONST	SEGMENT
??_C@_02BDDLJJBK@lu?$AA@ DB 'lu', 00H			; `string'
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DK@Z
_TEXT	SEGMENT
__Fmt$ = -92						; size = 6
__Buf$ = -76						; size = 64
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 1
__Val$ = 28						; size = 4
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DK@Z PROC NEAR ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT
; _this$ = ecx

; 919  : 		{	// put formatted unsigned long to _Dest

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-96]
	mov	ecx, 24					; 00000018H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 920  : 		char _Buf[2 * _MAX_INT_DIG], _Fmt[6];
; 921  : 		return (_Iput(_Dest, _Iosbase, _Fill, _Buf,
; 922  : 			::sprintf(_Buf, _Ifmt(_Fmt, "lu",
; 923  : 				_Iosbase.flags()), _Val)));

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?flags@ios_base@std@@QBEHXZ		; std::ios_base::flags
	push	eax
	push	OFFSET FLAT:??_C@_02BDDLJJBK@lu?$AA@
	lea	ecx, DWORD PTR __Fmt$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADPBDH@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ifmt
	add	esp, 16					; 00000010H
	push	eax
	lea	eax, DWORD PTR __Buf$[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH
	push	eax
	lea	ecx, DWORD PTR __Buf$[ebp]
	push	ecx
	mov	dl, BYTE PTR __Fill$[ebp]
	push	edx
	mov	eax, DWORD PTR __Iosbase$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput
	add	esp, 32					; 00000020H
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 924  : 		}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L13791
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	call	@__security_check_cookie@4
	pop	edi
	add	esp, 96					; 00000060H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
$L13791:
	DD	2
	DD	$L13790
$L13790:
	DD	-76					; ffffffb4H
	DD	64					; 00000040H
	DD	$L13787
	DD	-92					; ffffffa4H
	DD	6
	DD	$L13788
$L13788:
	DB	95					; 0000005fH
	DB	70					; 00000046H
	DB	109					; 0000006dH
	DB	116					; 00000074H
	DB	0
$L13787:
	DB	95					; 0000005fH
	DB	66					; 00000042H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	0
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DK@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
_TEXT	ENDS
PUBLIC	??_C@_02HIKPPMOK@Ld?$AA@			; `string'
;	COMDAT ??_C@_02HIKPPMOK@Ld?$AA@
CONST	SEGMENT
??_C@_02HIKPPMOK@Ld?$AA@ DB 'Ld', 00H			; `string'
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_J@Z
_TEXT	SEGMENT
__Fmt$ = -92						; size = 8
__Buf$ = -76						; size = 64
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 1
__Val$ = 28						; size = 8
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_J@Z PROC NEAR ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT
; _this$ = ecx

; 929  : 		{	// put formatted long long to _Dest

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-96]
	mov	ecx, 24					; 00000018H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 930  : 		char _Buf[2 * _MAX_INT_DIG], _Fmt[8];
; 931  : 		return (_Iput(_Dest, _Iosbase, _Fill, _Buf,
; 932  : 			::sprintf(_Buf, _Ifmt(_Fmt, "Ld",
; 933  : 				_Iosbase.flags()), _Val)));

	mov	eax, DWORD PTR __Val$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?flags@ios_base@std@@QBEHXZ		; std::ios_base::flags
	push	eax
	push	OFFSET FLAT:??_C@_02HIKPPMOK@Ld?$AA@
	lea	edx, DWORD PTR __Fmt$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADPBDH@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ifmt
	add	esp, 16					; 00000010H
	push	eax
	lea	ecx, DWORD PTR __Buf$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 16					; 00000010H
	push	eax
	lea	edx, DWORD PTR __Buf$[ebp]
	push	edx
	mov	al, BYTE PTR __Fill$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput
	add	esp, 32					; 00000020H
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 934  : 		}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L13799
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	call	@__security_check_cookie@4
	pop	edi
	add	esp, 96					; 00000060H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
$L13799:
	DD	2
	DD	$L13798
$L13798:
	DD	-76					; ffffffb4H
	DD	64					; 00000040H
	DD	$L13795
	DD	-92					; ffffffa4H
	DD	8
	DD	$L13796
$L13796:
	DB	95					; 0000005fH
	DB	70					; 00000046H
	DB	109					; 0000006dH
	DB	116					; 00000074H
	DB	0
$L13795:
	DB	95					; 0000005fH
	DB	66					; 00000042H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	0
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_J@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
_TEXT	ENDS
PUBLIC	??_C@_02CLHGNPPK@Lu?$AA@			; `string'
;	COMDAT ??_C@_02CLHGNPPK@Lu?$AA@
CONST	SEGMENT
??_C@_02CLHGNPPK@Lu?$AA@ DB 'Lu', 00H			; `string'
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_K@Z
_TEXT	SEGMENT
__Fmt$ = -92						; size = 8
__Buf$ = -76						; size = 64
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 1
__Val$ = 28						; size = 8
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_K@Z PROC NEAR ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT
; _this$ = ecx

; 938  : 		{	// put formatted unsigned long long to _Dest

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-96]
	mov	ecx, 24					; 00000018H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 939  : 		char _Buf[2 * _MAX_INT_DIG], _Fmt[8];
; 940  : 		return (_Iput(_Dest, _Iosbase, _Fill, _Buf,
; 941  : 			::sprintf(_Buf, _Ifmt(_Fmt, "Lu",
; 942  : 				_Iosbase.flags()), _Val)));

	mov	eax, DWORD PTR __Val$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?flags@ios_base@std@@QBEHXZ		; std::ios_base::flags
	push	eax
	push	OFFSET FLAT:??_C@_02CLHGNPPK@Lu?$AA@
	lea	edx, DWORD PTR __Fmt$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADPBDH@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ifmt
	add	esp, 16					; 00000010H
	push	eax
	lea	ecx, DWORD PTR __Buf$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 16					; 00000010H
	push	eax
	lea	edx, DWORD PTR __Buf$[ebp]
	push	edx
	mov	al, BYTE PTR __Fill$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput
	add	esp, 32					; 00000020H
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 943  : 		}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L13807
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	call	@__security_check_cookie@4
	pop	edi
	add	esp, 96					; 00000060H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
$L13807:
	DD	2
	DD	$L13806
$L13806:
	DD	-76					; ffffffb4H
	DD	64					; 00000040H
	DD	$L13803
	DD	-92					; ffffffa4H
	DD	8
	DD	$L13804
$L13804:
	DB	95					; 0000005fH
	DB	70					; 00000046H
	DB	109					; 0000006dH
	DB	116					; 00000074H
	DB	0
$L13803:
	DB	95					; 0000005fH
	DB	66					; 00000042H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	0
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_K@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
_TEXT	ENDS
PUBLIC	__real@4733426172c74d82
PUBLIC	__real@4202a05f20000000
PUBLIC	__real@38aa95a5b7f87a0f
PUBLIC	?precision@ios_base@std@@QBEHXZ			; std::ios_base::precision
PUBLIC	?_Ffmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADDH@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ffmt
PUBLIC	?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDIIII@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Fput
;	COMDAT __real@4733426172c74d82
CONST	SEGMENT
__real@4733426172c74d82 DQ 04733426172c74d82r	; 1e+035
CONST	ENDS
;	COMDAT __real@4202a05f20000000
CONST	SEGMENT
__real@4202a05f20000000 DQ 04202a05f20000000r	; 1e+010
CONST	ENDS
;	COMDAT __real@38aa95a5b7f87a0f
CONST	SEGMENT
__real@38aa95a5b7f87a0f DQ 038aa95a5b7f87a0fr	; 1e-035
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z
_TEXT	SEGMENT
tv82 = -172						; size = 4
tv75 = -168						; size = 4
tv73 = -164						; size = 4
__Signed$11872 = -157					; size = 1
__Afterpoint$ = -156					; size = 4
__Beforepoint$ = -152					; size = 4
__Significance$ = -148					; size = 4
__Precision$ = -144					; size = 4
__Fmt$ = -136						; size = 8
__Buf$ = -120						; size = 108
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 1
__Val$ = 28						; size = 8
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z PROC NEAR ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT
; _this$ = ecx

; 948  : 		{	// put formatted double to _Dest

	push	ebp
	mov	ebp, esp
	sub	esp, 172				; 000000acH
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-172]
	mov	ecx, 43					; 0000002bH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 949  : 		char _Buf[_MAX_EXP_DIG + _MAX_SIG_DIG + 64], _Fmt[8];
; 950  : 		streamsize _Precision = _Iosbase.precision() <= 0
; 951  : 			&& !(_Iosbase.flags() & ios_base::fixed)
; 952  : 				? 6 : _Iosbase.precision();	// desired precision

	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?precision@ios_base@std@@QBEHXZ		; std::ios_base::precision
	test	eax, eax
	jg	SHORT $L13811
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?flags@ios_base@std@@QBEHXZ		; std::ios_base::flags
	and	eax, 8192				; 00002000H
	jne	SHORT $L13811
	mov	DWORD PTR tv73[ebp], 6
	jmp	SHORT $L13812
$L13811:
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?precision@ios_base@std@@QBEHXZ		; std::ios_base::precision
	mov	DWORD PTR tv73[ebp], eax
$L13812:
	mov	eax, DWORD PTR tv73[ebp]
	mov	DWORD PTR __Precision$[ebp], eax

; 953  : 		int _Significance = _MAX_SIG_DIG < _Precision
; 954  : 			? _MAX_SIG_DIG : (int)_Precision;	// actual sprintf precision

	cmp	DWORD PTR __Precision$[ebp], 36		; 00000024H
	jle	SHORT $L13813
	mov	DWORD PTR tv75[ebp], 36			; 00000024H
	jmp	SHORT $L13814
$L13813:
	mov	ecx, DWORD PTR __Precision$[ebp]
	mov	DWORD PTR tv75[ebp], ecx
$L13814:
	mov	edx, DWORD PTR tv75[ebp]
	mov	DWORD PTR __Significance$[ebp], edx

; 955  : 		_Precision -= _Significance;

	mov	eax, DWORD PTR __Precision$[ebp]
	sub	eax, DWORD PTR __Significance$[ebp]
	mov	DWORD PTR __Precision$[ebp], eax

; 956  : 		size_t _Beforepoint = 0;	// zeros to add before decimal point

	mov	DWORD PTR __Beforepoint$[ebp], 0

; 957  : 		size_t _Afterpoint = 0;	// zeros to add after decimal point

	mov	DWORD PTR __Afterpoint$[ebp], 0

; 958  : 
; 959  : 		if ((_Iosbase.flags() & ios_base::floatfield) == ios_base::fixed)

	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?flags@ios_base@std@@QBEHXZ		; std::ios_base::flags
	and	eax, 12288				; 00003000H
	cmp	eax, 8192				; 00002000H
	jne	$L11871

; 960  : 			{	// scale silly fixed-point value
; 961  : 			bool _Signed = _Val < 0;

	fld	QWORD PTR __Val$[ebp]
	fcomp	QWORD PTR __real@0000000000000000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L13815
	mov	DWORD PTR tv82[ebp], 1
	jmp	SHORT $L13816
$L13815:
	mov	DWORD PTR tv82[ebp], 0
$L13816:
	mov	cl, BYTE PTR tv82[ebp]
	mov	BYTE PTR __Signed$11872[ebp], cl

; 962  : 			if (_Signed)

	movzx	edx, BYTE PTR __Signed$11872[ebp]
	test	edx, edx
	je	SHORT $L11873

; 963  : 				_Val = -_Val;

	fld	QWORD PTR __Val$[ebp]
	fchs
	fstp	QWORD PTR __Val$[ebp]
$L11873:

; 964  : 
; 965  : 			for (; 1e35 <= _Val && _Beforepoint < 5000; _Beforepoint += 10)

	jmp	SHORT $L11874
$L11875:
	mov	eax, DWORD PTR __Beforepoint$[ebp]
	add	eax, 10					; 0000000aH
	mov	DWORD PTR __Beforepoint$[ebp], eax
$L11874:
	fld	QWORD PTR __real@4733426172c74d82
	fcomp	QWORD PTR __Val$[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jp	SHORT $L11876
	cmp	DWORD PTR __Beforepoint$[ebp], 5000	; 00001388H
	jae	SHORT $L11876

; 966  : 				_Val /= 1e10;	// drop 10 zeros before decimal point

	fld	QWORD PTR __Val$[ebp]
	fdiv	QWORD PTR __real@4202a05f20000000
	fstp	QWORD PTR __Val$[ebp]
	jmp	SHORT $L11875
$L11876:

; 967  : 
; 968  : 			if (0 < _Val)

	fld	QWORD PTR __real@0000000000000000
	fcomp	QWORD PTR __Val$[ebp]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L11877

; 969  : 				for (; 10 <= _Precision && _Val <= 1e-35
; 970  : 					&& _Afterpoint < 5000; _Afterpoint += 10)

	jmp	SHORT $L11878
$L11879:
	mov	ecx, DWORD PTR __Afterpoint$[ebp]
	add	ecx, 10					; 0000000aH
	mov	DWORD PTR __Afterpoint$[ebp], ecx
$L11878:
	cmp	DWORD PTR __Precision$[ebp], 10		; 0000000aH
	jl	SHORT $L11877
	fld	QWORD PTR __Val$[ebp]
	fcomp	QWORD PTR __real@38aa95a5b7f87a0f
	fnstsw	ax
	test	ah, 65					; 00000041H
	jp	SHORT $L11877
	cmp	DWORD PTR __Afterpoint$[ebp], 5000	; 00001388H
	jae	SHORT $L11877

; 971  : 					{	// drop 10 zeros after decimal point
; 972  : 					_Val *= 1e10;

	fld	QWORD PTR __Val$[ebp]
	fmul	QWORD PTR __real@4202a05f20000000
	fstp	QWORD PTR __Val$[ebp]

; 973  : 					_Precision -= 10;

	mov	edx, DWORD PTR __Precision$[ebp]
	sub	edx, 10					; 0000000aH
	mov	DWORD PTR __Precision$[ebp], edx

; 974  : 					}

	jmp	SHORT $L11879
$L11877:

; 975  : 
; 976  : 			if (_Signed)

	movzx	eax, BYTE PTR __Signed$11872[ebp]
	test	eax, eax
	je	SHORT $L11871

; 977  : 				_Val = -_Val;

	fld	QWORD PTR __Val$[ebp]
	fchs
	fstp	QWORD PTR __Val$[ebp]
$L11871:

; 978  : 			}
; 979  : 
; 980  : 		return (_Fput(_Dest, _Iosbase, _Fill, _Buf,
; 981  : 			_Beforepoint, _Afterpoint, _Precision,
; 982  : 				::sprintf(_Buf, _Ffmt(_Fmt, 0, _Iosbase.flags()),
; 983  : 					_Significance, _Val)));	// convert and put

	fld	QWORD PTR __Val$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	mov	ecx, DWORD PTR __Significance$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?flags@ios_base@std@@QBEHXZ		; std::ios_base::flags
	push	eax
	push	0
	lea	edx, DWORD PTR __Fmt$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?_Ffmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADDH@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ffmt
	add	esp, 16					; 00000010H
	push	eax
	lea	ecx, DWORD PTR __Buf$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 20					; 00000014H
	push	eax
	mov	edx, DWORD PTR __Precision$[ebp]
	push	edx
	mov	eax, DWORD PTR __Afterpoint$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Beforepoint$[ebp]
	push	ecx
	lea	edx, DWORD PTR __Buf$[ebp]
	push	edx
	mov	al, BYTE PTR __Fill$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDIIII@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Fput
	add	esp, 44					; 0000002cH
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 984  : 		}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L13827
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	call	@__security_check_cookie@4
	pop	edi
	add	esp, 172				; 000000acH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
$L13827:
	DD	2
	DD	$L13826
$L13826:
	DD	-120					; ffffff88H
	DD	108					; 0000006cH
	DD	$L13823
	DD	-136					; ffffff78H
	DD	8
	DD	$L13824
$L13824:
	DB	95					; 0000005fH
	DB	70					; 00000046H
	DB	109					; 0000006dH
	DB	116					; 00000074H
	DB	0
$L13823:
	DB	95					; 0000005fH
	DB	66					; 00000042H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	0
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xiosbase
_TEXT	ENDS
;	COMDAT ?precision@ios_base@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?precision@ios_base@std@@QBEHXZ PROC NEAR		; std::ios_base::precision, COMDAT
; _this$ = ecx

; 357  : 		{	// return precision

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 358  : 		return (_Prec);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+20]

; 359  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?precision@ios_base@std@@QBEHXZ ENDP			; std::ios_base::precision
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xlocnum
_TEXT	ENDS
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z
_TEXT	SEGMENT
tv82 = -172						; size = 4
tv75 = -168						; size = 4
tv73 = -164						; size = 4
__Signed$11894 = -157					; size = 1
__Afterpoint$ = -156					; size = 4
__Beforepoint$ = -152					; size = 4
__Significance$ = -148					; size = 4
__Precision$ = -144					; size = 4
__Fmt$ = -136						; size = 8
__Buf$ = -120						; size = 108
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 1
__Val$ = 28						; size = 8
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z PROC NEAR ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT
; _this$ = ecx

; 988  : 		{	// put formatted long double to _Dest

	push	ebp
	mov	ebp, esp
	sub	esp, 172				; 000000acH
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-172]
	mov	ecx, 43					; 0000002bH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 989  : 		char _Buf[_MAX_EXP_DIG + _MAX_SIG_DIG + 64], _Fmt[8];
; 990  : 		streamsize _Precision = _Iosbase.precision() <= 0
; 991  : 			&& !(_Iosbase.flags() & ios_base::fixed)
; 992  : 				? 6 : _Iosbase.precision();	// desired precision

	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?precision@ios_base@std@@QBEHXZ		; std::ios_base::precision
	test	eax, eax
	jg	SHORT $L13833
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?flags@ios_base@std@@QBEHXZ		; std::ios_base::flags
	and	eax, 8192				; 00002000H
	jne	SHORT $L13833
	mov	DWORD PTR tv73[ebp], 6
	jmp	SHORT $L13834
$L13833:
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?precision@ios_base@std@@QBEHXZ		; std::ios_base::precision
	mov	DWORD PTR tv73[ebp], eax
$L13834:
	mov	eax, DWORD PTR tv73[ebp]
	mov	DWORD PTR __Precision$[ebp], eax

; 993  : 		int _Significance = _MAX_SIG_DIG < _Precision
; 994  : 			? _MAX_SIG_DIG : (int)_Precision;	// actual sprintf precision

	cmp	DWORD PTR __Precision$[ebp], 36		; 00000024H
	jle	SHORT $L13835
	mov	DWORD PTR tv75[ebp], 36			; 00000024H
	jmp	SHORT $L13836
$L13835:
	mov	ecx, DWORD PTR __Precision$[ebp]
	mov	DWORD PTR tv75[ebp], ecx
$L13836:
	mov	edx, DWORD PTR tv75[ebp]
	mov	DWORD PTR __Significance$[ebp], edx

; 995  : 		_Precision -= _Significance;

	mov	eax, DWORD PTR __Precision$[ebp]
	sub	eax, DWORD PTR __Significance$[ebp]
	mov	DWORD PTR __Precision$[ebp], eax

; 996  : 		size_t _Beforepoint = 0;	// zeros to add before decimal point

	mov	DWORD PTR __Beforepoint$[ebp], 0

; 997  : 		size_t _Afterpoint = 0;	// zeros to add after decimal point

	mov	DWORD PTR __Afterpoint$[ebp], 0

; 998  : 
; 999  : 		if ((_Iosbase.flags() & ios_base::floatfield) == ios_base::fixed)

	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?flags@ios_base@std@@QBEHXZ		; std::ios_base::flags
	and	eax, 12288				; 00003000H
	cmp	eax, 8192				; 00002000H
	jne	$L11893

; 1000 : 			{	// scale silly fixed-point value
; 1001 : 			bool _Signed = _Val < 0;

	fld	QWORD PTR __Val$[ebp]
	fcomp	QWORD PTR __real@0000000000000000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L13837
	mov	DWORD PTR tv82[ebp], 1
	jmp	SHORT $L13838
$L13837:
	mov	DWORD PTR tv82[ebp], 0
$L13838:
	mov	cl, BYTE PTR tv82[ebp]
	mov	BYTE PTR __Signed$11894[ebp], cl

; 1002 : 			if (_Signed)

	movzx	edx, BYTE PTR __Signed$11894[ebp]
	test	edx, edx
	je	SHORT $L11895

; 1003 : 				_Val = -_Val;

	fld	QWORD PTR __Val$[ebp]
	fchs
	fstp	QWORD PTR __Val$[ebp]
$L11895:

; 1004 : 
; 1005 : 			for (; 1e35 <= _Val && _Beforepoint < 5000; _Beforepoint += 10)

	jmp	SHORT $L11896
$L11897:
	mov	eax, DWORD PTR __Beforepoint$[ebp]
	add	eax, 10					; 0000000aH
	mov	DWORD PTR __Beforepoint$[ebp], eax
$L11896:
	fld	QWORD PTR __real@4733426172c74d82
	fcomp	QWORD PTR __Val$[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jp	SHORT $L11898
	cmp	DWORD PTR __Beforepoint$[ebp], 5000	; 00001388H
	jae	SHORT $L11898

; 1006 : 				_Val /= 1e10;	// drop 10 zeros before decimal point

	fld	QWORD PTR __Val$[ebp]
	fdiv	QWORD PTR __real@4202a05f20000000
	fstp	QWORD PTR __Val$[ebp]
	jmp	SHORT $L11897
$L11898:

; 1007 : 
; 1008 : 			if (0 < _Val)

	fld	QWORD PTR __real@0000000000000000
	fcomp	QWORD PTR __Val$[ebp]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $L11899

; 1009 : 				for (; 10 <= _Precision && _Val <= 1e-35
; 1010 : 					&& _Afterpoint < 5000; _Afterpoint += 10)

	jmp	SHORT $L11900
$L11901:
	mov	ecx, DWORD PTR __Afterpoint$[ebp]
	add	ecx, 10					; 0000000aH
	mov	DWORD PTR __Afterpoint$[ebp], ecx
$L11900:
	cmp	DWORD PTR __Precision$[ebp], 10		; 0000000aH
	jl	SHORT $L11899
	fld	QWORD PTR __Val$[ebp]
	fcomp	QWORD PTR __real@38aa95a5b7f87a0f
	fnstsw	ax
	test	ah, 65					; 00000041H
	jp	SHORT $L11899
	cmp	DWORD PTR __Afterpoint$[ebp], 5000	; 00001388H
	jae	SHORT $L11899

; 1011 : 					{	// drop 10 zeros after decimal point
; 1012 : 					_Val *= 1e10;

	fld	QWORD PTR __Val$[ebp]
	fmul	QWORD PTR __real@4202a05f20000000
	fstp	QWORD PTR __Val$[ebp]

; 1013 : 					_Precision -= 10;

	mov	edx, DWORD PTR __Precision$[ebp]
	sub	edx, 10					; 0000000aH
	mov	DWORD PTR __Precision$[ebp], edx

; 1014 : 					}

	jmp	SHORT $L11901
$L11899:

; 1015 : 
; 1016 : 			if (_Signed)

	movzx	eax, BYTE PTR __Signed$11894[ebp]
	test	eax, eax
	je	SHORT $L11893

; 1017 : 				_Val = -_Val;

	fld	QWORD PTR __Val$[ebp]
	fchs
	fstp	QWORD PTR __Val$[ebp]
$L11893:

; 1018 : 			}
; 1019 : 
; 1020 : 		return (_Fput(_Dest, _Iosbase, _Fill, _Buf,
; 1021 : 			_Beforepoint, _Afterpoint, _Precision,
; 1022 : 				::sprintf(_Buf, _Ffmt(_Fmt, 'L', _Iosbase.flags()),
; 1023 : 					_Significance, _Val)));	// convert and put

	fld	QWORD PTR __Val$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	mov	ecx, DWORD PTR __Significance$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?flags@ios_base@std@@QBEHXZ		; std::ios_base::flags
	push	eax
	push	76					; 0000004cH
	lea	edx, DWORD PTR __Fmt$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?_Ffmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADDH@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ffmt
	add	esp, 16					; 00000010H
	push	eax
	lea	ecx, DWORD PTR __Buf$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 20					; 00000014H
	push	eax
	mov	edx, DWORD PTR __Precision$[ebp]
	push	edx
	mov	eax, DWORD PTR __Afterpoint$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Beforepoint$[ebp]
	push	ecx
	lea	edx, DWORD PTR __Buf$[ebp]
	push	edx
	mov	al, BYTE PTR __Fill$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDIIII@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Fput
	add	esp, 44					; 0000002cH
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1024 : 		}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L13843
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	call	@__security_check_cookie@4
	pop	edi
	add	esp, 172				; 000000acH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
$L13843:
	DD	2
	DD	$L13842
$L13842:
	DD	-120					; ffffff88H
	DD	108					; 0000006cH
	DD	$L13839
	DD	-136					; ffffff78H
	DD	8
	DD	$L13840
$L13840:
	DB	95					; 0000005fH
	DB	70					; 00000046H
	DB	109					; 0000006dH
	DB	116					; 00000074H
	DB	0
$L13839:
	DB	95					; 0000005fH
	DB	66					; 00000042H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	0
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
_TEXT	ENDS
PUBLIC	??_C@_02BBAHNLBA@?$CFp?$AA@			; `string'
;	COMDAT ??_C@_02BBAHNLBA@?$CFp?$AA@
CONST	SEGMENT
??_C@_02BBAHNLBA@?$CFp?$AA@ DB '%p', 00H		; `string'
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBX@Z
_TEXT	SEGMENT
__Buf$ = -76						; size = 64
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 1
__Val$ = 28						; size = 4
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBX@Z PROC NEAR ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT
; _this$ = ecx

; 1028 : 		{	// put formatted void pointer to _Dest

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-80]
	mov	ecx, 20					; 00000014H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 1029 : 		char _Buf[2 * _MAX_INT_DIG];
; 1030 : 		return (_Iput(_Dest, _Iosbase, _Fill, _Buf,
; 1031 : 			::sprintf(_Buf, "%p", _Val)));

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_02BBAHNLBA@?$CFp?$AA@
	lea	ecx, DWORD PTR __Buf$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH
	push	eax
	lea	edx, DWORD PTR __Buf$[ebp]
	push	edx
	mov	al, BYTE PTR __Fill$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput
	add	esp, 32					; 00000020H
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1032 : 		}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L13850
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	call	@__security_check_cookie@4
	pop	edi
	add	esp, 80					; 00000050H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
$L13850:
	DD	1
	DD	$L13849
$L13849:
	DD	-76					; ffffffb4H
	DD	64					; 00000040H
	DD	$L13847
$L13847:
	DB	95					; 0000005fH
	DB	66					; 00000042H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	0
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBX@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
_TEXT	ENDS
PUBLIC	??1?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAE@XZ ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::~num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >
; Function compile flags: /Odt /RTCsu
;	COMDAT ??_G?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z PROC NEAR ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAE@XZ ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::~num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $L11918
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L11918:
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_G?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`scalar deleting destructor'
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??1?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAE@XZ PROC NEAR ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::~num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >, COMDAT
; _this$ = ecx

; 801  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@

; 802  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1facet@locale@std@@UAE@XZ		; std::locale::facet::~facet
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAE@XZ ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::~num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >
_TEXT	ENDS
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
PUBLIC	??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 311  : 		{	// construct empty string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >

; 312  : 		_Tidy();

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 313  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
PUBLIC	??0?$allocator@D@std@@QAE@ABV01@@Z		; std::allocator<char>::allocator<char>
; Function compile flags: /Odt /RTCsu
;	COMDAT ??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Al$ = 8						; size = 1
??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z PROC NEAR ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >, COMDAT
; _this$ = ecx

; 34   : 		{	// construct allocator from _Al

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$allocator@D@std@@QAE@ABV01@@Z	; std::allocator<char>::allocator<char>

; 35   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z ENDP ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@D@std@@QAE@XZ PROC NEAR			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 111  : 	allocator()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 112  : 		{	// construct default allocator (do nothing)
; 113  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@D@std@@QAE@ABV01@@Z PROC NEAR		; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 115  : 	allocator(const allocator<_Ty>&)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 116  : 		{	// construct by copying (do nothing)
; 117  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$allocator@D@std@@QAE@ABV01@@Z ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
PUBLIC	?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::npos
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
;	COMDAT ?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xstring
CONST	SEGMENT
?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB DD 0ffffffffH ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::npos
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 584  : 		{	// assign _Right

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 585  : 		return (assign(_Right, 0, npos));

	mov	eax, DWORD PTR ?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::npos
	push	eax
	push	0
	mov	ecx, DWORD PTR __Right$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 586  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
PUBLIC	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
PUBLIC	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
EXTRN	?_Xran@_String_base@std@@QBEXXZ:NEAR		; std::_String_base::_Xran
; Function compile flags: /Odt /RTCsu
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Num$ = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 590  : 		{	// assign _Right [_Roff, _Roff + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 591  : 		if (_Right.size() < _Roff)

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	cmp	eax, DWORD PTR __Roff$[ebp]
	jae	SHORT $L11395

; 592  : 			_String_base::_Xran();	// _Roff off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@_String_base@std@@QBEXXZ		; std::_String_base::_Xran
$L11395:

; 593  : 		size_type _Num = _Right.size() - _Roff;

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	sub	eax, DWORD PTR __Roff$[ebp]
	mov	DWORD PTR __Num$[ebp], eax

; 594  : 		if (_Count < _Num)

	mov	eax, DWORD PTR __Count$[ebp]
	cmp	eax, DWORD PTR __Num$[ebp]
	jae	SHORT $L11397

; 595  : 			_Num = _Count;	// trim _Num to size

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Num$[ebp], ecx
$L11397:

; 596  : 
; 597  : 		if (this == &_Right)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	edx, DWORD PTR __Right$[ebp]
	jne	SHORT $L11398

; 598  : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring

	mov	eax, DWORD PTR ?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::npos
	push	eax
	mov	ecx, DWORD PTR __Roff$[ebp]
	add	ecx, DWORD PTR __Num$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	mov	edx, DWORD PTR __Roff$[ebp]
	push	edx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase

; 599  : 		else if (_Grow(_Num))

	jmp	SHORT $L11516
$L11398:
	push	0
	mov	eax, DWORD PTR __Num$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $L11516

; 600  : 			{	// make room and assign new stuff
; 601  : 			_Traits::copy(_Myptr(), _Right._Myptr() + _Roff, _Num);

	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	add	eax, DWORD PTR __Roff$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 602  : 			_Eos(_Num);

	mov	eax, DWORD PTR __Num$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$L11516:

; 603  : 			}
; 604  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 605  : 		}

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
PUBLIC	?move@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::move
; Function compile flags: /Odt /RTCsu
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
__Newsize$11933 = -8					; size = 4
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 792  : 		{	// erase elements [_Off, _Off + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 793  : 		if (_Mysize < _Off)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $L11930

; 794  : 			_String_base::_Xran();	// _Off off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@_String_base@std@@QBEXXZ		; std::_String_base::_Xran
$L11930:

; 795  : 		if (_Mysize - _Off < _Count)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	sub	eax, DWORD PTR __Off$[ebp]
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	SHORT $L11931

; 796  : 			_Count = _Mysize - _Off;	// trim _Count

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	sub	edx, DWORD PTR __Off$[ebp]
	mov	DWORD PTR __Count$[ebp], edx
$L11931:

; 797  : 		if (0 < _Count)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $L11932

; 798  : 			{	// move elements down
; 799  : 			_Traits::move(_Myptr() + _Off, _Myptr() + _Off + _Count,
; 800  : 				_Mysize - _Off - _Count);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	sub	ecx, DWORD PTR __Off$[ebp]
	sub	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	add	eax, DWORD PTR __Off$[ebp]
	add	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	add	eax, DWORD PTR __Off$[ebp]
	push	eax
	call	?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move
	add	esp, 12					; 0000000cH

; 801  : 			size_type _Newsize = _Mysize - _Count;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	sub	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Newsize$11933[ebp], eax

; 802  : 			_Eos(_Newsize);

	mov	ecx, DWORD PTR __Newsize$11933[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$L11932:

; 803  : 			}
; 804  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 805  : 		}

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
EXTRN	_memmove:NEAR
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\iosfwd
;	COMDAT ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$char_traits@D@std@@SAPADPADPBDI@Z PROC NEAR	; std::char_traits<char>::move, COMDAT

; 369  : 		{	// copy [_First1, _First1 + _Count) to [_First2, ...)

	push	ebp
	mov	ebp, esp

; 370  : 		return ((_Elem *)::memmove(_First1, _First2, _Count));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First2$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First1$[ebp]
	push	edx
	call	_memmove
	add	esp, 12					; 0000000cH

; 371  : 		}

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
?move@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::move
_TEXT	ENDS
PUBLIC	?assign@?$char_traits@D@std@@SAXAADABD@Z	; std::char_traits<char>::assign
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z
_TEXT	SEGMENT
$T13875 = -5						; size = 1
_this$ = -4						; size = 4
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 1474 : 		{	// set new length and null terminator

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1475 : 		_Traits::assign(_Myptr()[_Mysize = _Newsize], _Elem());

	mov	BYTE PTR $T13875[ebp], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR [eax+20], ecx
	lea	edx, DWORD PTR $T13875[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	add	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	call	?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign
	add	esp, 8

; 1476 : 		}

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\iosfwd
_TEXT	ENDS
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC NEAR	; std::char_traits<char>::assign, COMDAT

; 330  : 		{	// assign an element

	push	ebp
	mov	ebp, esp

; 331  : 		_Left = _Right;

	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 332  : 		}

	pop	ebp
	ret	0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
EXTRN	?_Xlen@_String_base@std@@QBEXXZ:NEAR		; std::_String_base::_Xlen
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z
_TEXT	SEGMENT
tv81 = -8						; size = 4
_this$ = -4						; size = 4
__Newsize$ = 8						; size = 4
__Trim$ = 12						; size = 1
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow, COMDAT
; _this$ = ecx

; 1480 : 		{	// ensure buffer is big enough, trim to size if _Trim is true

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1481 : 		if (max_size() < _Newsize)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	eax, DWORD PTR __Newsize$[ebp]
	jae	SHORT $L11939

; 1482 : 			_String_base::_Xlen();	// result too long

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xlen@_String_base@std@@QBEXXZ		; std::_String_base::_Xlen
$L11939:

; 1483 : 		if (_Myres < _Newsize)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	cmp	ecx, DWORD PTR __Newsize$[ebp]
	jae	SHORT $L11940

; 1484 : 			_Copy(_Newsize, _Mysize);	// reallocate to grow

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	mov	ecx, DWORD PTR __Newsize$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy

; 1485 : 		else if (_Trim && _Newsize < _BUF_SIZE)

	jmp	SHORT $L11941
$L11940:
	movzx	edx, BYTE PTR __Trim$[ebp]
	test	edx, edx
	je	SHORT $L11942
	cmp	DWORD PTR __Newsize$[ebp], 16		; 00000010H
	jae	SHORT $L11942

; 1486 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 1487 : 				_Newsize < _Mysize ? _Newsize : _Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	cmp	ecx, DWORD PTR [eax+20]
	jae	SHORT $L13880
	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR tv81[ebp], edx
	jmp	SHORT $L13881
$L13880:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR tv81[ebp], ecx
$L13881:
	mov	edx, DWORD PTR tv81[ebp]
	push	edx
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 1488 : 		else if (_Newsize == 0)

	jmp	SHORT $L11941
$L11942:
	cmp	DWORD PTR __Newsize$[ebp], 0
	jne	SHORT $L11941

; 1489 : 			_Eos(0);	// new size is zero, just null terminate

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$L11941:

; 1490 : 		return (0 < _Newsize);	// return true only if more work to do

	xor	eax, eax
	cmp	eax, DWORD PTR __Newsize$[ebp]
	sbb	eax, eax
	neg	eax

; 1491 : 		}

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr, COMDAT
; _this$ = ecx

; 1531 : 		{	// determine current pointer to buffer for mutable string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1532 : 		return (_BUF_SIZE <= _Myres ? _Bx._Ptr : _Bx._Buf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24], 16			; 00000010H
	jb	SHORT $L13884
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv70[ebp], edx
	jmp	SHORT $L13885
$L13884:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	mov	DWORD PTR tv70[ebp], eax
$L13885:
	mov	eax, DWORD PTR tv70[ebp]

; 1533 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXPADI@Z PROC NEAR	; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 131  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 132  : 		operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 133  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@D@std@@QAEXPADI@Z ENDP		; std::allocator<char>::deallocate
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xlocnum
_TEXT	ENDS
;	COMDAT ?_Ffmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADDH@Z
_TEXT	SEGMENT
tv81 = -9						; size = 1
__Ffl$ = -8						; size = 4
__Ptr$ = -4						; size = 4
_this$ = 8						; size = 4
__Fmt$ = 12						; size = 4
__Spec$ = 16						; size = 1
__Flags$ = 20						; size = 4
?_Ffmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADDH@Z PROC NEAR ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ffmt, COMDAT

; 1037 : 		{	// generate sprintf format for floating-point

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 1038 : 		char *_Ptr = _Fmt;

	mov	eax, DWORD PTR __Fmt$[ebp]
	mov	DWORD PTR __Ptr$[ebp], eax

; 1039 : 		*_Ptr++ = '%';

	mov	ecx, DWORD PTR __Ptr$[ebp]
	mov	BYTE PTR [ecx], 37			; 00000025H
	mov	edx, DWORD PTR __Ptr$[ebp]
	add	edx, 1
	mov	DWORD PTR __Ptr$[ebp], edx

; 1040 : 
; 1041 : 		if (_Flags & ios_base::showpos)

	mov	eax, DWORD PTR __Flags$[ebp]
	and	eax, 32					; 00000020H
	je	SHORT $L12001

; 1042 : 			*_Ptr++ = '+';

	mov	ecx, DWORD PTR __Ptr$[ebp]
	mov	BYTE PTR [ecx], 43			; 0000002bH
	mov	edx, DWORD PTR __Ptr$[ebp]
	add	edx, 1
	mov	DWORD PTR __Ptr$[ebp], edx
$L12001:

; 1043 : 		if (_Flags & ios_base::showpoint)

	mov	eax, DWORD PTR __Flags$[ebp]
	and	eax, 16					; 00000010H
	je	SHORT $L12002

; 1044 : 			*_Ptr++ = '#';

	mov	ecx, DWORD PTR __Ptr$[ebp]
	mov	BYTE PTR [ecx], 35			; 00000023H
	mov	edx, DWORD PTR __Ptr$[ebp]
	add	edx, 1
	mov	DWORD PTR __Ptr$[ebp], edx
$L12002:

; 1045 : 		*_Ptr++ = '.';

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	BYTE PTR [eax], 46			; 0000002eH
	mov	ecx, DWORD PTR __Ptr$[ebp]
	add	ecx, 1
	mov	DWORD PTR __Ptr$[ebp], ecx

; 1046 : 		*_Ptr++ = '*';	// for precision argument

	mov	edx, DWORD PTR __Ptr$[ebp]
	mov	BYTE PTR [edx], 42			; 0000002aH
	mov	eax, DWORD PTR __Ptr$[ebp]
	add	eax, 1
	mov	DWORD PTR __Ptr$[ebp], eax

; 1047 : 		if (_Spec != '\0')

	movsx	ecx, BYTE PTR __Spec$[ebp]
	test	ecx, ecx
	je	SHORT $L12003

; 1048 : 			*_Ptr++ = _Spec;	// 'L' qualifier for long double only

	mov	edx, DWORD PTR __Ptr$[ebp]
	mov	al, BYTE PTR __Spec$[ebp]
	mov	BYTE PTR [edx], al
	mov	ecx, DWORD PTR __Ptr$[ebp]
	add	ecx, 1
	mov	DWORD PTR __Ptr$[ebp], ecx
$L12003:

; 1049 : 
; 1050 : 		ios_base::fmtflags _Ffl = _Flags & ios_base::floatfield;

	mov	edx, DWORD PTR __Flags$[ebp]
	and	edx, 12288				; 00003000H
	mov	DWORD PTR __Ffl$[ebp], edx

; 1051 : 		*_Ptr++ = _Ffl == ios_base::fixed ? 'f'
; 1052 : 			: _Ffl == ios_base::scientific ? 'e' : 'g';	// specifier

	cmp	DWORD PTR __Ffl$[ebp], 8192		; 00002000H
	jne	SHORT $L13890
	mov	BYTE PTR tv81[ebp], 102			; 00000066H
	jmp	SHORT $L13891
$L13890:
	cmp	DWORD PTR __Ffl$[ebp], 4096		; 00001000H
	setne	al
	lea	eax, DWORD PTR [eax+eax+101]
	mov	BYTE PTR tv81[ebp], al
$L13891:
	mov	ecx, DWORD PTR __Ptr$[ebp]
	mov	dl, BYTE PTR tv81[ebp]
	mov	BYTE PTR [ecx], dl
	mov	eax, DWORD PTR __Ptr$[ebp]
	add	eax, 1
	mov	DWORD PTR __Ptr$[ebp], eax

; 1053 : 		*_Ptr = '\0';

	mov	ecx, DWORD PTR __Ptr$[ebp]
	mov	BYTE PTR [ecx], 0

; 1054 : 		return (_Fmt);

	mov	eax, DWORD PTR __Fmt$[ebp]

; 1055 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Ffmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADDH@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ffmt
_TEXT	ENDS
PUBLIC	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
PUBLIC	?decimal_point@?$numpunct@D@std@@QBEDXZ		; std::numpunct<char>::decimal_point
PUBLIC	?thousands_sep@?$numpunct@D@std@@QBEDXZ		; std::numpunct<char>::thousands_sep
PUBLIC	?grouping@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::grouping
PUBLIC	??$_Maklocchr@D@std@@YADDPADABU_Cvtvec@@@Z	; std::_Maklocchr<char>
PUBLIC	??_C@_01DDCIFGEA@E?$AA@				; `string'
PUBLIC	??_C@_01KGKMHCOC@e?$AA@				; `string'
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
PUBLIC	?_Putc@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Putc
PUBLIC	?_Putgrouped@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDID@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Putgrouped
EXTRN	_memchr:NEAR
EXTRN	_strcspn:NEAR
EXTRN	_localeconv:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T13926	DD	0ffffffffH
	DD	FLAT:$L13914
	DD	0ffffffffH
	DD	FLAT:$L13915
	DD	01H
	DD	FLAT:$L13916
$T13918	DD	019930520H
	DD	03H
	DD	FLAT:$T13926
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_C@_01DDCIFGEA@E?$AA@
CONST	SEGMENT
??_C@_01DDCIFGEA@E?$AA@ DB 'E', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01KGKMHCOC@e?$AA@
CONST	SEGMENT
??_C@_01KGKMHCOC@e?$AA@ DB 'e', 00H			; `string'
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDIIII@Z
_TEXT	SEGMENT
tv347 = -268						; size = 4
tv212 = -264						; size = 4
tv89 = -260						; size = 4
tv377 = -256						; size = 4
tv382 = -252						; size = 4
$T13913 = -248						; size = 8
$T13912 = -240						; size = 8
$T13911 = -232						; size = 8
$T13908 = -224						; size = 8
$T13907 = -216						; size = 8
$T13906 = -208						; size = 8
$T13905 = -200						; size = 8
$T13904 = -192						; size = 8
$T13903 = -184						; size = 8
$T13902 = -176						; size = 8
$T13901 = -168						; size = 8
$T13900 = -160						; size = 8
$T13895 = -152						; size = 4
__Expoffset$12061 = -148				; size = 4
__Fracoffset$12054 = -144				; size = 4
__Ptr$ = -140						; size = 4
__Adjustfield$ = -136					; size = 4
__Fillcount$ = -132					; size = 4
__Off$12033 = -128					; size = 4
__Pg$12032 = -124					; size = 4
__Ptr$12025 = -120					; size = 4
__Enders$ = -112					; size = 3
__Prefix$ = -104					; size = 4
__E0$ = -97						; size = 1
__Groupstring$ = -92					; size = 28
__Kseparator$ = -57					; size = 1
__Grouping$ = -52					; size = 28
__Punct_fac$ = -20					; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
__Dest$ = 16						; size = 8
__Iosbase$ = 24						; size = 4
__Fill$ = 28						; size = 1
__Buf$ = 32						; size = 4
__Beforepoint$ = 36					; size = 4
__Afterpoint$ = 40					; size = 4
__Trailing$ = 44					; size = 4
__Count$ = 48						; size = 4
?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDIIII@Z PROC NEAR ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Fput, COMDAT

; 1061 : 		{	// put formatted floating-point to _Dest

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDIIII@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 256				; 00000100H
	push	edi
	lea	edi, DWORD PTR [ebp-268]
	mov	ecx, 64					; 00000040H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1062 : 		const _Mypunct& _Punct_fac = _USE(_Iosbase.getloc(), _Mypunct);

	lea	eax, DWORD PTR $T13895[ebp]
	push	eax
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?getloc@ios_base@std@@QBE?AVlocale@2@XZ	; std::ios_base::getloc
	mov	DWORD PTR tv382[ebp], eax
	mov	ecx, DWORD PTR tv382[ebp]
	mov	DWORD PTR tv377[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR tv377[ebp]
	push	edx
	call	??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z ; std::use_facet<std::numpunct<char> >
	add	esp, 4
	mov	DWORD PTR __Punct_fac$[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T13895[ebp]
	call	??1locale@std@@QAE@XZ			; std::locale::~locale

; 1063 : 		const string _Grouping = _Punct_fac.grouping();

	lea	eax, DWORD PTR __Grouping$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Punct_fac$[ebp]
	call	?grouping@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::grouping
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 1064 : 		const _Elem _Kseparator = _Punct_fac.thousands_sep();

	mov	ecx, DWORD PTR __Punct_fac$[ebp]
	call	?thousands_sep@?$numpunct@D@std@@QBEDXZ	; std::numpunct<char>::thousands_sep
	mov	BYTE PTR __Kseparator$[ebp], al

; 1065 : 		string _Groupstring;

	lea	ecx, DWORD PTR __Groupstring$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 1066 : 		const _Elem _E0 = _MAKLOCCHR(_Elem, '0', _Cvt);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	push	ecx
	push	0
	push	48					; 00000030H
	call	??$_Maklocchr@D@std@@YADDPADABU_Cvtvec@@@Z ; std::_Maklocchr<char>
	add	esp, 12					; 0000000cH
	mov	BYTE PTR __E0$[ebp], al

; 1067 : 		size_t _Prefix = _Buf[0] == '+' || _Buf[0] == '-' ? 1 : 0;

	mov	edx, DWORD PTR __Buf$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 43					; 0000002bH
	je	SHORT $L13896
	mov	ecx, DWORD PTR __Buf$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 45					; 0000002dH
	je	SHORT $L13896
	mov	DWORD PTR tv89[ebp], 0
	jmp	SHORT $L13897
$L13896:
	mov	DWORD PTR tv89[ebp], 1
$L13897:
	mov	eax, DWORD PTR tv89[ebp]
	mov	DWORD PTR __Prefix$[ebp], eax

; 1068 : 
; 1069 : 		char _Enders[3];
; 1070 : 		_Enders[0] = ::localeconv()->decimal_point[0];

	call	_localeconv
	mov	ecx, DWORD PTR [eax]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR __Enders$[ebp], dl

; 1071 : 		_Enders[1] = 'e';

	mov	BYTE PTR __Enders$[ebp+1], 101		; 00000065H

; 1072 : 		_Enders[2] = '\0';

	mov	BYTE PTR __Enders$[ebp+2], 0

; 1073 : 
; 1074 : 		if (*_Grouping.c_str() != CHAR_MAX && '\0' < *_Grouping.c_str())

	lea	ecx, DWORD PTR __Grouping$[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	movsx	eax, BYTE PTR [eax]
	cmp	eax, 127				; 0000007fH
	je	$L12024
	lea	ecx, DWORD PTR __Grouping$[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jle	$L12024

; 1075 : 			{	// grouping specified, add thousands separators
; 1076 : 			_Groupstring.append(_Buf, _Count);	// assemble field into string

	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Buf$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Groupstring$[ebp]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1077 : 			const char *_Ptr = (const char *)::memchr(_Buf,
; 1078 : 				'e', _Count);	// find exponent

	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	push	101					; 00000065H
	mov	edx, DWORD PTR __Buf$[ebp]
	push	edx
	call	_memchr
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$12025[ebp], eax

; 1079 : 			if (_Ptr == 0)

	cmp	DWORD PTR __Ptr$12025[ebp], 0
	jne	SHORT $L12027

; 1080 : 				_Groupstring.append(_Trailing, '0');

	push	48					; 00000030H
	mov	eax, DWORD PTR __Trailing$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Groupstring$[ebp]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1081 : 			else

	jmp	SHORT $L12028
$L12027:

; 1082 : 				_Groupstring.insert(_Ptr - _Buf, _Trailing, '0');

	push	48					; 00000030H
	mov	ecx, DWORD PTR __Trailing$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Ptr$12025[ebp]
	sub	edx, DWORD PTR __Buf$[ebp]
	push	edx
	lea	ecx, DWORD PTR __Groupstring$[ebp]
	call	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
$L12028:

; 1083 : 
; 1084 : 			_Ptr = (const char *)::memchr(_Buf,
; 1085 : 				_Enders[0], _Count);	// find decimal point

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	movsx	ecx, BYTE PTR __Enders$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Buf$[ebp]
	push	edx
	call	_memchr
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$12025[ebp], eax

; 1086 : 			if (_Ptr == 0)

	cmp	DWORD PTR __Ptr$12025[ebp], 0
	jne	SHORT $L12030

; 1087 : 				_Groupstring.append(_Beforepoint, '0');

	push	48					; 00000030H
	mov	eax, DWORD PTR __Beforepoint$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Groupstring$[ebp]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1088 : 			else

	jmp	SHORT $L12031
$L12030:

; 1089 : 				{	// fill in zeros around decimal point
; 1090 : 				_Groupstring.insert(_Ptr - _Buf + 1, _Afterpoint, '0');

	push	48					; 00000030H
	mov	ecx, DWORD PTR __Afterpoint$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Ptr$12025[ebp]
	sub	edx, DWORD PTR __Buf$[ebp]
	add	edx, 1
	push	edx
	lea	ecx, DWORD PTR __Groupstring$[ebp]
	call	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert

; 1091 : 				_Groupstring.insert(_Ptr - _Buf, _Beforepoint, '0');

	push	48					; 00000030H
	mov	eax, DWORD PTR __Beforepoint$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$12025[ebp]
	sub	ecx, DWORD PTR __Buf$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Groupstring$[ebp]
	call	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
$L12031:

; 1092 : 				}
; 1093 : 
; 1094 : 			const char *_Pg = _Grouping.c_str();

	lea	ecx, DWORD PTR __Grouping$[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	mov	DWORD PTR __Pg$12032[ebp], eax

; 1095 : 			size_t _Off = ::strcspn(&_Groupstring[0], &_Enders[0]);

	lea	edx, DWORD PTR __Enders$[ebp]
	push	edx
	push	0
	lea	ecx, DWORD PTR __Groupstring$[ebp]
	call	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
	push	eax
	call	_strcspn
	add	esp, 8
	mov	DWORD PTR __Off$12033[ebp], eax
$L12035:

; 1096 : 			while (*_Pg != CHAR_MAX && '\0' < *_Pg
; 1097 : 				&& (size_t)*_Pg < _Off - _Prefix)

	mov	eax, DWORD PTR __Pg$12032[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 127				; 0000007fH
	je	SHORT $L12036
	mov	edx, DWORD PTR __Pg$12032[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	jle	SHORT $L12036
	mov	ecx, DWORD PTR __Pg$12032[ebp]
	movsx	edx, BYTE PTR [ecx]
	mov	eax, DWORD PTR __Off$12033[ebp]
	sub	eax, DWORD PTR __Prefix$[ebp]
	cmp	edx, eax
	jae	SHORT $L12036

; 1098 : 				{	// add a comma to mark thousands separator
; 1099 : 				_Groupstring.insert(_Off -= *_Pg, (size_t)1, ',');

	mov	ecx, DWORD PTR __Pg$12032[ebp]
	movsx	edx, BYTE PTR [ecx]
	mov	eax, DWORD PTR __Off$12033[ebp]
	sub	eax, edx
	mov	DWORD PTR __Off$12033[ebp], eax
	push	44					; 0000002cH
	push	1
	mov	ecx, DWORD PTR __Off$12033[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Groupstring$[ebp]
	call	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert

; 1100 : 				if ('\0' < _Pg[1])

	mov	edx, DWORD PTR __Pg$12032[ebp]
	movsx	eax, BYTE PTR [edx+1]
	test	eax, eax
	jle	SHORT $L12039

; 1101 : 					++_Pg;	// not last group, advance

	mov	ecx, DWORD PTR __Pg$12032[ebp]
	add	ecx, 1
	mov	DWORD PTR __Pg$12032[ebp], ecx
$L12039:

; 1102 : 				}

	jmp	SHORT $L12035
$L12036:

; 1103 : 
; 1104 : 			_Buf = &_Groupstring[0];

	push	0
	lea	ecx, DWORD PTR __Groupstring$[ebp]
	call	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
	mov	DWORD PTR __Buf$[ebp], eax

; 1105 : 			_Beforepoint = 0;

	mov	DWORD PTR __Beforepoint$[ebp], 0

; 1106 : 			_Afterpoint = 0;

	mov	DWORD PTR __Afterpoint$[ebp], 0

; 1107 : 			_Trailing = 0;

	mov	DWORD PTR __Trailing$[ebp], 0

; 1108 : 			_Count = _Groupstring.size();

	lea	ecx, DWORD PTR __Groupstring$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	mov	DWORD PTR __Count$[ebp], eax
$L12024:

; 1109 : 			}
; 1110 : 
; 1111 : 		size_t _Fillcount = _Beforepoint + _Afterpoint + _Trailing + _Count;

	mov	edx, DWORD PTR __Beforepoint$[ebp]
	add	edx, DWORD PTR __Afterpoint$[ebp]
	add	edx, DWORD PTR __Trailing$[ebp]
	add	edx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Fillcount$[ebp], edx

; 1112 : 		_Fillcount = _Iosbase.width() <= 0
; 1113 : 			|| (size_t)_Iosbase.width() <= _Fillcount
; 1114 : 				? 0 : (size_t)_Iosbase.width() - _Fillcount;

	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?width@ios_base@std@@QBEHXZ		; std::ios_base::width
	test	eax, eax
	jle	SHORT $L13898
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?width@ios_base@std@@QBEHXZ		; std::ios_base::width
	cmp	eax, DWORD PTR __Fillcount$[ebp]
	jbe	SHORT $L13898
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?width@ios_base@std@@QBEHXZ		; std::ios_base::width
	sub	eax, DWORD PTR __Fillcount$[ebp]
	mov	DWORD PTR tv212[ebp], eax
	jmp	SHORT $L13899
$L13898:
	mov	DWORD PTR tv212[ebp], 0
$L13899:
	mov	eax, DWORD PTR tv212[ebp]
	mov	DWORD PTR __Fillcount$[ebp], eax

; 1115 : 		ios_base::fmtflags _Adjustfield =
; 1116 : 			_Iosbase.flags() & ios_base::adjustfield;

	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?flags@ios_base@std@@QBEHXZ		; std::ios_base::flags
	and	eax, 448				; 000001c0H
	mov	DWORD PTR __Adjustfield$[ebp], eax

; 1117 : 		if (_Adjustfield != ios_base::left
; 1118 : 			&& _Adjustfield != ios_base::internal)

	cmp	DWORD PTR __Adjustfield$[ebp], 64	; 00000040H
	je	SHORT $L12044
	cmp	DWORD PTR __Adjustfield$[ebp], 256	; 00000100H
	je	SHORT $L12044

; 1119 : 			{	// put leading fill
; 1120 : 			_Dest = _Rep(_Dest, _Fill, _Fillcount);

	mov	ecx, DWORD PTR __Fillcount$[ebp]
	push	ecx
	mov	dl, BYTE PTR __Fill$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T13900[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
	add	esp, 24					; 00000018H
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	DWORD PTR __Dest$[ebp+4], edx

; 1121 : 			_Fillcount = 0;

	mov	DWORD PTR __Fillcount$[ebp], 0

; 1122 : 			}
; 1123 : 		else if (_Adjustfield == ios_base::internal)

	jmp	$L12046
$L12044:
	cmp	DWORD PTR __Adjustfield$[ebp], 256	; 00000100H
	jne	SHORT $L12046

; 1124 : 			{	// put internal fill
; 1125 : 			if (0 < _Prefix)

	cmp	DWORD PTR __Prefix$[ebp], 0
	jbe	SHORT $L12048

; 1126 : 				{	// but first put sign
; 1127 : 				_Dest = _Putc(_Dest, _Buf, 1);

	push	1
	mov	eax, DWORD PTR __Buf$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR $T13901[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	?_Putc@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Putc
	add	esp, 24					; 00000018H
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR __Dest$[ebp], edx
	mov	DWORD PTR __Dest$[ebp+4], eax

; 1128 : 				++_Buf, --_Count;

	mov	ecx, DWORD PTR __Buf$[ebp]
	add	ecx, 1
	mov	DWORD PTR __Buf$[ebp], ecx
	mov	edx, DWORD PTR __Count$[ebp]
	sub	edx, 1
	mov	DWORD PTR __Count$[ebp], edx
$L12048:

; 1129 : 				}
; 1130 : 			_Dest = _Rep(_Dest, _Fill, _Fillcount);

	mov	eax, DWORD PTR __Fillcount$[ebp]
	push	eax
	mov	cl, BYTE PTR __Fill$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T13902[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
	add	esp, 24					; 00000018H
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	DWORD PTR __Dest$[ebp+4], edx

; 1131 : 			_Fillcount = 0;

	mov	DWORD PTR __Fillcount$[ebp], 0
$L12046:

; 1132 : 			}
; 1133 : 
; 1134 : 		const char *_Ptr = (const char *)::memchr(_Buf,
; 1135 : 			_Enders[0], _Count);	// find decimal point

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	movsx	ecx, BYTE PTR __Enders$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Buf$[ebp]
	push	edx
	call	_memchr
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$[ebp], eax

; 1136 : 		if (_Ptr != 0)

	cmp	DWORD PTR __Ptr$[ebp], 0
	je	$L12053

; 1137 : 			{	// has decimal point, put pieces and zero fills
; 1138 : 			size_t _Fracoffset = _Ptr - _Buf + 1;

	mov	eax, DWORD PTR __Ptr$[ebp]
	sub	eax, DWORD PTR __Buf$[ebp]
	add	eax, 1
	mov	DWORD PTR __Fracoffset$12054[ebp], eax

; 1139 : 			_Dest = _Putgrouped(_Dest, _Buf, _Fracoffset - 1, _Kseparator);

	mov	cl, BYTE PTR __Kseparator$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Fracoffset$12054[ebp]
	sub	edx, 1
	push	edx
	mov	eax, DWORD PTR __Buf$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR $T13903[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	?_Putgrouped@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDID@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Putgrouped
	add	esp, 28					; 0000001cH
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR __Dest$[ebp], edx
	mov	DWORD PTR __Dest$[ebp+4], eax

; 1140 : 			_Dest = _Rep(_Dest, _E0, _Beforepoint);

	mov	ecx, DWORD PTR __Beforepoint$[ebp]
	push	ecx
	mov	dl, BYTE PTR __E0$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T13904[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
	add	esp, 24					; 00000018H
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	DWORD PTR __Dest$[ebp+4], edx

; 1141 : 			_Dest = _Rep(_Dest, _Punct_fac.decimal_point(), 1);

	push	1
	mov	ecx, DWORD PTR __Punct_fac$[ebp]
	call	?decimal_point@?$numpunct@D@std@@QBEDXZ	; std::numpunct<char>::decimal_point
	push	eax
	mov	eax, DWORD PTR __Dest$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T13905[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
	add	esp, 24					; 00000018H
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	DWORD PTR __Dest$[ebp+4], edx

; 1142 : 			_Dest = _Rep(_Dest, _E0, _Afterpoint);

	mov	eax, DWORD PTR __Afterpoint$[ebp]
	push	eax
	mov	cl, BYTE PTR __E0$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T13906[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
	add	esp, 24					; 00000018H
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	DWORD PTR __Dest$[ebp+4], edx

; 1143 : 			_Buf += _Fracoffset, _Count -= _Fracoffset;

	mov	eax, DWORD PTR __Buf$[ebp]
	add	eax, DWORD PTR __Fracoffset$12054[ebp]
	mov	DWORD PTR __Buf$[ebp], eax
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, DWORD PTR __Fracoffset$12054[ebp]
	mov	DWORD PTR __Count$[ebp], ecx
$L12053:

; 1144 : 			}
; 1145 : 
; 1146 : 		if ((_Ptr = (const char *)::memchr(_Buf, 'e', _Count)) != 0)

	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	push	101					; 00000065H
	mov	eax, DWORD PTR __Buf$[ebp]
	push	eax
	call	_memchr
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$[ebp], eax
	cmp	DWORD PTR __Ptr$[ebp], 0
	je	$L12060

; 1147 : 			{	// has exponent field, put it out
; 1148 : 			size_t _Expoffset = _Ptr - _Buf + 1;

	mov	ecx, DWORD PTR __Ptr$[ebp]
	sub	ecx, DWORD PTR __Buf$[ebp]
	add	ecx, 1
	mov	DWORD PTR __Expoffset$12061[ebp], ecx

; 1149 : 			_Dest = _Putgrouped(_Dest, _Buf, _Expoffset - 1, _Kseparator);

	mov	dl, BYTE PTR __Kseparator$[ebp]
	push	edx
	mov	eax, DWORD PTR __Expoffset$12061[ebp]
	sub	eax, 1
	push	eax
	mov	ecx, DWORD PTR __Buf$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T13907[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?_Putgrouped@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDID@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Putgrouped
	add	esp, 28					; 0000001cH
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	DWORD PTR __Dest$[ebp+4], edx

; 1150 : 			_Dest = _Rep(_Dest, _E0, _Trailing), _Trailing = 0;

	mov	eax, DWORD PTR __Trailing$[ebp]
	push	eax
	mov	cl, BYTE PTR __E0$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T13908[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
	add	esp, 24					; 00000018H
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	DWORD PTR __Dest$[ebp+4], edx
	mov	DWORD PTR __Trailing$[ebp], 0

; 1151 : 			_Dest = _Putc(_Dest, _Iosbase.flags() & ios_base::uppercase
; 1152 : 				? "E" : "e", 1);

	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?flags@ios_base@std@@QBEHXZ		; std::ios_base::flags
	and	eax, 4
	je	SHORT $L13909
	mov	DWORD PTR tv347[ebp], OFFSET FLAT:??_C@_01DDCIFGEA@E?$AA@
	jmp	SHORT $L13910
$L13909:
	mov	DWORD PTR tv347[ebp], OFFSET FLAT:??_C@_01KGKMHCOC@e?$AA@
$L13910:
	push	1
	mov	eax, DWORD PTR tv347[ebp]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR $T13911[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	?_Putc@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Putc
	add	esp, 24					; 00000018H
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR __Dest$[ebp], edx
	mov	DWORD PTR __Dest$[ebp+4], eax

; 1153 : 			_Buf += _Expoffset, _Count -= _Expoffset;

	mov	ecx, DWORD PTR __Buf$[ebp]
	add	ecx, DWORD PTR __Expoffset$12061[ebp]
	mov	DWORD PTR __Buf$[ebp], ecx
	mov	edx, DWORD PTR __Count$[ebp]
	sub	edx, DWORD PTR __Expoffset$12061[ebp]
	mov	DWORD PTR __Count$[ebp], edx
$L12060:

; 1154 : 			}
; 1155 : 
; 1156 : 		_Dest = _Putgrouped(_Dest, _Buf, _Count,
; 1157 : 			_Kseparator);	// put leftover field

	mov	al, BYTE PTR __Kseparator$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Buf$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T13912[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?_Putgrouped@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDID@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Putgrouped
	add	esp, 28					; 0000001cH
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	DWORD PTR __Dest$[ebp+4], edx

; 1158 : 		_Dest = _Rep(_Dest, _E0, _Trailing);	// put trailing zeros

	mov	eax, DWORD PTR __Trailing$[ebp]
	push	eax
	mov	cl, BYTE PTR __E0$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T13913[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
	add	esp, 24					; 00000018H
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	DWORD PTR __Dest$[ebp+4], edx

; 1159 : 		_Iosbase.width(0);

	push	0
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?width@ios_base@std@@QAEHH@Z		; std::ios_base::width

; 1160 : 		return (_Rep(_Dest, _Fill, _Fillcount));	// put trailing fill

	mov	eax, DWORD PTR __Fillcount$[ebp]
	push	eax
	mov	cl, BYTE PTR __Fill$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
	add	esp, 24					; 00000018H
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR __Groupstring$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Grouping$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1161 : 		}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L13925
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	call	@__security_check_cookie@4
	pop	edi
	add	esp, 268				; 0000010cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$L13925:
	DD	3
	DD	$L13924
$L13924:
	DD	-52					; ffffffccH
	DD	28					; 0000001cH
	DD	$L13919
	DD	-92					; ffffffa4H
	DD	28					; 0000001cH
	DD	$L13920
	DD	-112					; ffffff90H
	DD	3
	DD	$L13921
$L13921:
	DB	95					; 0000005fH
	DB	69					; 00000045H
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	115					; 00000073H
	DB	0
$L13920:
	DB	95					; 0000005fH
	DB	71					; 00000047H
	DB	114					; 00000072H
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	112					; 00000070H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	103					; 00000067H
	DB	0
$L13919:
	DB	95					; 0000005fH
	DB	71					; 00000047H
	DB	114					; 00000072H
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	112					; 00000070H
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	103					; 00000067H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L13914:
	lea	ecx, DWORD PTR $T13895[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
$L13915:
	lea	ecx, DWORD PTR __Grouping$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L13916:
	lea	ecx, DWORD PTR __Groupstring$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDIIII@Z:
	mov	eax, OFFSET FLAT:$T13918
	jmp	___CxxFrameHandler
text$x	ENDS
?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDIIII@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Fput
; Function compile flags: /Odt /RTCsu
;	COMDAT ?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADPBDH@Z
_TEXT	SEGMENT
tv85 = -10						; size = 1
tv86 = -9						; size = 1
__Basefield$ = -8					; size = 4
__Ptr$ = -4						; size = 4
_this$ = 8						; size = 4
__Fmt$ = 12						; size = 4
__Spec$ = 16						; size = 4
__Flags$ = 20						; size = 4
?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADPBDH@Z PROC NEAR ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ifmt, COMDAT

; 1165 : 		{	// generate sprintf format for integer

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 1166 : 		char *_Ptr = _Fmt;

	mov	eax, DWORD PTR __Fmt$[ebp]
	mov	DWORD PTR __Ptr$[ebp], eax

; 1167 : 		*_Ptr++ = '%';

	mov	ecx, DWORD PTR __Ptr$[ebp]
	mov	BYTE PTR [ecx], 37			; 00000025H
	mov	edx, DWORD PTR __Ptr$[ebp]
	add	edx, 1
	mov	DWORD PTR __Ptr$[ebp], edx

; 1168 : 
; 1169 : 		if (_Flags & ios_base::showpos)

	mov	eax, DWORD PTR __Flags$[ebp]
	and	eax, 32					; 00000020H
	je	SHORT $L12073

; 1170 : 			*_Ptr++ = '+';

	mov	ecx, DWORD PTR __Ptr$[ebp]
	mov	BYTE PTR [ecx], 43			; 0000002bH
	mov	edx, DWORD PTR __Ptr$[ebp]
	add	edx, 1
	mov	DWORD PTR __Ptr$[ebp], edx
$L12073:

; 1171 : 		if (_Flags & ios_base::showbase)

	mov	eax, DWORD PTR __Flags$[ebp]
	and	eax, 8
	je	SHORT $L12074

; 1172 : 			*_Ptr++ = '#';

	mov	ecx, DWORD PTR __Ptr$[ebp]
	mov	BYTE PTR [ecx], 35			; 00000023H
	mov	edx, DWORD PTR __Ptr$[ebp]
	add	edx, 1
	mov	DWORD PTR __Ptr$[ebp], edx
$L12074:

; 1173 : 		if (_Spec[0] != 'L')

	mov	eax, DWORD PTR __Spec$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 76					; 0000004cH
	je	SHORT $L12075

; 1174 : 			*_Ptr++ = _Spec[0];	// qualifier

	mov	edx, DWORD PTR __Ptr$[ebp]
	mov	eax, DWORD PTR __Spec$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx], cl
	mov	edx, DWORD PTR __Ptr$[ebp]
	add	edx, 1
	mov	DWORD PTR __Ptr$[ebp], edx

; 1175 : 		else

	jmp	SHORT $L12076
$L12075:

; 1176 : 			{	/* change L to I64 */
; 1177 : 			*_Ptr++ = 'I';

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	BYTE PTR [eax], 73			; 00000049H
	mov	ecx, DWORD PTR __Ptr$[ebp]
	add	ecx, 1
	mov	DWORD PTR __Ptr$[ebp], ecx

; 1178 : 			*_Ptr++ = '6';

	mov	edx, DWORD PTR __Ptr$[ebp]
	mov	BYTE PTR [edx], 54			; 00000036H
	mov	eax, DWORD PTR __Ptr$[ebp]
	add	eax, 1
	mov	DWORD PTR __Ptr$[ebp], eax

; 1179 : 			*_Ptr++ = '4';

	mov	ecx, DWORD PTR __Ptr$[ebp]
	mov	BYTE PTR [ecx], 52			; 00000034H
	mov	edx, DWORD PTR __Ptr$[ebp]
	add	edx, 1
	mov	DWORD PTR __Ptr$[ebp], edx
$L12076:

; 1180 : 			}
; 1181 : 
; 1182 : 		ios_base::fmtflags _Basefield = _Flags & ios_base::basefield;

	mov	eax, DWORD PTR __Flags$[ebp]
	and	eax, 3584				; 00000e00H
	mov	DWORD PTR __Basefield$[ebp], eax

; 1183 : 		*_Ptr++ = _Basefield == ios_base::oct ? 'o'
; 1184 : 			: _Basefield != ios_base::hex ? _Spec[1]	// 'd' or 'u'
; 1185 : 			: _Flags & ios_base::uppercase ? 'X' : 'x';

	cmp	DWORD PTR __Basefield$[ebp], 1024	; 00000400H
	jne	SHORT $L13933
	mov	BYTE PTR tv86[ebp], 111			; 0000006fH
	jmp	SHORT $L13934
$L13933:
	cmp	DWORD PTR __Basefield$[ebp], 2048	; 00000800H
	je	SHORT $L13931
	mov	ecx, DWORD PTR __Spec$[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR tv85[ebp], dl
	jmp	SHORT $L13932
$L13931:
	mov	eax, DWORD PTR __Flags$[ebp]
	and	eax, 4
	neg	eax
	sbb	al, al
	and	al, -32					; ffffffe0H
	add	al, 120					; 00000078H
	mov	BYTE PTR tv85[ebp], al
$L13932:
	mov	cl, BYTE PTR tv85[ebp]
	mov	BYTE PTR tv86[ebp], cl
$L13934:
	mov	edx, DWORD PTR __Ptr$[ebp]
	mov	al, BYTE PTR tv86[ebp]
	mov	BYTE PTR [edx], al
	mov	ecx, DWORD PTR __Ptr$[ebp]
	add	ecx, 1
	mov	DWORD PTR __Ptr$[ebp], ecx

; 1186 : 		*_Ptr = '\0';

	mov	edx, DWORD PTR __Ptr$[ebp]
	mov	BYTE PTR [edx], 0

; 1187 : 		return (_Fmt);

	mov	eax, DWORD PTR __Fmt$[ebp]

; 1188 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADPBDH@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ifmt
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
$T13959	DD	0ffffffffH
	DD	FLAT:$L13950
	DD	0ffffffffH
	DD	FLAT:$L13951
$T13953	DD	019930520H
	DD	02H
	DD	FLAT:$T13959
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z
_TEXT	SEGMENT
tv163 = -132						; size = 4
tv88 = -128						; size = 4
tv87 = -124						; size = 4
tv211 = -120						; size = 4
tv214 = -116						; size = 4
$T13949 = -112						; size = 8
$T13948 = -104						; size = 8
$T13947 = -96						; size = 8
$T13946 = -88						; size = 8
$T13938 = -80						; size = 4
__Adjustfield$ = -76					; size = 4
__Fillcount$ = -72					; size = 4
__Off$12088 = -68					; size = 4
__Pg$12087 = -64					; size = 4
__Prefix$ = -60						; size = 4
__Grouping$ = -52					; size = 28
__Punct_fac$ = -20					; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
__Dest$ = 16						; size = 8
__Iosbase$ = 24						; size = 4
__Fill$ = 28						; size = 1
__Buf$ = 32						; size = 4
__Count$ = 36						; size = 4
?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z PROC NEAR ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput, COMDAT

; 1192 : 		{	// put formatted integer to _Dest

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 120				; 00000078H
	push	edi
	lea	edi, DWORD PTR [ebp-132]
	mov	ecx, 30					; 0000001eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1193 : 		const _Mypunct& _Punct_fac = _USE(_Iosbase.getloc(), _Mypunct);

	lea	eax, DWORD PTR $T13938[ebp]
	push	eax
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?getloc@ios_base@std@@QBE?AVlocale@2@XZ	; std::ios_base::getloc
	mov	DWORD PTR tv214[ebp], eax
	mov	ecx, DWORD PTR tv214[ebp]
	mov	DWORD PTR tv211[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR tv211[ebp]
	push	edx
	call	??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z ; std::use_facet<std::numpunct<char> >
	add	esp, 4
	mov	DWORD PTR __Punct_fac$[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T13938[ebp]
	call	??1locale@std@@QAE@XZ			; std::locale::~locale

; 1194 : 		const string _Grouping = _Punct_fac.grouping();

	lea	eax, DWORD PTR __Grouping$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Punct_fac$[ebp]
	call	?grouping@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::grouping
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 1195 : 		const size_t _Prefix = *_Buf == '+' || *_Buf == '-' ? 1
; 1196 : 			: *_Buf == '0' && (_Buf[1] == 'x' || _Buf[1] == 'X') ? 2
; 1197 : 			: 0;

	mov	ecx, DWORD PTR __Buf$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 43					; 0000002bH
	je	SHORT $L13939
	mov	eax, DWORD PTR __Buf$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 45					; 0000002dH
	je	SHORT $L13939
	mov	edx, DWORD PTR __Buf$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 48					; 00000030H
	jne	SHORT $L13941
	mov	ecx, DWORD PTR __Buf$[ebp]
	movsx	edx, BYTE PTR [ecx+1]
	cmp	edx, 120				; 00000078H
	je	SHORT $L13940
	mov	eax, DWORD PTR __Buf$[ebp]
	movsx	ecx, BYTE PTR [eax+1]
	cmp	ecx, 88					; 00000058H
	jne	SHORT $L13941
$L13940:
	mov	DWORD PTR tv87[ebp], 2
	jmp	SHORT $L13942
$L13941:
	mov	DWORD PTR tv87[ebp], 0
$L13942:
	mov	edx, DWORD PTR tv87[ebp]
	mov	DWORD PTR tv88[ebp], edx
	jmp	SHORT $L13943
$L13939:
	mov	DWORD PTR tv88[ebp], 1
$L13943:
	mov	eax, DWORD PTR tv88[ebp]
	mov	DWORD PTR __Prefix$[ebp], eax

; 1198 : 
; 1199 : 		if (*_Grouping.c_str() != CHAR_MAX && '\0' < *_Grouping.c_str())

	lea	ecx, DWORD PTR __Grouping$[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 127				; 0000007fH
	je	$L12086
	lea	ecx, DWORD PTR __Grouping$[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	movsx	edx, BYTE PTR [eax]
	test	edx, edx
	jle	$L12086

; 1200 : 			{	// grouping specified, add thousands separators
; 1201 : 			const char *_Pg = _Grouping.c_str();

	lea	ecx, DWORD PTR __Grouping$[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	mov	DWORD PTR __Pg$12087[ebp], eax

; 1202 : 			size_t _Off = _Count;

	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Off$12088[ebp], eax
$L12090:

; 1203 : 			while (*_Pg != CHAR_MAX && '\0' < *_Pg
; 1204 : 				&& (size_t)*_Pg < _Off - _Prefix)

	mov	ecx, DWORD PTR __Pg$12087[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 127				; 0000007fH
	je	SHORT $L12086
	mov	eax, DWORD PTR __Pg$12087[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jle	SHORT $L12086
	mov	edx, DWORD PTR __Pg$12087[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR __Off$12088[ebp]
	sub	ecx, DWORD PTR __Prefix$[ebp]
	cmp	eax, ecx
	jae	SHORT $L12086

; 1205 : 				{	// add a comma to mark thousands separator
; 1206 : 				_Off -= *_Pg;

	mov	edx, DWORD PTR __Pg$12087[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR __Off$12088[ebp]
	sub	ecx, eax
	mov	DWORD PTR __Off$12088[ebp], ecx

; 1207 : 				::memmove(&_Buf[_Off + 1], &_Buf[_Off],
; 1208 : 					_Count + 1 - _Off);

	mov	edx, DWORD PTR __Count$[ebp]
	add	edx, 1
	sub	edx, DWORD PTR __Off$12088[ebp]
	push	edx
	mov	eax, DWORD PTR __Buf$[ebp]
	add	eax, DWORD PTR __Off$12088[ebp]
	push	eax
	mov	ecx, DWORD PTR __Off$12088[ebp]
	mov	edx, DWORD PTR __Buf$[ebp]
	lea	eax, DWORD PTR [edx+ecx+1]
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH

; 1209 : 				_Buf[_Off] = ',', ++_Count;

	mov	ecx, DWORD PTR __Buf$[ebp]
	add	ecx, DWORD PTR __Off$12088[ebp]
	mov	BYTE PTR [ecx], 44			; 0000002cH
	mov	edx, DWORD PTR __Count$[ebp]
	add	edx, 1
	mov	DWORD PTR __Count$[ebp], edx

; 1210 : 				if ('\0' < _Pg[1])

	mov	eax, DWORD PTR __Pg$12087[ebp]
	movsx	ecx, BYTE PTR [eax+1]
	test	ecx, ecx
	jle	SHORT $L12093

; 1211 : 					++_Pg;	// not last group, advance

	mov	edx, DWORD PTR __Pg$12087[ebp]
	add	edx, 1
	mov	DWORD PTR __Pg$12087[ebp], edx
$L12093:

; 1212 : 				}

	jmp	SHORT $L12090
$L12086:

; 1213 : 			}
; 1214 : 
; 1215 : 		size_t _Fillcount = _Iosbase.width() <= 0
; 1216 : 			|| (size_t)_Iosbase.width() <= _Count
; 1217 : 				? 0 : (size_t)_Iosbase.width() - _Count;

	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?width@ios_base@std@@QBEHXZ		; std::ios_base::width
	test	eax, eax
	jle	SHORT $L13944
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?width@ios_base@std@@QBEHXZ		; std::ios_base::width
	cmp	eax, DWORD PTR __Count$[ebp]
	jbe	SHORT $L13944
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?width@ios_base@std@@QBEHXZ		; std::ios_base::width
	sub	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR tv163[ebp], eax
	jmp	SHORT $L13945
$L13944:
	mov	DWORD PTR tv163[ebp], 0
$L13945:
	mov	eax, DWORD PTR tv163[ebp]
	mov	DWORD PTR __Fillcount$[ebp], eax

; 1218 : 
; 1219 : 		ios_base::fmtflags _Adjustfield =
; 1220 : 			_Iosbase.flags() & ios_base::adjustfield;

	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?flags@ios_base@std@@QBEHXZ		; std::ios_base::flags
	and	eax, 448				; 000001c0H
	mov	DWORD PTR __Adjustfield$[ebp], eax

; 1221 : 		if (_Adjustfield != ios_base::left
; 1222 : 			&& _Adjustfield != ios_base::internal)

	cmp	DWORD PTR __Adjustfield$[ebp], 64	; 00000040H
	je	SHORT $L12098
	cmp	DWORD PTR __Adjustfield$[ebp], 256	; 00000100H
	je	SHORT $L12098

; 1223 : 			{	// put leading fill
; 1224 : 			_Dest = _Rep(_Dest, _Fill, _Fillcount);

	mov	ecx, DWORD PTR __Fillcount$[ebp]
	push	ecx
	mov	dl, BYTE PTR __Fill$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T13946[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
	add	esp, 24					; 00000018H
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	DWORD PTR __Dest$[ebp+4], edx

; 1225 : 			_Fillcount = 0;

	mov	DWORD PTR __Fillcount$[ebp], 0

; 1226 : 			}
; 1227 : 		else if (_Adjustfield == ios_base::internal)

	jmp	SHORT $L12100
$L12098:
	cmp	DWORD PTR __Adjustfield$[ebp], 256	; 00000100H
	jne	SHORT $L12100

; 1228 : 			{	// put internal fill
; 1229 : 			_Dest = _Putc(_Dest, _Buf, _Prefix);	// put prefix

	mov	eax, DWORD PTR __Prefix$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Buf$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T13947[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?_Putc@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Putc
	add	esp, 24					; 00000018H
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	DWORD PTR __Dest$[ebp+4], edx

; 1230 : 			_Buf += _Prefix, _Count -= _Prefix;

	mov	eax, DWORD PTR __Buf$[ebp]
	add	eax, DWORD PTR __Prefix$[ebp]
	mov	DWORD PTR __Buf$[ebp], eax
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, DWORD PTR __Prefix$[ebp]
	mov	DWORD PTR __Count$[ebp], ecx

; 1231 : 			_Dest = _Rep(_Dest, _Fill, _Fillcount), _Fillcount = 0;

	mov	edx, DWORD PTR __Fillcount$[ebp]
	push	edx
	mov	al, BYTE PTR __Fill$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR $T13948[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
	add	esp, 24					; 00000018H
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR __Dest$[ebp], edx
	mov	DWORD PTR __Dest$[ebp+4], eax
	mov	DWORD PTR __Fillcount$[ebp], 0
$L12100:

; 1232 : 			}
; 1233 : 
; 1234 : 		_Dest = _Putgrouped(_Dest, _Buf, _Count,
; 1235 : 			_Punct_fac.thousands_sep());	// put field

	mov	ecx, DWORD PTR __Punct_fac$[ebp]
	call	?thousands_sep@?$numpunct@D@std@@QBEDXZ	; std::numpunct<char>::thousands_sep
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Buf$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T13949[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?_Putgrouped@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDID@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Putgrouped
	add	esp, 28					; 0000001cH
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	DWORD PTR __Dest$[ebp+4], edx

; 1236 : 		_Iosbase.width(0);

	push	0
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	?width@ios_base@std@@QAEHH@Z		; std::ios_base::width

; 1237 : 		return (_Rep(_Dest, _Fill, _Fillcount));	// put trailing fill

	mov	eax, DWORD PTR __Fillcount$[ebp]
	push	eax
	mov	cl, BYTE PTR __Fill$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
	add	esp, 24					; 00000018H
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Grouping$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1238 : 		}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L13958
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	call	@__security_check_cookie@4
	pop	edi
	add	esp, 132				; 00000084H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$L13958:
	DD	1
	DD	$L13957
$L13957:
	DD	-52					; ffffffccH
	DD	28					; 0000001cH
	DD	$L13954
$L13954:
	DB	95					; 0000005fH
	DB	71					; 00000047H
	DB	114					; 00000072H
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	112					; 00000070H
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	103					; 00000067H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L13950:
	lea	ecx, DWORD PTR $T13938[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
$L13951:
	lea	ecx, DWORD PTR __Grouping$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z:
	mov	eax, OFFSET FLAT:$T13953
	jmp	___CxxFrameHandler
text$x	ENDS
?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput
PUBLIC	??4?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@D@Z ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator=
PUBLIC	??D?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator*
PUBLIC	??E?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator++
; Function compile flags: /Odt /RTCsu
;	COMDAT ?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
__Dest$ = 16						; size = 8
__Ptr$ = 24						; size = 4
__Count$ = 28						; size = 4
?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z PROC NEAR ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put, COMDAT

; 1242 : 		{	// put [_Ptr, _Ptr + _Count) to _Dest

	push	ebp
	mov	ebp, esp

; 1243 : 		for (; 0 < _Count; --_Count, ++_Dest, ++_Ptr)

	jmp	SHORT $L12109
$L12110:
	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, 1
	mov	DWORD PTR __Count$[ebp], eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	call	??E?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator++
	mov	ecx, DWORD PTR __Ptr$[ebp]
	add	ecx, 1
	mov	DWORD PTR __Ptr$[ebp], ecx
$L12109:
	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $L12111

; 1244 : 			*_Dest = *_Ptr;

	mov	edx, DWORD PTR __Ptr$[ebp]
	mov	al, BYTE PTR [edx]
	push	eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	call	??D?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator*
	mov	ecx, eax
	call	??4?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@D@Z ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator=
	jmp	SHORT $L12110
$L12111:

; 1245 : 		return (_Dest);

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR __Dest$[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1246 : 		}

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
__Dest$ = 16						; size = 8
__Ch$ = 24						; size = 1
__Count$ = 28						; size = 4
?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z PROC NEAR ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep, COMDAT

; 1276 : 		{	// put _Count * _Ch to _Dest

	push	ebp
	mov	ebp, esp

; 1277 : 		for (; 0 < _Count; --_Count, ++_Dest)

	jmp	SHORT $L12115
$L12116:
	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, 1
	mov	DWORD PTR __Count$[ebp], eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	call	??E?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator++
$L12115:
	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $L12117

; 1278 : 			*_Dest = _Ch;

	mov	cl, BYTE PTR __Ch$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Dest$[ebp]
	call	??D?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator*
	mov	ecx, eax
	call	??4?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@D@Z ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator=
	jmp	SHORT $L12116
$L12117:

; 1279 : 		return (_Dest);

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __Dest$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1280 : 		}

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?falsename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
$T13969 = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?falsename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC NEAR ; std::numpunct<char>::falsename, COMDAT
; _this$ = ecx

; 53   : 		{	// return name for false

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T13969[ebp], 0

; 54   : 		return (do_falsename());

	mov	esi, esp
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+16]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	eax, DWORD PTR $T13969[ebp]
	or	eax, 1
	mov	DWORD PTR $T13969[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 55   : 		}

	pop	esi
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?falsename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::numpunct<char>::falsename
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?truename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
$T13974 = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?truename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC NEAR ; std::numpunct<char>::truename, COMDAT
; _this$ = ecx

; 58   : 		{	// return name for true

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T13974[ebp], 0

; 59   : 		return (do_truename());

	mov	esi, esp
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+20]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	eax, DWORD PTR $T13974[ebp]
	or	eax, 1
	mov	DWORD PTR $T13974[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 60   : 		}

	pop	esi
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?truename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::numpunct<char>::truename
_TEXT	ENDS
PUBLIC	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
__Num$ = -8						; size = 4
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 521  : 		{	// append [_Ptr, _Ptr + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 522  : 		if (_Inside(_Ptr))

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $L12150

; 523  : 			return (append(*this, _Ptr - _Myptr(), _Count));	// substring

	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	mov	ecx, DWORD PTR __Ptr$[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	jmp	SHORT $L12149
$L12150:

; 524  : 		if (npos - _Mysize <= _Count)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::npos
	sub	ecx, DWORD PTR [eax+20]
	cmp	ecx, DWORD PTR __Count$[ebp]
	ja	SHORT $L12151

; 525  : 			_String_base::_Xlen();	// result too long

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xlen@_String_base@std@@QBEXXZ		; std::_String_base::_Xlen
$L12151:

; 526  : 
; 527  : 		size_type _Num;
; 528  : 		if (0 < _Count && _Grow(_Num = _Mysize + _Count))

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $L12153
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Num$[ebp], eax
	push	0
	mov	ecx, DWORD PTR __Num$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	edx, al
	test	edx, edx
	je	SHORT $L12153

; 529  : 			{	// make room and append new stuff
; 530  : 			_Traits::copy(_Myptr() + _Mysize, _Ptr, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	mov	edx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [edx+20]
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 531  : 			_Eos(_Num);

	mov	eax, DWORD PTR __Num$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$L12153:

; 532  : 			}
; 533  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$L12149:

; 534  : 		}

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
PUBLIC	?assign@?$char_traits@D@std@@SAPADPADID@Z	; std::char_traits<char>::assign
; Function compile flags: /Odt /RTCsu
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z
_TEXT	SEGMENT
__Num$ = -8						; size = 4
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
__Ch$ = 12						; size = 1
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 542  : 		{	// append _Count * _Ch

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 543  : 		if (npos - _Mysize <= _Count)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::npos
	sub	ecx, DWORD PTR [eax+20]
	cmp	ecx, DWORD PTR __Count$[ebp]
	ja	SHORT $L12156

; 544  : 			_String_base::_Xlen();	// result too long

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xlen@_String_base@std@@QBEXXZ		; std::_String_base::_Xlen
$L12156:

; 545  : 
; 546  : 		size_type _Num;
; 547  : 		if (0 < _Count && _Grow(_Num = _Mysize + _Count))

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $L12158
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Num$[ebp], eax
	push	0
	mov	ecx, DWORD PTR __Num$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	edx, al
	test	edx, edx
	je	SHORT $L12158

; 548  : 			{	// make room and append new stuff using assign
; 549  : 			_Traits::assign(_Myptr() + _Mysize, _Count, _Ch);

	mov	al, BYTE PTR __Ch$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	mov	edx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [edx+20]
	push	eax
	call	?assign@?$char_traits@D@std@@SAPADPADID@Z ; std::char_traits<char>::assign
	add	esp, 12					; 0000000cH

; 550  : 			_Eos(_Num);

	mov	eax, DWORD PTR __Num$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$L12158:

; 551  : 			}
; 552  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 553  : 		}

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\iosfwd
_TEXT	ENDS
;	COMDAT ?assign@?$char_traits@D@std@@SAPADPADID@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Ch$ = 16						; size = 1
?assign@?$char_traits@D@std@@SAPADPADID@Z PROC NEAR	; std::char_traits<char>::assign, COMDAT

; 374  : 		{	// assign _Count * _Ch to [_First, ...)

	push	ebp
	mov	ebp, esp

; 375  : 		return ((_Elem *)::memset(_First, _Ch, _Count));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	movsx	ecx, BYTE PTR __Ch$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 376  : 		}

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
?assign@?$char_traits@D@std@@SAPADPADID@Z ENDP		; std::char_traits<char>::assign
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xstring
_TEXT	ENDS
;	COMDAT ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IID@Z
_TEXT	SEGMENT
__Num$ = -8						; size = 4
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
__Ch$ = 16						; size = 1
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IID@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert, COMDAT
; _this$ = ecx

; 726  : 		{	// insert _Count * _Ch at _Off

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 727  : 		if (_Mysize < _Off)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $L12161

; 728  : 			_String_base::_Xran();	// _Off off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@_String_base@std@@QBEXXZ		; std::_String_base::_Xran
$L12161:

; 729  : 		if (npos - _Mysize <= _Count)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::npos
	sub	eax, DWORD PTR [edx+20]
	cmp	eax, DWORD PTR __Count$[ebp]
	ja	SHORT $L12162

; 730  : 			_String_base::_Xlen();	// result too long

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xlen@_String_base@std@@QBEXXZ		; std::_String_base::_Xlen
$L12162:

; 731  : 		size_type _Num;
; 732  : 		if (0 < _Count && _Grow(_Num = _Mysize + _Count))

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $L12164
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	add	edx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Num$[ebp], edx
	push	0
	mov	eax, DWORD PTR __Num$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $L12164

; 733  : 			{	// make room and insert new stuff
; 734  : 			_Traits::move(_Myptr() + _Off + _Count,
; 735  : 				_Myptr() + _Off, _Mysize - _Off);	// empty out hole

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	sub	eax, DWORD PTR __Off$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	add	eax, DWORD PTR __Off$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	add	eax, DWORD PTR __Off$[ebp]
	add	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move
	add	esp, 12					; 0000000cH

; 736  : 			_Traits::assign(_Myptr() + _Off, _Count, _Ch);	// fill hole

	mov	cl, BYTE PTR __Ch$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	add	eax, DWORD PTR __Off$[ebp]
	push	eax
	call	?assign@?$char_traits@D@std@@SAPADPADID@Z ; std::char_traits<char>::assign
	add	esp, 12					; 0000000cH

; 737  : 			_Eos(_Num);

	mov	eax, DWORD PTR __Num$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$L12164:

; 738  : 			}
; 739  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 740  : 		}

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[], COMDAT
; _this$ = ecx

; 1078 : 		{	// subscript mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1079 : 		return (_Myptr()[_Off]);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	add	eax, DWORD PTR __Off$[ebp]

; 1080 : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@D@std@@QBEIXZ		; std::allocator<char>::max_size
; Function compile flags: /Odt /RTCsu
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
tv68 = -12						; size = 4
__Num$ = -8						; size = 4
_this$ = -4						; size = 4
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 1113 : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1114 : 		size_type _Num = _Mybase::_Alval.max_size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$allocator@D@std@@QBEIXZ	; std::allocator<char>::max_size
	mov	DWORD PTR __Num$[ebp], eax

; 1115 : 		return (_Num <= 1 ? 1 : _Num - 1);

	cmp	DWORD PTR __Num$[ebp], 1
	ja	SHORT $L13988
	mov	DWORD PTR tv68[ebp], 1
	jmp	SHORT $L13989
$L13988:
	mov	eax, DWORD PTR __Num$[ebp]
	sub	eax, 1
	mov	DWORD PTR tv68[ebp], eax
$L13989:
	mov	eax, DWORD PTR tv68[ebp]

; 1116 : 		}

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
;	COMDAT xdata$x
xdata$x	SEGMENT
$T13999	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
$T14001	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L13995
$T14002	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L13993
$T14000	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:$T14001
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:$T14002
$T13997	DD	019930520H
	DD	04H
	DD	FLAT:$T13999
	DD	02H
	DD	FLAT:$T14000
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z
_TEXT	SEGMENT
tv145 = -36						; size = 4
tv144 = -32						; size = 4
__Ptr$ = -28						; size = 4
__Newres$ = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Newsize$ = 8						; size = 4
__Oldlen$ = 12						; size = 4
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy, COMDAT
; _this$ = ecx

; 1444 : 		{	// copy _Oldlen elements to newly allocated buffer

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi
	push	edi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-36], eax
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1445 : 		size_type _Newres = _Newsize | _ALLOC_MASK;

	mov	eax, DWORD PTR __Newsize$[ebp]
	or	eax, 15					; 0000000fH
	mov	DWORD PTR __Newres$[ebp], eax

; 1446 : 		if (max_size() < _Newres)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	eax, DWORD PTR __Newres$[ebp]
	jae	SHORT $L12173

; 1447 : 			_Newres = _Newsize;	// undo roundup if too big

	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], ecx

; 1448 : 		else if (_Newres / 3 < _Myres / 2

	jmp	SHORT $L12174
$L12173:

; 1449 : 			&& _Myres <= max_size() - _Myres / 2)

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+24]
	shr	ecx, 1
	mov	eax, DWORD PTR __Newres$[ebp]
	xor	edx, edx
	mov	esi, 3
	div	esi
	cmp	eax, ecx
	jae	SHORT $L12174
	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [edx+24]
	shr	esi, 1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	sub	eax, esi
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+24], eax
	ja	SHORT $L12174

; 1450 : 			_Newres = _Myres + _Myres / 2;	// grow exponentially if possible

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	shr	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+24]
	mov	DWORD PTR __Newres$[ebp], eax
$L12174:

; 1451 : 		_Elem *_Ptr;
; 1452 : 
; 1453 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1454 : 			_Ptr = _Mybase::_Alval.allocate(_Newres + 1);

	mov	edx, DWORD PTR __Newres$[ebp]
	add	edx, 1
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate
	mov	DWORD PTR tv144[ebp], eax
	mov	eax, DWORD PTR tv144[ebp]
	mov	DWORD PTR __Ptr$[ebp], eax
	jmp	SHORT $L13992
$L13993:

; 1455 : 		_CATCH_ALL

	mov	DWORD PTR __$EHRec$[ebp], esp

; 1456 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], ecx

; 1457 : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 2

; 1458 : 				_Ptr = _Mybase::_Alval.allocate(_Newres + 1);

	mov	edx, DWORD PTR __Newres$[ebp]
	add	edx, 1
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate
	mov	DWORD PTR tv145[ebp], eax
	mov	eax, DWORD PTR tv145[ebp]
	mov	DWORD PTR __Ptr$[ebp], eax
	jmp	SHORT $L13994
$L13995:

; 1459 : 			_CATCH_ALL
; 1460 : 			_Tidy(true);	// failed again, discard storage and reraise

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 1461 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$L13994:

; 1462 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], 1

; 1463 : 		_CATCH_END

	mov	eax, $L13992
	ret	0
$L13992:
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1464 : 
; 1465 : 		if (0 < _Oldlen)

	cmp	DWORD PTR __Oldlen$[ebp], 0
	jbe	SHORT $L12179

; 1466 : 			_Traits::copy(_Ptr, _Myptr(), _Oldlen);	// copy existing elements

	mov	ecx, DWORD PTR __Oldlen$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	push	eax
	mov	edx, DWORD PTR __Ptr$[ebp]
	push	edx
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH
$L12179:

; 1467 : 		_Tidy(true);

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 1468 : 		_Bx._Ptr = _Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 1469 : 		_Myres = _Newres;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Newres$[ebp]
	mov	DWORD PTR [edx+24], eax

; 1470 : 		_Eos(_Oldlen);

	mov	ecx, DWORD PTR __Oldlen$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$L13991:

; 1471 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 36					; 00000024H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z:
	mov	eax, OFFSET FLAT:$T13997
	jmp	___CxxFrameHandler
text$x	ENDS
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
; Function compile flags: /Odt /RTCsu
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside, COMDAT
; _this$ = ecx

; 1494 : 		{	// test if _Ptr points inside string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1495 : 		if (_Ptr < _Myptr() || _Myptr() + _Mysize <= _Ptr)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	cmp	DWORD PTR __Ptr$[ebp], eax
	jb	SHORT $L12183
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+20]
	cmp	eax, DWORD PTR __Ptr$[ebp]
	ja	SHORT $L12182
$L12183:

; 1496 : 			return (false);	// don't ask

	xor	al, al
	jmp	SHORT $L12181
$L12182:

; 1497 : 		else
; 1498 : 			return (true);

	mov	al, 1
$L12181:

; 1499 : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xlocnum
_TEXT	ENDS
;	COMDAT ?_Putc@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
__Dest$ = 16						; size = 8
__Ptr$ = 24						; size = 4
__Count$ = 28						; size = 4
?_Putc@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z PROC NEAR ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Putc, COMDAT

; 1250 : 		{	// put char sequence [_Ptr, _Ptr + _Count) to _Dest

	push	ebp
	mov	ebp, esp

; 1251 : 		for (; 0 < _Count; --_Count, ++_Dest, ++_Ptr)

	jmp	SHORT $L12206
$L12207:
	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, 1
	mov	DWORD PTR __Count$[ebp], eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	call	??E?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator++
	mov	ecx, DWORD PTR __Ptr$[ebp]
	add	ecx, 1
	mov	DWORD PTR __Ptr$[ebp], ecx
$L12206:
	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $L12208

; 1252 : 			*_Dest = _MAKLOCCHR(_Elem, *_Ptr, _Cvt);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 8
	push	edx
	push	0
	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	cl, BYTE PTR [eax]
	push	ecx
	call	??$_Maklocchr@D@std@@YADDPADABU_Cvtvec@@@Z ; std::_Maklocchr<char>
	add	esp, 12					; 0000000cH
	push	eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	call	??D?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator*
	mov	ecx, eax
	call	??4?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@D@Z ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator=
	jmp	SHORT $L12207
$L12208:

; 1253 : 		return (_Dest);

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __Dest$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1254 : 		}

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
?_Putc@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Putc
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?_Putgrouped@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDID@Z
_TEXT	SEGMENT
tv72 = -28						; size = 4
$T14014 = -24						; size = 8
$T14013 = -16						; size = 8
__Groupsize$12218 = -8					; size = 4
__Pend$12216 = -4					; size = 4
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
__Dest$ = 16						; size = 8
__Ptr$ = 24						; size = 4
__Count$ = 28						; size = 4
__Kseparator$ = 32					; size = 1
?_Putgrouped@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDID@Z PROC NEAR ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Putgrouped, COMDAT

; 1258 : 		{	// put char sequence [_Ptr, _Ptr + _Count) to _Dest with commas

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 1259 : 		for (; ; ++_Ptr, --_Count)

	jmp	SHORT $L12213
$L12214:
	mov	eax, DWORD PTR __Ptr$[ebp]
	add	eax, 1
	mov	DWORD PTR __Ptr$[ebp], eax
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Count$[ebp], ecx
$L12213:

; 1260 : 			{	// put field with thousands separators for commas
; 1261 : 			const char *_Pend = (const char *)::memchr(_Ptr, ',', _Count);

	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	push	44					; 0000002cH
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	_memchr
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Pend$12216[ebp], eax

; 1262 : 			size_t _Groupsize = _Pend != 0 ? _Pend - _Ptr : _Count;

	cmp	DWORD PTR __Pend$12216[ebp], 0
	je	SHORT $L14011
	mov	ecx, DWORD PTR __Pend$12216[ebp]
	sub	ecx, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR tv72[ebp], ecx
	jmp	SHORT $L14012
$L14011:
	mov	edx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR tv72[ebp], edx
$L14012:
	mov	eax, DWORD PTR tv72[ebp]
	mov	DWORD PTR __Groupsize$12218[ebp], eax

; 1263 : 
; 1264 : 			_Dest = _Putc(_Dest, _Ptr, _Groupsize);

	mov	ecx, DWORD PTR __Groupsize$12218[ebp]
	push	ecx
	mov	edx, DWORD PTR __Ptr$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T14013[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?_Putc@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Putc
	add	esp, 24					; 00000018H
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	DWORD PTR __Dest$[ebp+4], edx

; 1265 : 			_Ptr += _Groupsize, _Count -= _Groupsize;

	mov	eax, DWORD PTR __Ptr$[ebp]
	add	eax, DWORD PTR __Groupsize$12218[ebp]
	mov	DWORD PTR __Ptr$[ebp], eax
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, DWORD PTR __Groupsize$12218[ebp]
	mov	DWORD PTR __Count$[ebp], ecx

; 1266 : 			if (_Count == 0)

	jne	SHORT $L12220

; 1267 : 				break;

	jmp	SHORT $L12215
$L12220:

; 1268 : 			if (_Kseparator != (_Elem)0)

	movsx	edx, BYTE PTR __Kseparator$[ebp]
	test	edx, edx
	je	SHORT $L12222

; 1269 : 				_Dest = _Rep(_Dest, _Kseparator, 1);

	push	1
	mov	al, BYTE PTR __Kseparator$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR $T14014[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
	add	esp, 24					; 00000018H
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR __Dest$[ebp], edx
	mov	DWORD PTR __Dest$[ebp+4], eax
$L12222:

; 1270 : 			}

	jmp	$L12214
$L12215:

; 1271 : 		return (_Dest);

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR __Dest$[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1272 : 		}

	add	esp, 28					; 0000001cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Putgrouped@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDID@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Putgrouped
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xutility
_TEXT	ENDS
;	COMDAT ??4?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@D@Z
_TEXT	SEGMENT
$T14018 = -12						; size = 4
$T14017 = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 1
??4?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@D@Z PROC NEAR ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator=, COMDAT
; _this$ = ecx

; 980  : 		{	// store element and increment

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 981  : 		if (_Strbuf == 0
; 982  : 			|| traits_type::eq_int_type(_Traits::eof(),
; 983  : 				_Strbuf->sputc(_Right)))

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $L12229
	mov	cl, BYTE PTR __Right$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	call	?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z ; std::basic_streambuf<char,std::char_traits<char> >::sputc
	mov	DWORD PTR $T14017[ebp], eax
	call	?eof@?$char_traits@D@std@@SAHXZ		; std::char_traits<char>::eof
	mov	DWORD PTR $T14018[ebp], eax
	lea	eax, DWORD PTR $T14017[ebp]
	push	eax
	lea	ecx, DWORD PTR $T14018[ebp]
	push	ecx
	call	?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z ; std::char_traits<char>::eq_int_type
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $L12228
$L12229:

; 984  : 			_Failed = true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax], 1
$L12228:

; 985  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 986  : 		}

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@D@Z ENDP ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator=
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??D?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ PROC NEAR ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator*, COMDAT
; _this$ = ecx

; 989  : 		{	// pretend to get designated element

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 990  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 991  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??D?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ENDP ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator*
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??E?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??E?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ PROC NEAR ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator++, COMDAT
; _this$ = ecx

; 994  : 		{	// pretend to preincrement

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 995  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 996  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??E?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ENDP ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator++
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xlocnum
_TEXT	ENDS
;	COMDAT ?decimal_point@?$numpunct@D@std@@QBEDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?decimal_point@?$numpunct@D@std@@QBEDXZ PROC NEAR	; std::numpunct<char>::decimal_point, COMDAT
; _this$ = ecx

; 38   : 		{	// return decimal point

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 39   : 		return (do_decimal_point());

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+4]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 40   : 		}

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?decimal_point@?$numpunct@D@std@@QBEDXZ ENDP		; std::numpunct<char>::decimal_point
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?thousands_sep@?$numpunct@D@std@@QBEDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?thousands_sep@?$numpunct@D@std@@QBEDXZ PROC NEAR	; std::numpunct<char>::thousands_sep, COMDAT
; _this$ = ecx

; 43   : 		{	// return thousands separator

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 44   : 		return (do_thousands_sep());

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+8]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 45   : 		}

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?thousands_sep@?$numpunct@D@std@@QBEDXZ ENDP		; std::numpunct<char>::thousands_sep
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?grouping@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
$T14030 = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?grouping@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC NEAR ; std::numpunct<char>::grouping, COMDAT
; _this$ = ecx

; 48   : 		{	// return grouping string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T14030[ebp], 0

; 49   : 		return (do_grouping());

	mov	esi, esp
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+12]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	eax, DWORD PTR $T14030[ebp]
	or	eax, 1
	mov	DWORD PTR $T14030[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 50   : 		}

	pop	esi
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?grouping@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::numpunct<char>::grouping
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xstring
_TEXT	ENDS
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Num$ = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 502  : 		{	// append _Right [_Roff, _Roff + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 503  : 		if (_Right.size() < _Roff)

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	cmp	eax, DWORD PTR __Roff$[ebp]
	jae	SHORT $L12252

; 504  : 			_String_base::_Xran();	// _Roff off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@_String_base@std@@QBEXXZ		; std::_String_base::_Xran
$L12252:

; 505  : 		size_type _Num = _Right.size() - _Roff;

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	sub	eax, DWORD PTR __Roff$[ebp]
	mov	DWORD PTR __Num$[ebp], eax

; 506  : 		if (_Num < _Count)

	mov	eax, DWORD PTR __Num$[ebp]
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	SHORT $L12254

; 507  : 			_Count = _Num;	// trim _Count to size

	mov	ecx, DWORD PTR __Num$[ebp]
	mov	DWORD PTR __Count$[ebp], ecx
$L12254:

; 508  : 		if (npos - _Mysize <= _Count)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::npos
	sub	eax, DWORD PTR [edx+20]
	cmp	eax, DWORD PTR __Count$[ebp]
	ja	SHORT $L12255

; 509  : 			_String_base::_Xlen();	// result too long

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xlen@_String_base@std@@QBEXXZ		; std::_String_base::_Xlen
$L12255:

; 510  : 
; 511  : 		if (0 < _Count && _Grow(_Num = _Mysize + _Count))

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $L12256
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	add	edx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Num$[ebp], edx
	push	0
	mov	eax, DWORD PTR __Num$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $L12256

; 512  : 			{	// make room and append new stuff
; 513  : 			_Traits::copy(_Myptr() + _Mysize,
; 514  : 				_Right._Myptr() + _Roff, _Count);

	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	add	eax, DWORD PTR __Roff$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+20]
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 515  : 			_Eos(_Num);

	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$L12256:

; 516  : 			}
; 517  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 518  : 		}

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
PUBLIC	??$_Allocate@D@std@@YAPADIPAD@Z			; std::_Allocate<char>
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC NEAR	; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 136  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 137  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@D@std@@YAPADIPAD@Z		; std::_Allocate<char>
	add	esp, 8

; 138  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -12						; size = 4
__Count$ = -8						; size = 4
_this$ = -4						; size = 4
?max_size@?$allocator@D@std@@QBEIXZ PROC NEAR		; std::allocator<char>::max_size, COMDAT
; _this$ = ecx

; 156  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 157  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

	mov	DWORD PTR __Count$[ebp], -1

; 158  : 		return (0 < _Count ? _Count : 1);

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $L14038
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	jmp	SHORT $L14039
$L14038:
	mov	DWORD PTR tv65[ebp], 1
$L14039:
	mov	eax, DWORD PTR tv65[ebp]

; 159  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@D@std@@QBEIXZ ENDP		; std::allocator<char>::max_size
_TEXT	ENDS
PUBLIC	?_Psave@?$_Facetptr@V?$numpunct@D@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::numpunct<char> >::_Psave
PUBLIC	?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@@Z ; std::numpunct<char>::_Getcat
;	COMDAT ?_Psave@?$_Facetptr@V?$numpunct@D@std@@@std@@2PBVfacet@locale@2@B
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xlocale
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$numpunct@D@std@@@std@@2PBVfacet@locale@2@B DD 01H DUP (?) ; std::_Facetptr<std::numpunct<char> >::_Psave
_BSS	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
$T14052	DD	0ffffffffH
	DD	FLAT:$L14044
$T14046	DD	019930520H
	DD	01H
	DD	FLAT:$T14052
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z
_TEXT	SEGMENT
$T14043 = -64						; size = 4
$T14042 = -60						; size = 12
__Pfmod$12473 = -48					; size = 4
__Pf$ = -44						; size = 4
__Id$ = -40						; size = 4
__Psave$ = -32						; size = 4
__Lock$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Loc$ = 8						; size = 4
??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z PROC NEAR ; std::use_facet<std::numpunct<char> >, COMDAT

; 315  : 	{	// get facet reference from locale

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 52					; 00000034H
	push	edi
	lea	edi, DWORD PTR [ebp-64]
	mov	ecx, 13					; 0000000dH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 316  : 	_Lockit _Lock(_LOCK_LOCALE);	// the thread lock, make get atomic

	push	0
	lea	ecx, DWORD PTR __Lock$[ebp]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 317  : 	const locale::facet *_Psave =
; 318  : 		_Facetptr<_Facet>::_Psave;	// static pointer to lazy facet

	mov	eax, DWORD PTR ?_Psave@?$_Facetptr@V?$numpunct@D@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::numpunct<char> >::_Psave
	mov	DWORD PTR __Psave$[ebp], eax

; 319  : 
; 320  : 	size_t _Id = _Facet::id;

	mov	ecx, OFFSET FLAT:?id@?$numpunct@D@std@@2V0locale@2@A ; std::numpunct<char>::id
	call	??Bid@locale@std@@QAEIXZ		; std::locale::id::operator unsigned int
	mov	DWORD PTR __Id$[ebp], eax

; 321  : 	const locale::facet *_Pf = _Loc._Getfacet(_Id);

	mov	ecx, DWORD PTR __Id$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Loc$[ebp]
	call	?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z ; std::locale::_Getfacet
	mov	DWORD PTR __Pf$[ebp], eax

; 322  : 
; 323  : 	if (_Pf != 0)

	cmp	DWORD PTR __Pf$[ebp], 0
	je	SHORT $L12464

; 324  : 		;	// got facet from locale
; 325  : 	else if (_Psave != 0)

	jmp	SHORT $L12465
$L12464:
	cmp	DWORD PTR __Psave$[ebp], 0
	je	SHORT $L12466

; 326  : 		_Pf = _Psave;	// lazy facet already allocated

	mov	edx, DWORD PTR __Psave$[ebp]
	mov	DWORD PTR __Pf$[ebp], edx

; 327  : 	else if (_Facet::_Getcat(&_Psave) == (size_t)(-1))

	jmp	SHORT $L12465
$L12466:
	lea	eax, DWORD PTR __Psave$[ebp]
	push	eax
	call	?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@@Z ; std::numpunct<char>::_Getcat
	add	esp, 4
	cmp	eax, -1
	jne	SHORT $L12469

; 328  : 
; 329  :  #if _HAS_EXCEPTIONS
; 330  : 		throw bad_cast();	// lazy disallowed

	push	OFFSET FLAT:??_C@_08EPJLHIJG@bad?5cast?$AA@
	lea	ecx, DWORD PTR $T14042[ebp]
	call	??0bad_cast@@QAE@PBD@Z			; bad_cast::bad_cast
	push	OFFSET FLAT:__TI2?AVbad_cast@@
	lea	ecx, DWORD PTR $T14042[ebp]
	push	ecx
	call	__CxxThrowException@8
$L12469:

; 331  : 
; 332  :  #else /* _HAS_EXCEPTIONS */
; 333  : 		abort();	// lazy disallowed
; 334  :  #endif /* _HAS_EXCEPTIONS */
; 335  : 
; 336  : 	else
; 337  : 		{	// queue up lazy facet for destruction
; 338  : 		_Pf = _Psave;

	mov	edx, DWORD PTR __Psave$[ebp]
	mov	DWORD PTR __Pf$[ebp], edx

; 339  : 		_Facetptr<_Facet>::_Psave = _Psave;

	mov	eax, DWORD PTR __Psave$[ebp]
	mov	DWORD PTR ?_Psave@?$_Facetptr@V?$numpunct@D@std@@@std@@2PBVfacet@locale@2@B, eax ; std::_Facetptr<std::numpunct<char> >::_Psave

; 340  : 
; 341  : 		locale::facet *_Pfmod = (_Facet *)_Psave;

	mov	ecx, DWORD PTR __Psave$[ebp]
	mov	DWORD PTR __Pfmod$12473[ebp], ecx

; 342  : 		_Pfmod->_Incref();

	mov	ecx, DWORD PTR __Pfmod$12473[ebp]
	call	?_Incref@facet@locale@std@@QAEXXZ	; std::locale::facet::_Incref

; 343  : 		_Pfmod->_Register();

	mov	ecx, DWORD PTR __Pfmod$12473[ebp]
	call	?_Register@facet@locale@std@@QAEXXZ	; std::locale::facet::_Register
$L12465:

; 344  : 		}
; 345  : 
; 346  : 	return ((const _Facet&)(*_Pf));	// should be dynamic_cast

	mov	edx, DWORD PTR __Pf$[ebp]
	mov	DWORD PTR $T14043[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Lock$[ebp]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	mov	eax, DWORD PTR $T14043[ebp]
$L14041:

; 347  : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L14051
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	add	esp, 64					; 00000040H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$L14051:
	DD	2
	DD	$L14050
$L14050:
	DD	-20					; ffffffecH
	DD	4
	DD	$L14047
	DD	-32					; ffffffe0H
	DD	4
	DD	$L14048
$L14048:
	DB	95					; 0000005fH
	DB	80					; 00000050H
	DB	115					; 00000073H
	DB	97					; 00000061H
	DB	118					; 00000076H
	DB	101					; 00000065H
	DB	0
$L14047:
	DB	95					; 0000005fH
	DB	76					; 0000004cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L14044:
	lea	ecx, DWORD PTR __Lock$[ebp]
	jmp	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
__ehhandler$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z:
	mov	eax, OFFSET FLAT:$T14046
	jmp	___CxxFrameHandler
text$x	ENDS
??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z ENDP ; std::use_facet<std::numpunct<char> >
; Function compile flags: /Odt /RTCsu
;	COMDAT ??$_Maklocchr@D@std@@YADDPADABU_Cvtvec@@@Z
_TEXT	SEGMENT
__Byte$ = 8						; size = 1
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Maklocchr@D@std@@YADDPADABU_Cvtvec@@@Z PROC NEAR	; std::_Maklocchr<char>, COMDAT

; 430  : 	{	// convert char to _Elem using _Cvtvec

	push	ebp
	mov	ebp, esp

; 431  : 	return ((_Elem)(unsigned char)_Byte);

	mov	al, BYTE PTR __Byte$[ebp]

; 432  : 	}

	pop	ebp
	ret	0
??$_Maklocchr@D@std@@YADDPADABU_Cvtvec@@@Z ENDP		; std::_Maklocchr<char>
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@D@std@@YAPADIPAD@Z PROC NEAR		; std::_Allocate<char>, COMDAT

; 33   : 	{	// allocate storage for _Count elements of type _Ty

	push	ebp
	mov	ebp, esp

; 34   : 	return ((_Ty _FARQ *)operator new(_Count * sizeof (_Ty)));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 35   : 	}

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
??$_Allocate@D@std@@YAPADIPAD@Z ENDP			; std::_Allocate<char>
_TEXT	ENDS
PUBLIC	??0?$numpunct@D@std@@QAE@I@Z			; std::numpunct<char>::numpunct<char>
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xlocnum
xdata$x	SEGMENT
$T14070	DD	0ffffffffH
	DD	FLAT:$L14066
$T14068	DD	019930520H
	DD	01H
	DD	FLAT:$T14070
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@@Z
_TEXT	SEGMENT
tv80 = -24						; size = 4
$T14063 = -20						; size = 4
$T14062 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ppf$ = 8						; size = 4
?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@@Z PROC NEAR ; std::numpunct<char>::_Getcat, COMDAT

; 75   : 		{	// return locale category mask and construct standard facet

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-24], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-20], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-16], -858993460		; ccccccccH

; 76   : 		if (_Ppf != 0 && *_Ppf == 0)

	cmp	DWORD PTR __Ppf$[ebp], 0
	je	SHORT $L12502
	mov	eax, DWORD PTR __Ppf$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $L12502

; 77   : 			*_Ppf = _NEW_CRT numpunct<_Elem>;

	push	77					; 0000004dH
	push	OFFSET FLAT:??_C@_0EN@IBFBLEEG@D?3?2Program?5Files?5?$CIx86?$CJ?2Microsoft@
	push	OFFSET FLAT:?_DebugHeapTag@std@@3U_DebugHeapTag_t@1@B ; std::_DebugHeapTag
	push	24					; 00000018H
	call	??2@YAPAXIABU_DebugHeapTag_t@std@@PADH@Z ; operator new
	add	esp, 16					; 00000010H
	mov	DWORD PTR $T14063[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T14063[ebp], 0
	je	SHORT $L14064
	push	0
	mov	ecx, DWORD PTR $T14063[ebp]
	call	??0?$numpunct@D@std@@QAE@I@Z		; std::numpunct<char>::numpunct<char>
	mov	DWORD PTR tv80[ebp], eax
	jmp	SHORT $L14065
$L14064:
	mov	DWORD PTR tv80[ebp], 0
$L14065:
	mov	ecx, DWORD PTR tv80[ebp]
	mov	DWORD PTR $T14062[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR __Ppf$[ebp]
	mov	eax, DWORD PTR $T14062[ebp]
	mov	DWORD PTR [edx], eax
$L12502:

; 78   : 		return (_X_NUMERIC);

	mov	eax, 4

; 79   : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 24					; 00000018H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L14066:
	push	77					; 0000004dH
	push	OFFSET FLAT:??_C@_0EN@IBFBLEEG@D?3?2Program?5Files?5?$CIx86?$CJ?2Microsoft@
	push	OFFSET FLAT:?_DebugHeapTag@std@@3U_DebugHeapTag_t@1@B ; std::_DebugHeapTag
	mov	eax, DWORD PTR $T14063[ebp]
	push	eax
	call	??3@YAXPAXABU_DebugHeapTag_t@std@@PADH@Z ; operator delete
	add	esp, 16					; 00000010H
	ret	0
__ehhandler$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@@Z:
	mov	eax, OFFSET FLAT:$T14068
	jmp	___CxxFrameHandler
text$x	ENDS
?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@@Z ENDP ; std::numpunct<char>::_Getcat
PUBLIC	??_R4?$numpunct@D@std@@6B@			; std::numpunct<char>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$numpunct@D@std@@@8			; std::numpunct<char> `RTTI Type Descriptor'
PUBLIC	??_R3?$numpunct@D@std@@8			; std::numpunct<char>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$numpunct@D@std@@8			; std::numpunct<char>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@A@?$numpunct@D@std@@8		; std::numpunct<char>::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@@Z	; std::numpunct<char>::_Init
PUBLIC	?do_decimal_point@?$numpunct@D@std@@MBEDXZ	; std::numpunct<char>::do_decimal_point
PUBLIC	?do_thousands_sep@?$numpunct@D@std@@MBEDXZ	; std::numpunct<char>::do_thousands_sep
PUBLIC	?do_grouping@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::do_grouping
PUBLIC	?do_falsename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::do_falsename
PUBLIC	?do_truename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::do_truename
PUBLIC	??_7?$numpunct@D@std@@6B@			; std::numpunct<char>::`vftable'
PUBLIC	??_G?$numpunct@D@std@@MAEPAXI@Z			; std::numpunct<char>::`scalar deleting destructor'
EXTRN	??_E?$numpunct@D@std@@MAEPAXI@Z:NEAR		; std::numpunct<char>::`vector deleting destructor'
;	COMDAT xdata$x
xdata$x	SEGMENT
$T14081	DD	0ffffffffH
	DD	FLAT:$L14076
	DD	00H
	DD	FLAT:$L14077
$T14079	DD	019930520H
	DD	02H
	DD	FLAT:$T14081
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_7?$numpunct@D@std@@6B@
CONST	SEGMENT
??_7?$numpunct@D@std@@6B@ DD FLAT:??_R4?$numpunct@D@std@@6B@ ; std::numpunct<char>::`vftable'
	DD	FLAT:??_E?$numpunct@D@std@@MAEPAXI@Z
	DD	FLAT:?do_decimal_point@?$numpunct@D@std@@MBEDXZ
	DD	FLAT:?do_thousands_sep@?$numpunct@D@std@@MBEDXZ
	DD	FLAT:?do_grouping@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
	DD	FLAT:?do_falsename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
	DD	FLAT:?do_truename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
CONST	ENDS
;	COMDAT ??_R4?$numpunct@D@std@@6B@
rdata$r	SEGMENT
??_R4?$numpunct@D@std@@6B@ DD 00H			; std::numpunct<char>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$numpunct@D@std@@@8
	DD	FLAT:??_R3?$numpunct@D@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$numpunct@D@std@@@8
_DATA	SEGMENT
??_R0?AV?$numpunct@D@std@@@8 DD FLAT:??_7type_info@@6B@	; std::numpunct<char> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$numpunct@D@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R3?$numpunct@D@std@@8
rdata$r	SEGMENT
??_R3?$numpunct@D@std@@8 DD 00H				; std::numpunct<char>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2?$numpunct@D@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$numpunct@D@std@@8
rdata$r	SEGMENT
??_R2?$numpunct@D@std@@8 DD FLAT:??_R1A@?0A@A@?$numpunct@D@std@@8 ; std::numpunct<char>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@A@facet@locale@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@?$numpunct@D@std@@8
rdata$r	SEGMENT
??_R1A@?0A@A@?$numpunct@D@std@@8 DD FLAT:??_R0?AV?$numpunct@D@std@@@8 ; std::numpunct<char>::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
; Function compile flags: /Odt /RTCsu
rdata$r	ENDS
;	COMDAT ??0?$numpunct@D@std@@QAE@I@Z
_TEXT	SEGMENT
tv77 = -140						; size = 4
tv65 = -136						; size = 4
$T14075 = -132						; size = 116
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Refs$ = 8						; size = 4
??0?$numpunct@D@std@@QAE@I@Z PROC NEAR			; std::numpunct<char>::numpunct<char>, COMDAT
; _this$ = ecx

; 64   : 		{	// construct from current locale

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$numpunct@D@std@@QAE@I@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 128				; 00000080H
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-140]
	mov	ecx, 32					; 00000020H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Refs$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0facet@locale@std@@IAE@I@Z		; std::locale::facet::facet
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET FLAT:??_7?$numpunct@D@std@@6B@

; 65   : 		_Init(_Locinfo());

	push	OFFSET FLAT:??_C@_01GFHCPBMG@C?$AA@
	lea	ecx, DWORD PTR $T14075[ebp]
	call	??0_Locinfo@std@@QAE@PBD@Z		; std::_Locinfo::_Locinfo
	mov	DWORD PTR tv65[ebp], eax
	mov	edx, DWORD PTR tv65[ebp]
	mov	DWORD PTR tv77[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR tv77[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@@Z ; std::numpunct<char>::_Init
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T14075[ebp]
	call	??1_Locinfo@std@@QAE@XZ			; std::_Locinfo::~_Locinfo

; 66   : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	add	esp, 140				; 0000008cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L14076:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1facet@locale@std@@UAE@XZ		; std::locale::facet::~facet
$L14077:
	lea	ecx, DWORD PTR $T14075[ebp]
	jmp	??1_Locinfo@std@@QAE@XZ			; std::_Locinfo::~_Locinfo
__ehhandler$??0?$numpunct@D@std@@QAE@I@Z:
	mov	eax, OFFSET FLAT:$T14079
	jmp	___CxxFrameHandler
text$x	ENDS
??0?$numpunct@D@std@@QAE@I@Z ENDP			; std::numpunct<char>::numpunct<char>
; Function compile flags: /Odt /RTCsu
;	COMDAT ?do_decimal_point@?$numpunct@D@std@@MBEDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?do_decimal_point@?$numpunct@D@std@@MBEDXZ PROC NEAR	; std::numpunct<char>::do_decimal_point, COMDAT
; _this$ = ecx

; 111  : 		{	// return decimal point

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 112  : 		return (_Dp);

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+12]

; 113  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?do_decimal_point@?$numpunct@D@std@@MBEDXZ ENDP		; std::numpunct<char>::do_decimal_point
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?do_thousands_sep@?$numpunct@D@std@@MBEDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?do_thousands_sep@?$numpunct@D@std@@MBEDXZ PROC NEAR	; std::numpunct<char>::do_thousands_sep, COMDAT
; _this$ = ecx

; 116  : 		{	// return thousands separator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 117  : 		return (_Kseparator);

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+13]

; 118  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?do_thousands_sep@?$numpunct@D@std@@MBEDXZ ENDP		; std::numpunct<char>::do_thousands_sep
_TEXT	ENDS
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odt /RTCsu
;	COMDAT ?do_grouping@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
$T14091 = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?do_grouping@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC NEAR ; std::numpunct<char>::do_grouping, COMDAT
; _this$ = ecx

; 121  : 		{	// return grouping string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T14091[ebp], 0

; 122  : 		return (string(_Grouping));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	edx, DWORD PTR $T14091[ebp]
	or	edx, 1
	mov	DWORD PTR $T14091[ebp], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 123  : 		}

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?do_grouping@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::numpunct<char>::do_grouping
_TEXT	ENDS
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 360  : 		{	// construct from [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >

; 361  : 		_Tidy();

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 362  : 		assign(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 363  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Odt /RTCsu
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 621  : 		{	// assign [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 622  : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	?length@?$char_traits@D@std@@SAIPBD@Z	; std::char_traits<char>::length
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 623  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Num$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 608  : 		{	// assign [_Ptr, _Ptr + _Num)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 609  : 		if (_Inside(_Ptr))

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $L11926

; 610  : 			return (assign(*this, _Ptr - _Myptr(), _Num));	// substring

	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	mov	ecx, DWORD PTR __Ptr$[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	jmp	SHORT $L11925
$L11926:

; 611  : 
; 612  : 		if (_Grow(_Num))

	push	0
	mov	eax, DWORD PTR __Num$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $L11927

; 613  : 			{	// make room and assign new stuff
; 614  : 			_Traits::copy(_Myptr(), _Ptr, _Num);

	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 615  : 			_Eos(_Num);

	mov	ecx, DWORD PTR __Num$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$L11927:

; 616  : 			}
; 617  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$L11925:

; 618  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xlocnum
_TEXT	ENDS
;	COMDAT ?do_falsename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
$T14103 = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?do_falsename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC NEAR ; std::numpunct<char>::do_falsename, COMDAT
; _this$ = ecx

; 126  : 		{	// return name for false

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T14103[ebp], 0

; 127  : 		return (string_type(_Falsename));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	edx, DWORD PTR $T14103[ebp]
	or	edx, 1
	mov	DWORD PTR $T14103[ebp], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 128  : 		}

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?do_falsename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::numpunct<char>::do_falsename
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?do_truename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
$T14108 = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?do_truename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC NEAR ; std::numpunct<char>::do_truename, COMDAT
; _this$ = ecx

; 131  : 		{	// return name for true

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T14108[ebp], 0

; 132  : 		return (string_type(_Truename));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	edx, DWORD PTR $T14108[ebp]
	or	edx, 1
	mov	DWORD PTR $T14108[ebp], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 133  : 		}

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?do_truename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::numpunct<char>::do_truename
_TEXT	ENDS
PUBLIC	??1?$numpunct@D@std@@MAE@XZ			; std::numpunct<char>::~numpunct<char>
; Function compile flags: /Odt /RTCsu
;	COMDAT ??_G?$numpunct@D@std@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$numpunct@D@std@@MAEPAXI@Z PROC NEAR		; std::numpunct<char>::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$numpunct@D@std@@MAE@XZ		; std::numpunct<char>::~numpunct<char>
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $L12147
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L12147:
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_G?$numpunct@D@std@@MAEPAXI@Z ENDP			; std::numpunct<char>::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?_Tidy@?$numpunct@D@std@@AAEXXZ			; std::numpunct<char>::_Tidy
;	COMDAT xdata$x
xdata$x	SEGMENT
$T14118	DD	0ffffffffH
	DD	FLAT:$L14114
$T14116	DD	019930520H
	DD	01H
	DD	FLAT:$T14118
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ??1?$numpunct@D@std@@MAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$numpunct@D@std@@MAE@XZ PROC NEAR			; std::numpunct<char>::~numpunct<char>, COMDAT
; _this$ = ecx

; 83   : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$numpunct@D@std@@MAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	mov	DWORD PTR [ebp-16], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7?$numpunct@D@std@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 84   : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$numpunct@D@std@@AAEXXZ		; std::numpunct<char>::_Tidy

; 85   : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1facet@locale@std@@UAE@XZ		; std::locale::facet::~facet
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L14114:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1facet@locale@std@@UAE@XZ		; std::locale::facet::~facet
__ehhandler$??1?$numpunct@D@std@@MAE@XZ:
	mov	eax, OFFSET FLAT:$T14116
	jmp	___CxxFrameHandler
text$x	ENDS
??1?$numpunct@D@std@@MAE@XZ ENDP			; std::numpunct<char>::~numpunct<char>
PUBLIC	??$_DebugHeapDelete@X@std@@YAXPAX@Z		; std::_DebugHeapDelete<void>
; Function compile flags: /Odt /RTCsu
;	COMDAT ?_Tidy@?$numpunct@D@std@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$numpunct@D@std@@AAEXXZ PROC NEAR		; std::numpunct<char>::_Tidy, COMDAT
; _this$ = ecx

; 137  : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 138  : 		_DELETE_CRT_VEC((void *)_Grouping);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	??$_DebugHeapDelete@X@std@@YAXPAX@Z	; std::_DebugHeapDelete<void>
	add	esp, 4

; 139  : 		_DELETE_CRT_VEC((void *)_Falsename);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	call	??$_DebugHeapDelete@X@std@@YAXPAX@Z	; std::_DebugHeapDelete<void>
	add	esp, 4

; 140  : 		_DELETE_CRT_VEC((void *)_Truename);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	call	??$_DebugHeapDelete@X@std@@YAXPAX@Z	; std::_DebugHeapDelete<void>
	add	esp, 4

; 141  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$numpunct@D@std@@AAEXXZ ENDP			; std::numpunct<char>::_Tidy
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xdebug
_TEXT	ENDS
;	COMDAT ??$_DebugHeapDelete@X@std@@YAXPAX@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_DebugHeapDelete@X@std@@YAXPAX@Z PROC NEAR		; std::_DebugHeapDelete<void>, COMDAT

; 57   : 	{	// delete from the debug CRT heap even if operator delete exists

	push	ebp
	mov	ebp, esp

; 58   : 	if (_Ptr != 0)

	cmp	DWORD PTR __Ptr$[ebp], 0
	je	SHORT $L12477

; 59   : 		{	// worth deleting
; 60   : 		_Ptr->~_Ty();
; 61   : 		// delete as _NORMAL_BLOCK, not _CRT_BLOCK, since we might have
; 62   : 		// facets allocated by normal new.
; 63   : 		free(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	_free
	add	esp, 4
$L12477:

; 64   : 		}
; 65   : 	}

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
??$_DebugHeapDelete@X@std@@YAXPAX@Z ENDP		; std::_DebugHeapDelete<void>
_TEXT	ENDS
PUBLIC	?_Getcvt@_Locinfo@std@@QBE?AU_Cvtvec@@XZ	; std::_Locinfo::_Getcvt
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xlocnum
;	COMDAT ?_Init@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEXABV_Locinfo@2@@Z
_TEXT	SEGMENT
$T14127 = -12						; size = 8
_this$ = -4						; size = 4
__Lobj$ = 8						; size = 4
?_Init@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEXABV_Locinfo@2@@Z PROC NEAR ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Init, COMDAT
; _this$ = ecx

; 806  : 		{	// initialize from _Locinfo object

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 807  : 		_Cvt = _Lobj._Getcvt();

	lea	eax, DWORD PTR $T14127[ebp]
	push	eax
	mov	ecx, DWORD PTR __Lobj$[ebp]
	call	?_Getcvt@_Locinfo@std@@QBE?AU_Cvtvec@@XZ ; std::_Locinfo::_Getcvt
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], edx

; 808  : 		}

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Init@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEXABV_Locinfo@2@@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Init
_TEXT	ENDS
EXTRN	__Getcvt:NEAR
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xlocinfo
;	COMDAT ?_Getcvt@_Locinfo@std@@QBE?AU_Cvtvec@@XZ
_TEXT	SEGMENT
$T14130 = -12						; size = 8
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?_Getcvt@_Locinfo@std@@QBE?AU_Cvtvec@@XZ PROC NEAR	; std::_Locinfo::_Getcvt, COMDAT
; _this$ = ecx

; 81   : 		{	// return codecvt stuff

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 82   : 		return (::_Getcvt());

	call	__Getcvt
	mov	DWORD PTR $T14130[ebp], eax
	mov	DWORD PTR $T14130[ebp+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR $T14130[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR $T14130[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 83   : 		}

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Getcvt@_Locinfo@std@@QBE?AU_Cvtvec@@XZ ENDP		; std::_Locinfo::_Getcvt
_TEXT	ENDS
PUBLIC	??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z	; std::_Maklocstr<char>
PUBLIC	?_Getlconv@_Locinfo@std@@QBEPBUlconv@@XZ	; std::_Locinfo::_Getlconv
PUBLIC	?_Getfalse@_Locinfo@std@@QBEPBDXZ		; std::_Locinfo::_Getfalse
PUBLIC	?_Gettrue@_Locinfo@std@@QBEPBDXZ		; std::_Locinfo::_Gettrue
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xlocnum
xdata$x	SEGMENT
$T14143	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
$T14145	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L14139
$T14144	DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:$T14145
$T14141	DD	019930520H
	DD	02H
	DD	FLAT:$T14143
	DD	01H
	DD	FLAT:$T14144
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@@Z
_TEXT	SEGMENT
tv160 = -96						; size = 4
tv159 = -92						; size = 4
tv158 = -88						; size = 4
tv157 = -84						; size = 4
tv156 = -80						; size = 4
tv155 = -76						; size = 4
tv154 = -72						; size = 4
tv153 = -68						; size = 4
$T14137 = -64						; size = 8
$T14136 = -56						; size = 8
$T14135 = -48						; size = 8
$T14134 = -40						; size = 8
$T14133 = -32						; size = 8
__Ptr$ = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Lobj$ = 8						; size = 4
?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@@Z PROC NEAR	; std::numpunct<char>::_Init, COMDAT
; _this$ = ecx

; 89   : 		{	// initialize from _Lobj

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-96]
	mov	ecx, 20					; 00000014H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 90   : 		const lconv *_Ptr = _Lobj._Getlconv();

	mov	ecx, DWORD PTR __Lobj$[ebp]
	call	?_Getlconv@_Locinfo@std@@QBEPBUlconv@@XZ ; std::_Locinfo::_Getlconv
	mov	DWORD PTR __Ptr$[ebp], eax

; 91   : 
; 92   : 		_Grouping = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 93   : 		_Falsename = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0

; 94   : 		_Truename = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], 0

; 95   : 
; 96   : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 97   : 		_Grouping = _MAKLOCSTR(char, _Ptr->grouping, _Lobj._Getcvt());

	lea	eax, DWORD PTR $T14133[ebp]
	push	eax
	mov	ecx, DWORD PTR __Lobj$[ebp]
	call	?_Getcvt@_Locinfo@std@@QBE?AU_Cvtvec@@XZ ; std::_Locinfo::_Getcvt
	mov	DWORD PTR tv153[ebp], eax
	mov	ecx, DWORD PTR tv153[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR __Ptr$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z ; std::_Maklocstr<char>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv154[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR tv154[ebp]
	mov	DWORD PTR [ecx+8], edx

; 98   : 		_Falsename = _MAKLOCSTR(_Elem, _Lobj._Getfalse(), _Lobj._Getcvt());

	lea	eax, DWORD PTR $T14134[ebp]
	push	eax
	mov	ecx, DWORD PTR __Lobj$[ebp]
	call	?_Getcvt@_Locinfo@std@@QBE?AU_Cvtvec@@XZ ; std::_Locinfo::_Getcvt
	mov	DWORD PTR tv155[ebp], eax
	mov	ecx, DWORD PTR __Lobj$[ebp]
	call	?_Getfalse@_Locinfo@std@@QBEPBDXZ	; std::_Locinfo::_Getfalse
	mov	DWORD PTR tv156[ebp], eax
	mov	ecx, DWORD PTR tv155[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR tv156[ebp]
	push	edx
	call	??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z ; std::_Maklocstr<char>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv157[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR tv157[ebp]
	mov	DWORD PTR [eax+16], ecx

; 99   : 		_Truename = _MAKLOCSTR(_Elem, _Lobj._Gettrue(), _Lobj._Getcvt());

	lea	edx, DWORD PTR $T14135[ebp]
	push	edx
	mov	ecx, DWORD PTR __Lobj$[ebp]
	call	?_Getcvt@_Locinfo@std@@QBE?AU_Cvtvec@@XZ ; std::_Locinfo::_Getcvt
	mov	DWORD PTR tv158[ebp], eax
	mov	ecx, DWORD PTR __Lobj$[ebp]
	call	?_Gettrue@_Locinfo@std@@QBEPBDXZ	; std::_Locinfo::_Gettrue
	mov	DWORD PTR tv159[ebp], eax
	mov	eax, DWORD PTR tv158[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR tv159[ebp]
	push	ecx
	call	??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z ; std::_Maklocstr<char>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv160[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR tv160[ebp]
	mov	DWORD PTR [edx+20], eax
	jmp	SHORT $L14138
$L14139:

; 100  : 		_CATCH_ALL
; 101  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$numpunct@D@std@@AAEXXZ		; std::numpunct<char>::_Tidy

; 102  : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$L14138:

; 103  : 		_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 104  : 
; 105  : 		_Dp = _MAKLOCCHR(_Elem, _Ptr->decimal_point[0], _Lobj._Getcvt());

	lea	ecx, DWORD PTR $T14136[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Lobj$[ebp]
	call	?_Getcvt@_Locinfo@std@@QBE?AU_Cvtvec@@XZ ; std::_Locinfo::_Getcvt
	push	eax
	push	0
	mov	edx, DWORD PTR __Ptr$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	cl, BYTE PTR [eax]
	push	ecx
	call	??$_Maklocchr@D@std@@YADDPADABU_Cvtvec@@@Z ; std::_Maklocchr<char>
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+12], al

; 106  : 		_Kseparator =
; 107  : 			_MAKLOCCHR(_Elem, _Ptr->thousands_sep[0], _Lobj._Getcvt());

	lea	eax, DWORD PTR $T14137[ebp]
	push	eax
	mov	ecx, DWORD PTR __Lobj$[ebp]
	call	?_Getcvt@_Locinfo@std@@QBE?AU_Cvtvec@@XZ ; std::_Locinfo::_Getcvt
	push	eax
	push	0
	mov	ecx, DWORD PTR __Ptr$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	al, BYTE PTR [edx]
	push	eax
	call	??$_Maklocchr@D@std@@YADDPADABU_Cvtvec@@@Z ; std::_Maklocchr<char>
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+13], al
$L14132:

; 108  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 96					; 00000060H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@@Z:
	mov	eax, OFFSET FLAT:$T14141
	jmp	___CxxFrameHandler
text$x	ENDS
?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@@Z ENDP	; std::numpunct<char>::_Init
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xlocinfo
;	COMDAT ?_Getlconv@_Locinfo@std@@QBEPBUlconv@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getlconv@_Locinfo@std@@QBEPBUlconv@@XZ PROC NEAR	; std::_Locinfo::_Getlconv, COMDAT
; _this$ = ecx

; 86   : 		{	// return localeconv stuff

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 87   : 		return (localeconv());

	call	_localeconv

; 88   : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Getlconv@_Locinfo@std@@QBEPBUlconv@@XZ ENDP		; std::_Locinfo::_Getlconv
_TEXT	ENDS
PUBLIC	??_C@_05LAPONLG@false?$AA@			; `string'
;	COMDAT ??_C@_05LAPONLG@false?$AA@
CONST	SEGMENT
??_C@_05LAPONLG@false?$AA@ DB 'false', 00H		; `string'
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ?_Getfalse@_Locinfo@std@@QBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getfalse@_Locinfo@std@@QBEPBDXZ PROC NEAR		; std::_Locinfo::_Getfalse, COMDAT
; _this$ = ecx

; 124  : 		{	// return false name (no C source)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 125  : 		return ("false");

	mov	eax, OFFSET FLAT:??_C@_05LAPONLG@false?$AA@

; 126  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Getfalse@_Locinfo@std@@QBEPBDXZ ENDP			; std::_Locinfo::_Getfalse
_TEXT	ENDS
PUBLIC	??_C@_04LOAJBDKD@true?$AA@			; `string'
;	COMDAT ??_C@_04LOAJBDKD@true?$AA@
CONST	SEGMENT
??_C@_04LOAJBDKD@true?$AA@ DB 'true', 00H		; `string'
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ?_Gettrue@_Locinfo@std@@QBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Gettrue@_Locinfo@std@@QBEPBDXZ PROC NEAR		; std::_Locinfo::_Gettrue, COMDAT
; _this$ = ecx

; 129  : 		{	// return true name (no C source)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 130  : 		return ("true");

	mov	eax, OFFSET FLAT:??_C@_04LOAJBDKD@true?$AA@

; 131  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Gettrue@_Locinfo@std@@QBEPBDXZ ENDP			; std::_Locinfo::_Gettrue
_TEXT	ENDS
PUBLIC	??_C@_0EN@CBMLGOH@D?3?2Program?5Files?5?$CIx86?$CJ?2Microsoft@ ; `string'
EXTRN	??_U@YAPAXIABU_DebugHeapTag_t@std@@PADH@Z:NEAR	; operator new[]
;	COMDAT ??_C@_0EN@CBMLGOH@D?3?2Program?5Files?5?$CIx86?$CJ?2Microsoft@
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xlocale
CONST	SEGMENT
??_C@_0EN@CBMLGOH@D?3?2Program?5Files?5?$CIx86?$CJ?2Microsoft@ DB 'D:\Pro'
	DB	'gram Files (x86)\Microsoft Visual Studio .NET 2003\Vc7\includ'
	DB	'e\xlocale', 00H				; `string'
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z
_TEXT	SEGMENT
$T14156 = -16						; size = 4
__Ptrnext$12563 = -12					; size = 4
__Ptrdest$ = -8						; size = 4
__Count$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z PROC NEAR ; std::_Maklocstr<char>, COMDAT

; 452  : 	{	// convert C string to _Elem sequence using _Cvtvec

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 453  : 	size_t _Count = ::strlen(_Ptr) + 1;

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	add	eax, 1
	mov	DWORD PTR __Count$[ebp], eax

; 454  : 	_Elem *_Ptrdest = _NEW_CRT _Elem[_Count];

	push	454					; 000001c6H
	push	OFFSET FLAT:??_C@_0EN@CBMLGOH@D?3?2Program?5Files?5?$CIx86?$CJ?2Microsoft@
	push	OFFSET FLAT:?_DebugHeapTag@std@@3U_DebugHeapTag_t@1@B ; std::_DebugHeapTag
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	call	??_U@YAPAXIABU_DebugHeapTag_t@std@@PADH@Z ; operator new[]
	add	esp, 16					; 00000010H
	mov	DWORD PTR $T14156[ebp], eax
	mov	edx, DWORD PTR $T14156[ebp]
	mov	DWORD PTR __Ptrdest$[ebp], edx

; 455  : 
; 456  : 	for (_Elem *_Ptrnext = _Ptrdest; 0 < _Count; --_Count, ++_Ptrnext, ++_Ptr)

	mov	eax, DWORD PTR __Ptrdest$[ebp]
	mov	DWORD PTR __Ptrnext$12563[ebp], eax
	jmp	SHORT $L12564
$L12565:
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Count$[ebp], ecx
	mov	edx, DWORD PTR __Ptrnext$12563[ebp]
	add	edx, 1
	mov	DWORD PTR __Ptrnext$12563[ebp], edx
	mov	eax, DWORD PTR __Ptr$[ebp]
	add	eax, 1
	mov	DWORD PTR __Ptr$[ebp], eax
$L12564:
	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $L12566

; 457  : 		*_Ptrnext = (_Elem)(unsigned char)*_Ptr;

	mov	ecx, DWORD PTR __Ptrnext$12563[ebp]
	mov	edx, DWORD PTR __Ptr$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx], al
	jmp	SHORT $L12565
$L12566:

; 458  : 	return (_Ptrdest);

	mov	eax, DWORD PTR __Ptrdest$[ebp]

; 459  : 	}

	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z ENDP	; std::_Maklocstr<char>
_TEXT	ENDS
PUBLIC	??0id@locale@std@@QAE@I@Z			; std::locale::id::id
;	COMDAT CRT$XCU
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xlocnum
CRT$XCU	SEGMENT
_$S2	DD	FLAT:_$E1
; Function compile flags: /Odt /RTCsu
CRT$XCU	ENDS
;	COMDAT _$E1
text$yc	SEGMENT
_$E1	PROC NEAR					; COMDAT

; 806  : 		{	// initialize from _Locinfo object

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET FLAT:?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_$E1	ENDP
; Function compile flags: /Odt /RTCsu
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xlocale
text$yc	ENDS
;	COMDAT ??0id@locale@std@@QAE@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
??0id@locale@std@@QAE@I@Z PROC NEAR			; std::locale::id::id, COMDAT
; _this$ = ecx

; 66   : 			{	// construct with specified stamp value

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [eax], ecx

; 67   : 			}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0id@locale@std@@QAE@I@Z ENDP				; std::locale::id::id
_TEXT	ENDS
;	COMDAT CRT$XCU
; File d:\program files (x86)\microsoft visual studio .net 2003\vc7\include\xlocnum
CRT$XCU	SEGMENT
_$S4	DD	FLAT:_$E3
; Function compile flags: /Odt /RTCsu
CRT$XCU	ENDS
;	COMDAT _$E3
text$yc	SEGMENT
_$E3	PROC NEAR					; COMDAT

; 806  : 		{	// initialize from _Locinfo object

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET FLAT:?id@?$numpunct@D@std@@2V0locale@2@A ; std::numpunct<char>::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_$E3	ENDP
text$yc	ENDS
PUBLIC	?id@?$numpunct@D@std@@2V0locale@2@A		; std::numpunct<char>::id
PUBLIC	?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id
;	COMDAT ?id@?$numpunct@D@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@D@std@@2V0locale@2@A DD 01H DUP (?)	; std::numpunct<char>::id
_BSS	ENDS
;	COMDAT ?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id
_BSS	ENDS
END
